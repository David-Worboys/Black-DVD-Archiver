"""
    Produces a DVD folder with an autogenerated menu

    Copyright (C) 2022  David Worboys (-:alumnus Moyhu Primary School et al.:-)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
# Tell Black to leave this block alone (realm of isort)
# fmt: off
import dataclasses
import datetime
import hashlib
import locale
import math
import subprocess
from random import randint
from typing import Final, Optional

import psutil
import xmltodict

import dvdarch_utils
import file_utils
import sqldb
import sys_consts
from configuration_classes import File_Def

# fmt: on

SPUMUX_BUFFER: Final[int] = 43


@dataclasses.dataclass
class DVD_Config:
    _input_videos: list[File_Def] | tuple[File_Def] = dataclasses.field(
        default_factory=tuple
    )
    _menu_labels: list[str] | tuple[str] = dataclasses.field(default_factory=tuple)
    _menu_title: list[str] | tuple[str] = dataclasses.field(default_factory=tuple)
    _menu_background_color: str = "wheat"
    _menu_font_color: str = "gold"
    _menu_font_point_size: int = 24
    _menu_font: str = ""
    _button_background_color: str = "darkgray"
    _button_background_transparency: float = 0.8
    _button_font_color: str = "white"
    _button_font_point_size: int = 12
    _button_font: str = ""
    _menu_aspect_ratio: str = sys_consts.AR43
    _menu_buttons_across: int = 2
    _menu_buttons_per_page: int = 4
    _serial_number: str = ""
    _timestamp_font: str = ""
    _timestamp_font_point_size: int = 11
    _timestamp_prefix: str = "DVD Build Date:"
    _timestamp: str = ""
    _video_standard: str = sys_consts.PAL

    def __post_init__(self):
        if self.menu_background_color.strip() == "":
            self.menu_background_color = "wheat"

        # Get the current locale settings and store them
        current_locale = locale.getlocale(locale.LC_TIME)

        # Set the locale to the user's default locale
        locale.setlocale(locale.LC_TIME, "")

        # Format the timestamp using the user's default locale
        self.timestamp = (
            f"{self.timestamp_prefix} {datetime.datetime.now().strftime('%x %H:%M')}"
        )

        # Restore the previous locale settings
        locale.setlocale(locale.LC_TIME, current_locale)

    @property
    def input_videos(self) -> list[File_Def] | tuple[File_Def]:
        return self._input_videos

    @input_videos.setter
    def input_videos(self, value: list[File_Def] | tuple[File_Def]) -> None:
        assert isinstance(
            value, (list, tuple)
        ), f"{value=}. Must be a list | tuple of File_Def"

        for video_file in value:
            assert isinstance(
                video_file, File_Def
            ), f"{video_file=}. Must be a File_Def"

            assert file_utils.File().path_exists(
                video_file.path
            ), f"{video_file.path=}. Must be a valid file path"

        self._input_videos = value

    @property
    def menu_labels(self) -> list[str] | tuple[str]:
        return self._menu_labels

    @menu_labels.setter
    def menu_labels(self, value: list[str] | tuple[str]) -> None:
        assert isinstance(
            value, (list, tuple)
        ), f"{value=}. Must be a list | tuple of str"

        assert all(
            isinstance(menu_label, str) and menu_label.strip() != ""
            for menu_label in value
        ), f"{value=} must be list | tuple of non-empty strings."

        self._menu_labels = value

    @property
    def menu_background_color(self) -> str:
        return self._menu_background_color

    @menu_background_color.setter
    def menu_background_color(self, value: str) -> None:
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._menu_background_color = value

    @property
    def menu_title(self) -> list[str] | tuple[str]:
        return self._menu_title

    @menu_title.setter
    def menu_title(self, value: list[str] | tuple[str]) -> None:
        assert isinstance(value, (list, tuple)), f"{value=}. Must be a list | tuple str"
        assert all(
            isinstance(title, str) for title in value
        ), f"{value=} must be list | tuple of str"

        self._menu_title = value

    @property
    def menu_aspect_ratio(self) -> str:
        return self._menu_aspect_ratio

    @menu_aspect_ratio.setter
    def menu_aspect_ratio(self, value: str) -> None:
        assert isinstance(value, str), f"{value=}. Must be a string"
        assert value.upper() in (
            sys_consts.AR169,
            sys_consts.AR43,
        ), f"{value=}. Must be AR169 | AR43"

        self._menu_aspect_ratio = value.upper()

    @property
    def menu_font(self) -> str:
        return self._menu_font

    @menu_font.setter
    def menu_font(self, value: str) -> None:
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        if file_utils.File().file_exists(value):
            self._menu_font = value
            return
        else:
            for font in dvdarch_utils.get_fonts():
                if font[0] == value:
                    self._menu_font = font[1]
                    return

        raise RuntimeError(f"{value=}. Font not found")

    @property
    def button_background_color(self) -> str:
        return self._button_background_color

    @button_background_color.setter
    def button_background_color(self, value: str):
        assert isinstance(value, str), "Button background color must be a string."
        self._button_background_color = value

    @property
    def button_background_transparency(self) -> float:
        return self._button_background_transparency

    @button_background_transparency.setter
    def button_background_transparency(self, value: float):
        assert (
            isinstance(value, float) and 0 <= value <= 1
        ), f"{value=}.  0 <= Must be float <= 1"

        self._button_background_transparency = value

    @property
    def button_font_color(self) -> str:
        return self._button_font_color

    @button_font_color.setter
    def button_font_color(self, value: str):
        assert isinstance(value, str), "Button font color must be a string."
        self._button_font_color = value

    @property
    def button_font_point_size(self) -> int:
        return self._button_font_point_size

    @button_font_point_size.setter
    def button_font_point_size(self, value: int):
        assert isinstance(value, int), "Button font point size must be an integer."
        self._button_font_point_size = value

    @property
    def button_font(self) -> str:
        return self._button_font

    @button_font.setter
    def button_font(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        if file_utils.File().file_exists(value):
            self._button_font = value
            return
        else:
            for font in dvdarch_utils.get_fonts():
                if font[0] == value:
                    self._button_font = font[1]
                    return

        raise RuntimeError(f"{value=}. Font not found")

    @property
    def menu_font_color(self) -> str:
        return self._menu_font_color

    @menu_font_color.setter
    def menu_font_color(self, value: str) -> None:
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._menu_font_color = value

    @property
    def menu_font_point_size(self) -> int:
        return self._menu_font_point_size

    @menu_font_point_size.setter
    def menu_font_point_size(self, value: int) -> None:
        assert isinstance(value, int) and value > 1, f"{value=}. Must be an int > 1"

        self._menu_font_point_size = value

    @property
    def menu_buttons_across(self) -> int:
        return self._menu_buttons_across

    @menu_buttons_across.setter
    def menu_buttons_across(self, value: int) -> None:
        assert isinstance(value, int) and value > 0, f"{value=}. Must be an int > 0"

        self._menu_buttons_across = value

    @property
    def menu_buttons_per_page(self) -> int:
        return self._menu_buttons_per_page

    @menu_buttons_per_page.setter
    def menu_buttons_per_page(self, value: int) -> None:
        assert isinstance(value, int) and value > 0, f"{value=}. Must be an int > 0"

        self._menu_buttons_per_page = value

    @property
    def serial_number(self) -> str:
        return self._serial_number

    @serial_number.setter
    def serial_number(self, value: str) -> None:
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._serial_number = value

    @property
    def timestamp_font(self) -> str:
        return self._timestamp_font

    @timestamp_font.setter
    def timestamp_font(self, value: str) -> None:
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        if file_utils.File().path_exists(value):
            self._timestamp_font = value
            return
        else:
            for font in dvdarch_utils.get_fonts():
                if font[0] == value:
                    self._timestamp_font = font[1]
                    return

        raise RuntimeError(f"{value=}. Font not found")

    @property
    def timestamp_font_point_size(self) -> int:
        return self._timestamp_font_point_size

    @timestamp_font_point_size.setter
    def timestamp_font_point_size(self, value: int) -> None:
        assert isinstance(value, int) and value > 1, f"{value=}. Must be an int > 1"

        self._timestamp_font_point_size = value

    @property
    def timestamp_prefix(self) -> str:
        return self._timestamp_prefix

    @timestamp_prefix.setter
    def timestamp_prefix(self, value: str) -> None:
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._timestamp_prefix = value

    @property
    def timestamp(self) -> str:
        return self._timestamp

    @timestamp.setter
    def timestamp(self, value: str) -> None:
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._timestamp = value

    @property
    def video_standard(self):
        return self._video_standard

    @video_standard.setter
    def video_standard(self, value: str) -> None:
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._video_standard = value.upper()

        assert value in (
            sys_consts.PAL,
            sys_consts.NTSC,
        ), f"{value=}. Must be NTSC or PAL"


@dataclasses.dataclass(slots=True)
class _Cell_Coords:
    x0: int = 0
    y0: int = 0
    x1: int = 0
    y1: int = 0
    width: int = 0
    height: int = 0
    page: int = 0
    video_file: File_Def = dataclasses.field(default_factory=File_Def)

    def get_mask_filenames(self, alternate_file_path: str = "") -> tuple[str, ...]:
        """Generate the file names for overlay, highlight, select, and text masks.

        Args:
            alternate_file_path (str) : If provided, use this file path instead of the
                video_file.menu_image_file_path.

        Returns:
            A tuple of four strings representing the file names of the following:
            - overlay_file: A PNG file containing the overlay mask.
            - highlight_file: A PNG file containing the highlight mask.
            - select_file: A PNG file containing the select mask.
            - text_file: A file containing the text (with extension specified by file_extn).
        """

        file_handler = file_utils.File()

        if alternate_file_path:
            path_name, file_name, file_extn = file_handler.split_file_path(
                alternate_file_path
            )
        else:
            path_name, file_name, file_extn = file_handler.split_file_path(
                self.video_file.menu_image_file_path
            )

        suffixes = ["_overlay", "_highlight", "_select", "_text"]
        filenames = []

        for suffix in suffixes:
            if suffix == "_text":
                filename = (
                    file_handler.file_join(
                        path_name, f"{file_name}{suffix}_{self.page}", file_extn
                    )
                    if file_extn
                    else ""
                )
            else:
                filename = file_handler.file_join(
                    path_name, f"{file_name}{suffix}_{self.page}", "png"
                )
            filenames.append(filename)

        return tuple(filenames)


# ===== Public Class
@dataclasses.dataclass
class DVD:
    """Does the grunt work needed to automatically turn video files into a
    DVD Folder/File structure with an auto generated menu"""

    _BACKGROUND_CANVAS_FILE: str = "background_canvas.png"

    # Database
    _db_settings: sqldb.App_Settings = sqldb.App_Settings(sys_consts.PROGRAM_NAME)
    _application_db: Optional[sqldb.SQLDB] = None

    # Internal instance vars
    _dvd_setup: DVD_Config = dataclasses.field(default_factory=DVD_Config)
    _dvd_timestamp_x_offset: int = 10  # TODO Make user configurable

    # folders
    _working_folder: str = ""
    _dvd_working_folder: str = ""
    _dvd_out_folder: str = ""
    _iso_out_folder: str = ""
    _menu_image_folder: str = ""
    _tmp_folder: str = ""
    _vob_folder: str = ""

    # file names
    _background_canvas_file: str = ""

    def __post_init__(self) -> None:
        pass

    @property
    def dvd_setup(self) -> DVD_Config:
        return self._dvd_setup

    @dvd_setup.setter
    def dvd_setup(self, value: DVD_Config) -> None:
        assert isinstance(value, DVD_Config), f"{value=}. Must be a DVD_Setup"

        self._dvd_setup = value

    @property
    def working_folder(self) -> str:
        return self._working_folder

    @working_folder.setter
    def working_folder(self, value: str) -> None:
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._working_folder = value

    @property
    def application_db(self) -> sqldb.SQLDB | None:
        return self._application_db

    @application_db.setter
    def application_db(self, value: sqldb.SQLDB | None) -> None:
        assert (
            isinstance(value, sqldb.SQLDB)
        ) or value is None, f"{value=}. Must be an instance of sqldb.SQLDB or None"

        self._application_db = value

    @property
    def dvd_image_folder(self) -> str:
        return self._dvd_out_folder

    @property
    def iso_folder(self) -> str:
        return self._iso_out_folder

    def build(self) -> tuple[int, str]:
        """Builds the  DVD Folder/File structure

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert (
            len(self.dvd_setup.input_videos) > 0
        ), "Must have at least one input video"
        assert len(self.dvd_setup.menu_labels) > 0, "Must have at least one menu label"
        assert len(self.dvd_setup.input_videos) == len(
            self.dvd_setup.menu_labels
        ), "Input videos and menu_labels must be the same length"

        error_no, error_message = self._build_working_folders()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._encode_video()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._extract_menu_images()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._create_dvd_menu()

        if error_no == -1:
            return error_no, error_message

        return 1, ""

    def generate_dvd_serial_number(
        self, product_code: str = "HV", product_description="Home Video"
    ) -> str:
        """
        Generates a DVD serial number with the format "DVD-AB-000001-5"

        Parameters:
            product_code (str): A string that identifies the product code, e.g. "HV" for home video.
            product_description (str): A string that describes the product code, e.g. "Home Video" for home video.

        Returns:
            str: A string containing the generated DVD serial number.
        """
        assert (
            isinstance(product_code, str) and product_code.strip() != ""
        ), f"{product_code=}. Must be a non-empty string"
        assert (
            isinstance(product_description, str) and product_description.strip() != ""
        ), f"{product_description=}. Must be a non-empty string"

        # Increment the sequential number for each DVD produced
        if not self._db_settings.setting_exist("serial_number"):
            self._db_settings.setting_set("serial_number", 0)

        serial_number: int = self._db_settings.setting_get("serial_number")
        serial_number += 1
        self._db_settings.setting_set("serial_number", serial_number)

        # Generate the serial number string
        serial_number_str = "{:06d}".format(serial_number)
        serial_number_checksum = hashlib.md5(serial_number_str.encode()).hexdigest()[0]
        serial_number_str = (
            f"DVD-{product_code}-{serial_number_str}-{serial_number_checksum}"
        )

        return serial_number_str

    def _build_working_folders(self) -> tuple[int, str]:
        """Builds the working file structure.

        All of these files are disposable once the DVD image is created

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        self._dvd_working_folder = file_handler.file_join(
            self.working_folder, f"{sys_consts.PROGRAM_NAME} DVD Builder"
        )

        if file_handler.path_exists(
            self._dvd_working_folder
        ) and file_handler.path_writeable(
            self._dvd_working_folder
        ):  # Blow it away
            result, message = file_handler.remove_dir_contents(self._dvd_working_folder)

            if result == -1:
                return -1, message

        if file_handler.path_exists(
            self.working_folder
        ) and file_handler.path_writeable(self.working_folder):
            file_handler.make_dir(self._dvd_working_folder)

        if file_handler.path_exists(
            self._dvd_working_folder
        ) and file_handler.path_writeable(self._dvd_working_folder):
            self._dvd_out_folder = file_handler.file_join(
                self._dvd_working_folder, "dvd_image"
            )
            self._iso_out_folder = file_handler.file_join(
                self._dvd_working_folder, "iso_image"
            )
            self._menu_image_folder = file_handler.file_join(
                self._dvd_working_folder, "menu_images"
            )
            self._tmp_folder = file_handler.file_join(self._dvd_working_folder, "tmp")
            self._vob_folder = file_handler.file_join(self._dvd_working_folder, "vobs")

            if file_handler.make_dir(self._dvd_out_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._dvd_out_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._iso_out_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._iso_out_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._menu_image_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._menu_image_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._tmp_folder) == -1:
                return (
                    -1,
                    f"{self._tmp_folder=}. Could Not Be Created Or Is Not Writeable",
                )
            if file_handler.make_dir(self._vob_folder) == -1:
                return (
                    -1,
                    f"{self._vob_folder=}. Could Not Be Created Or Is Not Writeable",
                )

        if not file_handler.path_exists(
            self._dvd_working_folder
        ) and not file_handler.path_writeable(self._dvd_working_folder):
            return (
                -1,
                (
                    f"{self._dvd_working_folder=}. Could Not Be Created Or Is Not"
                    " Writeable"
                ),
            )

        # Build mandatory file paths
        self._background_canvas_file = file_handler.file_join(
            self._tmp_folder, self._BACKGROUND_CANVAS_FILE
        )

        return 1, ""

    def _encode_video(self) -> tuple[int, str]:
        """Encodes the input video files as DVD VOB (mpeg2) files

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()
        video_filters = []
        video_width = 0
        video_height = 0

        # Black Video Choices
        average_bit_rate = sys_consts.AVERAGE_BITRATE

        black_border_size = 12  # TODO Black choice for now

        # Black filter Choices for now TODO Allow some user configuration
        debug = False
        normalise_video_filter = (  # Try to improve exposure of video
            "normalize=blackpt=black:whitept=white:smoothing=11:independence=1"
        )

        video_denoise_filter = "nlmeans=1.0:7:5:3:3"  # Light but fairly fast denoise
        # video_denoise_filter = "nlmeans=7.0:7:5:0:9"  # Light but fairly fast denoise
        # video_denoise_filter ="owdenoise"
        color_correct_filter = "colorcorrect=analyze='median'"  # Fixes white balance
        usharp_filter = "unsharp=luma_amount=0.2"  # Gentle sharpening of luma channel

        # Black frame around the video to hide things like head switching noise
        filter_commands = [
            f"drawbox=x=0:y=0:w=iw:h={black_border_size}:color=black:t=fill",
            f"drawbox=x=0:y=ih-{black_border_size}:w=iw:h={black_border_size}:color=black:t=fill",
            f"drawbox=x=0:y={black_border_size}:w={black_border_size}:h=ih-{black_border_size*2}:color=black:t=fill",
            f"drawbox=x=iw-{black_border_size}:y={black_border_size}:w={black_border_size}:h=ih-{black_border_size*2}:color=black:t=fill",
        ]
        black_box_filter = ",".join(filter_commands)

        # Tries to dering and lighten dark videos somewhat
        auto_bright = "pp=dr/al"

        for video_file in self.dvd_setup.input_videos:
            _, file_name, _ = file_handler.split_file_path(video_file.file_path)
            vob_file = file_handler.file_join(self._vob_folder, file_name, "vob")

            if (
                "video_height" not in video_file.file_info
                or "video_width" not in video_file.file_info
            ):
                return (
                    -1,
                    f"{video_file.file_path=}. Does Not Specify Height and/or Width",
                )

            if "video_ar" not in video_file.file_info:
                return -1, f"{video_file.file_path=}. Does Not Video Aspect Ratio"

            if str(video_file.file_info["video_ar"][1]).startswith("1.33"):
                aspect_ratio = sys_consts.AR43
            elif str(video_file.file_info["video_ar"][1]).startswith("1.78"):
                aspect_ratio = sys_consts.AR169
            else:
                return (
                    -1,
                    (
                        "Unrecognised Aspect Ratio :"
                        f" {video_file.file_info['video_ar'][1]}"
                    ),
                )

            if video_file.video_file_settings.filters_off:
                video_filter_options = [
                    "-vf",  # set video filters,
                    f" {black_box_filter}",  # video filters applied
                ]
            else:
                video_filter_options = []

                if video_file.video_file_settings.normalise:
                    video_filter_options.append(normalise_video_filter)

                if video_file.video_file_settings.denoise:
                    video_filter_options.append(video_denoise_filter)

                if video_file.video_file_settings.white_balance:
                    video_filter_options.append(color_correct_filter)

                if video_file.video_file_settings.sharpen:
                    video_filter_options.append(usharp_filter)

                if video_file.video_file_settings.auto_bright:
                    video_filter_options.append(auto_bright)

                video_filter_options.append(black_box_filter)

                video_filters = ["-vf", ",".join(video_filter_options)]

            video_width = video_file.file_info["video_width"][1]
            video_height = video_file.file_info["video_height"][1]

            if self.dvd_setup.video_standard == sys_consts.PAL:
                frame_rate = f"{sys_consts.PAL_FRAMERATE}"
                if video_width == 720 and video_height == 576:
                    video_size = f"{video_width}x{video_height}"
                else:
                    # TODO Add Resize Filter
                    return (
                        -1,
                        (
                            f"Video {video_width=}x{video_height} does not conform to"
                            " PAL standard size 720x576"
                        ),
                    )
            else:  # NTSC
                frame_rate = f"{sys_consts.NTSC_FRAMERATE}"
                # TODO Add Resize Filter
                if video_width == 720 and video_height == 480:
                    video_size = f"{video_width}x{video_height}"
                else:
                    return (
                        -1,
                        (
                            f"Video {video_width=}x{video_height} does not conform to"
                            " NTSC standard size 720x480"
                        ),
                    )

            if debug:
                command_header = [
                    sys_consts.FFMPG,  # the ffmpeg executable
                    "-report",  # Generate verbose output for debug
                ]
            else:
                command_header = [sys_consts.FFMPG]

            interlaced_flags = []
            if "video_scan_type" in video_file.file_info:
                if (
                    str(video_file.file_info["video_scan_type"][1])
                    .lower()
                    .startswith("interlaced")
                ):
                    interlaced_flags = [
                        "-flags:v:0",  # video flags for the first video stream
                        "+ilme+ildct",  # include interlaced motion estimation and interlaced DCT
                        "-alternate_scan:v:0",  # set alternate scan for first video stream (interlace)
                        "1",  # alternate scan value is 1
                    ]

            command = (
                command_header
                + [
                    "-fflags",  # set ffmpeg flags
                    "+genpts",  # generate presentation timestamps
                    "-threads",  # set number of threads to use
                    f"{psutil.cpu_count(logical=False) - 1}",  # To be responsive use 1 core less than is in the system
                    "-i",  # input flag
                    video_file.file_path,  # path to video file
                ]
                + interlaced_flags
                + [
                    "-f",  # set output format
                    "dvd",  # output format is DVD
                    "-c:v:0",  # codec for the first video stream
                    "mpeg2video",  # use mpeg2video codec
                    "-aspect",  # set aspect ratio
                    aspect_ratio,  # aspect ratio value
                    "-s",  # set resolution
                    video_size,  # resolution value
                    "-r",  # set frame rate
                    frame_rate,  # frame rate value
                    "-g",  # set GOP (group of pictures) size
                    "15",  # GOP size is 15
                    "-pix_fmt",  # set pixel format
                    "yuv420p",  # use YUV 420p pixel format
                    "-b:v",  # set video bitrate
                    f"{average_bit_rate}k",  # average video bitrate is kilobits/sec
                    "-maxrate:v",  # set maximum video rate
                    "9000k",  # maximum video rate is 9000 kilobits/sec
                    "-minrate:v",  # set minimum video rate
                    "0",  # minimum video rate is 0
                    "-bufsize:v",  # set video buffer size
                    "1835008",  # video buffer size is 1835008 bits
                    "-packetsize",  # set packet size
                    "2048",  # packet size is 2048 bits
                    "-muxrate",  # set mux rate
                    "10080000",  # mux rate is 10080000 bits/sec
                    "-force_key_frames",  # force key frames
                    "expr:if(isnan(prev_forced_n),1,eq(n,prev_forced_n + 15))",  # set key frame expression (Closes each GOP)
                ]
                + video_filters
                + [
                    "-b:a",  # set audio bitrate
                    "192000",  # audio bitrate is 192000 bits/sec
                    "-ar",  # set audio sample rate
                    "48000",  # audio sample rate is 48000 samples/sec
                    "-c:a:0",  # codec for the first audio stream
                    "ac3",  # use ac3 codec
                    "-filter:a:0",  # audio filter for the first audio stream
                    "loudnorm=I=-16:LRA=11:TP=-1.5",  # use loudnorm filter with specified parameters
                    "-map",  # set mapping
                    "0:V",  # map first video stream
                    "-map",  # set mapping
                    "0:a",  # map first audio stream
                    "-map",  # set mapping
                    "-0:s",  # exclude first subtitle stream
                    vob_file,  # Output encoded VOB file for inclusion in DVD
                ]
            )

            result, message = dvdarch_utils.execute_check_output(commands=command)

            if result == -1:
                return -1, message

        return 1, ""

    def _create_dvd_menu(self) -> tuple[int, str]:
        """Creates the DVD menu automagically

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        debug = False

        timestamp_height = 0
        buttons_per_page = self.dvd_setup.menu_buttons_per_page
        buttons_across = self.dvd_setup.menu_buttons_across

        dvd_dims = dvdarch_utils.get_dvd_dims(
            self.dvd_setup.menu_aspect_ratio, self.dvd_setup.video_standard
        )
        if dvd_dims.display_height == -1:
            return -1, "Failed To Get DVD Dimensions"

        cell_coords, message = self._calc_layout(
            num_buttons=len(self.dvd_setup.input_videos),
            buttons_per_page=buttons_per_page,
            buttons_across=buttons_across,
            button_aspect_ratio=4 / 3,
            dvd_dims=dvd_dims,
            border_top=10,
            border_bottom=10 + timestamp_height,
            border_left=10,  # + timestamp_height,
            border_right=10,  # + timestamp_height,
        )

        if not cell_coords:
            return -1, message

        result, message = self._create_canvas_image(
            width=dvd_dims.display_width, height=dvd_dims.display_height
        )
        if result == -1:
            return result, message

        canvas_height, message = dvdarch_utils.get_image_height(
            self._background_canvas_file
        )
        if canvas_height == -1:
            return -1, message

        canvas_width, message = dvdarch_utils.get_image_width(
            self._background_canvas_file
        )
        if canvas_width == -1:
            return -1, message

        result, message = self._resize_menu_button_images(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_labels(buttons_per_page=buttons_per_page)

        if result == -1:
            return -1, message

        if debug:
            print("=============================")
            print(f"DBG  {canvas_height=} {canvas_width=} ")
            print(f"DBG {dvd_dims=}")
            print(f"DBG {cell_coords=}")
            print("=============================")

        result, message = self._prepare_buttons(
            cell_coords=cell_coords,
        )

        if result == -1:
            return -1, message

        result, message = self._convert_to_m2v(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._convert_audio(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._multiplex_audio_video(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_menu_mpg(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_dvd_image(buttons_per_page=buttons_per_page)

        if result == -1:
            return -1, message

        return 1, ""

    def _create_labels(self, buttons_per_page: int) -> tuple[int, str]:
        """
        Create images for each label to be placed on the button images.
        Args:
            buttons_per_page (int): The number of buttons on the DVD menu page

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail,
            - arg2: error message or "" if ok
        """
        # Black Choice
        # label_line_height = 0
        # label_lines = 2
        # font: str = "DejaVu-Sans-Bold"
        # pointsize: int = 15
        # fill: str = "white"
        # fill: str = "gold"
        # stroke: str = "black"
        # strokewidth: int = 0
        # word_spacing: int = 0
        # clear_inner_stroke: bool = True
        # line_height: int = 0
        # max_width: int = 0
        # max_lines: int = 1
        # size: int = 0
        # undercolor = "RoyalBlue"
        # background: str = "none"
        # gravity: str = "center"

        file_handler = file_utils.File()

        for video_index, input_video in enumerate(self.dvd_setup.input_videos):
            page = math.floor(video_index / buttons_per_page)
            path_name, file_name, file_extn = file_handler.split_file_path(
                input_video.menu_image_file_path
            )

            # Setup required files
            menu_button_file = file_handler.file_join(path_name, file_name, file_extn)
            menu_button_text_file = file_handler.file_join(
                path_name, f"{file_name}_text_{page}", file_extn
            )

            if not file_handler.file_exists(menu_button_file):
                return -1, f"Video File Does Not Exist : {menu_button_file}"

            menu_text = self.dvd_setup.menu_labels[video_index]

            result, message = dvdarch_utils.overlay_text(
                in_file=menu_button_file,
                out_file=menu_button_text_file,
                text=menu_text,
                text_font=self.dvd_setup.button_font,
                text_pointsize=self.dvd_setup.button_font_point_size,
                text_color=self.dvd_setup.button_font_color,
                position="bottom",
                background_color=self.dvd_setup.button_background_color,
                opacity=self.dvd_setup.button_background_transparency,
                y_offset=10,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _calc_layout(
        self,
        num_buttons: int,
        buttons_per_page: int,
        buttons_across,
        button_aspect_ratio: float,
        dvd_dims: dvdarch_utils.dvd_dims,
        border_top: int = 0,
        border_left: int = 0,
        border_bottom: int = 15,
        border_right: int = 0,
    ) -> tuple[list[_Cell_Coords], str]:
        """
        Generates a layout of rectangles with fixed size borders on each edge,
        arranged to fit within a canvas of fixed aspect ratio.

        Args:
            num_buttons (int): The number of num_buttons to be arranged.
            buttons_per_page (int): The number of buttons on the DVD menu page
            buttons_across (int): The number of buttons across the DVD menu (buttons down is calculated).
            button_aspect_ratio (float): The aspect ratio of the button rectangles (height/width).
            dvd_dims (dvdarch_utils.dvd_dims): The DVD dimensions
            border_top (int): The width of the border at the top edge of the canvas.
            border_left (int): The width of the border at the left edge of the canvas.
            border_bottom (int): The width of the border at the bottom edge of the canvas.
            border_right (int): The width of the border at the right edge of the canvas.
        Returns:
            tuple[list[_Cell_Coords], str]:
            - arg 1: A list of _Cell_Coords objects representing the layout of the rectangles within the canvas.
            - arg 2 : An error message if there is an error.

        """
        assert (
            isinstance(num_buttons, int) and num_buttons > 0
        ), f"{num_buttons=}. Must be int > than zero"
        assert (
            isinstance(button_aspect_ratio, float) and button_aspect_ratio > 0
        ), f"{button_aspect_ratio=}. Must be float > than zero"
        assert isinstance(
            dvd_dims, dvdarch_utils.dvd_dims
        ), f"{dvd_dims=}. Must be a valid dvd_dims object"
        assert (
            isinstance(border_top, int) and border_top >= 0
        ), f"{border_top=}. Must be int >= than zero"
        assert (
            isinstance(border_left, int) and border_left >= 0
        ), f"{border_left=}. Must be int >= than zero"
        assert (
            isinstance(border_bottom, int) and border_bottom >= 0
        ), f"{border_bottom=}. Must be int >= than zero"
        assert (
            isinstance(border_right, int) and border_right >= 0
        ), f"{border_right=}. Must be int >= than zero"

        # ===== Helper
        def _build_page_grid(
            num_buttons: int,
            buttons_per_page: int,
            buttons_across: int,
        ) -> tuple[list[list], int, int]:
            """Builds a page grid.  Empty cells are represented by -1, Non-empty cells are represented by 1.

            Args:
                num_buttons (int): Total number of buttons in the dvd menu.
                buttons_per_page (int): Number of buttons on a single page.
                buttons_across (int): Number of buttons across a single page.

            Returns:
                tuple[list[list], int, int]:
                - arg 1: A list of page grids.
                - arg 2: Number of rows in the page grid.
                - arg 3: Number of columns in the page grid.
            """
            assert (
                isinstance(num_buttons, int) and num_buttons > 0
            ), f"{num_buttons=}. Must be int > 0"
            assert (
                isinstance(buttons_per_page, int) and buttons_per_page > 0
            ), f"{buttons_per_page=}. Must be int > 0"
            assert (
                isinstance(buttons_across, int) and buttons_across > 0
            ), f"{buttons_across=}. Must be int > 0"

            pages = []
            button_count = 0
            num_rows = 0
            num_cols = 0

            if buttons_per_page == 1:
                buttons_down = 1
            else:
                buttons_down = math.ceil(buttons_per_page / buttons_across)

            for _ in range(num_pages):
                page_grid = [
                    [-1 for _ in range(buttons_across)] for _ in range(buttons_down)
                ]

                button_num = 0
                for row_index in range(buttons_down):
                    for col_index in range(buttons_across):
                        if button_num > buttons_per_page - 1:
                            break
                        elif button_count < num_buttons:
                            page_grid[row_index][col_index] = 1
                            button_count += 1
                        else:
                            break

                        button_num += 1

                    if button_num > buttons_per_page - 1 or button_count == num_buttons:
                        break

                pages.append(page_grid)
                num_rows = max(num_rows, len(page_grid))
                num_cols = max(num_cols, len(page_grid[0]))
            return pages, num_rows, num_cols

        # ===== Main

        # TODO Make these values configurable
        header_pad = 10  # Feel good thing
        button_padding = 20  # Min value that works with spumux

        # This keeps spumux happy
        if border_right < SPUMUX_BUFFER:
            border_right = SPUMUX_BUFFER

        if border_left < SPUMUX_BUFFER:
            border_left = SPUMUX_BUFFER

        if not self.dvd_setup.menu_title:  # Header pad is only for titles
            header_pad = 0

        # Compute the canvas size and ratio
        canvas_width = dvd_dims.display_width - (border_left + border_right)
        canvas_height = dvd_dims.display_height - (
            border_top + border_bottom + header_pad
        )

        num_pages = math.ceil(num_buttons / buttons_per_page)

        pages, num_rows, num_cols = _build_page_grid(
            num_buttons=num_buttons,
            buttons_per_page=buttons_per_page,
            buttons_across=buttons_across,
        )

        max_button_height = canvas_height // max(
            num_rows, 4
        )  # Do not change as spumux very sensitive to this

        ## Compute the maximum width of each rectangle based on the number of columns across all pages
        rect_width_max = (
            (canvas_width // num_cols)
            - (num_cols * button_padding)
            - (border_left + border_right)
        )

        # Compute the dimensions of each rectangle and the padding between them
        rect_width = rect_width_max
        rect_height = int(min(canvas_height / num_rows, max_button_height))
        rect_aspect_ratio = rect_width / rect_height

        if rect_aspect_ratio > button_aspect_ratio:
            rect_width = int(rect_height * button_aspect_ratio)
        else:
            rect_height = int(rect_width / button_aspect_ratio)

        # Compute the vertical padding between the rectangles
        if num_rows > 1:
            rect_padding = (canvas_height - rect_height * num_rows) / (num_rows - 1)
        else:
            rect_padding = canvas_height - rect_height * num_rows

        # We do not want the padding to be too big or small, so we max it at
        # twice the horizontal spacing between the rectangles and min it at button_padding.
        if rect_padding < button_padding or rect_padding > 2 * button_padding:
            rect_padding = 2 * button_padding

        # Want buttons in same pos on all pages, so we calc based on first page
        num_non_empty_rows = sum(1 for row in pages[0] if any(col != -1 for col in row))

        # Calculate the total height of the grid
        total_height = (
            num_non_empty_rows * rect_height + (num_non_empty_rows - 1) * rect_padding
        )

        if total_height > canvas_height:
            return (
                [],
                f"Too Many Buttons Down: {total_height=}  >  {canvas_height=}",
            )

            # Calculate the y offset
        y_offset = ((canvas_height - total_height) // 2) + border_top + header_pad

        cell_cords = []
        file_index = 0
        for page_index, page in enumerate(pages):
            for row_index, row in enumerate(page):
                row_col_count = len([col for col in row if col != -1])

                total_width = (row_col_count * rect_width) + (
                    button_padding * (row_col_count - 1)
                )

                if total_width > canvas_width:
                    return (
                        [],
                        f"Too Many Buttons Across: {total_width=}  >  {canvas_width=}",
                    )

                x_offset = (canvas_width - total_width) // 2 + border_right

                col_index = 0
                for col_value in row:
                    if col_value == -1:  # Ignore not on grid
                        continue

                    x = int(x_offset + col_index * (rect_width + button_padding))
                    y = int(y_offset + row_index * (rect_height + rect_padding))

                    if file_index > len(self.dvd_setup.input_videos) - 1:
                        return (
                            [],
                            (
                                "File index out of range 0 -"
                                f" {len(self.dvd_setup.input_videos) - 1}"
                            ),
                        )

                    cell_cords.append(
                        _Cell_Coords(
                            x0=x,
                            y0=y,
                            x1=x + rect_width,
                            y1=y + rect_height,
                            width=rect_width
                            - button_padding,  # Provide space between buttons
                            height=rect_height
                            - button_padding,  # Provide space between buttons
                            page=page_index,
                            video_file=self.dvd_setup.input_videos[file_index],
                        )
                    )
                    file_index += 1
                    col_index += 1
        return cell_cords, ""

    def _create_canvas_image(self, width: int, height: int) -> tuple[int, str]:
        """Creates a background canvas to place the menu elements on

        Args:
            width (int): Width in pixels
            height (int ): Height in pixels

        Returns:
            tuple[int,str]
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(width, int) and width > 0, f"{width=}. Must be int > 0"
        assert isinstance(width, int) and width > 0, f"{height=}. Must be int > 0"

        commands = [
            sys_consts.CONVERT,
            "-size",
            f"{width}x{height}",
            f"xc:{self.dvd_setup.menu_background_color}",
            self._background_canvas_file,
        ]

        result, message = dvdarch_utils.execute_check_output(commands=commands)

        if result == -1:
            return -1, message

        if self.dvd_setup.timestamp_font and self.dvd_setup.timestamp:
            _, timestamp_height = dvdarch_utils.get_text_dims(
                text=self.dvd_setup.timestamp,
                font=self.dvd_setup.timestamp_font,
                pointsize=self.dvd_setup.timestamp_font_point_size,
            )

            if timestamp_height == -1:
                return -1, "Failed to get timestamp height"

            result, message = dvdarch_utils.write_text_on_file(
                input_file=self._background_canvas_file,
                text=self.dvd_setup.timestamp,
                x=self._dvd_timestamp_x_offset,
                y=height - timestamp_height,
                pointsize=self.dvd_setup.timestamp_font_point_size,
                color=self.dvd_setup.menu_font_color,
                font=self.dvd_setup.timestamp_font,
            )

            if result == -1:
                return -1, message

        if self.dvd_setup.timestamp_font and self.dvd_setup.serial_number:
            serial_num_width, serial_num_height = dvdarch_utils.get_text_dims(
                text=self.dvd_setup.serial_number,
                font=self.dvd_setup.timestamp_font,
                pointsize=self.dvd_setup.timestamp_font_point_size,
            )

            if serial_num_height == -1:
                return -1, "Failed to get serial number height"

            result, message = dvdarch_utils.write_text_on_file(
                input_file=self._background_canvas_file,
                text=self.dvd_setup.serial_number,
                x=width - serial_num_width - self._dvd_timestamp_x_offset,
                y=height - serial_num_height,
                pointsize=self.dvd_setup.timestamp_font_point_size,
                color=self.dvd_setup.menu_font_color,
                font=self.dvd_setup.timestamp_font,
            )

            if result == -1:
                return -1, message

            calling_card = (
                f"{sys_consts.PROGRAM_NAME} (c)"
                f" {sys_consts.AUTHOR} {sys_consts.COPYRIGHT_YEAR()}"
            )

            progname_width, progname_height = dvdarch_utils.get_text_dims(
                text=calling_card,
                font=self.dvd_setup.timestamp_font,
                pointsize=self.dvd_setup.timestamp_font_point_size,
            )

            if progname_height == -1:
                return -1, "Failed to get calling card height"

            result, message = dvdarch_utils.write_text_on_file(
                input_file=self._background_canvas_file,
                text=calling_card,
                x=width // 2 - progname_width // 2,
                y=height - progname_height,
                pointsize=self.dvd_setup.timestamp_font_point_size,
                color=self.dvd_setup.menu_font_color,
                font=self.dvd_setup.timestamp_font,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _prepare_buttons(self, cell_coords: list[_Cell_Coords]) -> tuple[int, str]:
        """Prepares the buttons and places them on the requisite image files required to build a dvd menu.

        Args:
            cell_coords (list[_Cell_Coords]): The list of cell coordinates.

        Returns:
            tuple[int, str]: A tuple containing the following values:
                - arg1: 1: ok, -1: fail
                - arg2: error message or "" if ok
        """

        # ===== Helper
        def _get_canvas_overlay_files(
            background_path_name: str, background_file_name: str, page_no: int
        ) -> tuple[int, str, str, str, str]:
            """Returns a tuple containing the paths of canvas overlay, highlight, select, and images files.

            Args:
                background_path_name (str): The path of the background file.
                background_file_name (str): The name of the background file.
                page_no (int): The page number for which the canvas files are required.

            Returns:
                tuple[int, str, str, str, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - The path of the canvas overlay file or error_message of not ok .
                    - The path of the canvas highlight file.
                    - The path of the canvas select file.
                    - The path of the canvas images file.
            """
            assert (
                isinstance(background_path_name, str)
                and background_path_name.strip() != ""
            ), f"{background_path_name=}. Must be non-empty str"
            assert (
                isinstance(background_file_name, str)
                and background_file_name.strip() != ""
            ), f"{background_file_name=}. Must be non-empty str"
            assert (
                isinstance(page_no, int) and page_no >= 0
            ), f"{page_no=}. Must be int >= 0"

            canvas_overlay_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_overlay_{page_no}",
                "png",
            )
            canvas_highlight_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_highlight_{page_no}",
                "png",
            )
            canvas_select_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_select_{page_no}",
                "png",
            )
            canvas_images_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_images_{page_no}",
                "png",
            )

            command = [
                sys_consts.CONVERT,
                self._background_canvas_file,
                canvas_images_file,
            ]

            result, message = dvdarch_utils.execute_check_output(commands=command)

            if result == -1:
                return -1, message, "", "", ""

            return (
                1,
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
                canvas_images_file,
            )

        def _create_canvas_files(
            width: int,
            height: int,
            canvas_overlay_file: str,
            canvas_highlight_file: str,
            canvas_select_file: str,
        ) -> tuple[int, str]:
            """Create canvas image files with specified width and height.

            Args:
                width (int): Width of the canvas image files to create.
                height (int): Height of the canvas image files to create.
                canvas_overlay_file (str): Filename for the canvas overlay file.
                canvas_highlight_file (str): Filename for the canvas highlight file.
                canvas_select_file (str): Filename for the canvas select file.

            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if successful, otherwise -1.
                    - "" if successful, otherwise the error message.
            """
            # Check that the width and height are positive integers
            assert isinstance(width, int) and width > 0, f"{width=}. Must be int >= 0 "
            assert (
                isinstance(height, int) and height > 0
            ), f"{height=}. Must be int >= 0 "
            assert (
                isinstance(canvas_overlay_file, str)
                and canvas_overlay_file.strip() != ""
            ), f"{canvas_overlay_file=}. Cannot be empty."
            assert (
                isinstance(canvas_highlight_file, str)
                and canvas_highlight_file.strip() != ""
            ), f"{canvas_highlight_file=}. Cannot be empty."
            assert (
                isinstance(canvas_select_file, str) and canvas_select_file.strip() != ""
            ), f"{canvas_select_file=}. Cannot be empty."

            for file in (
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
            ):
                result, message = dvdarch_utils.create_transparent_file(
                    width=width,
                    height=height,
                    out_file=file,
                )

                if result == -1:
                    return -1, message
            return 1, ""

        def _create_outline_files(
            width: int,
            height: int,
            overlay_file: str,
            highlight_file: str,
            selected_file: str,
            highlight_border_colour: str = "gold",
            select_border_colour: str = "white",
        ) -> tuple[int, str]:
            """Creates three outline files (highlight, select, and overlay) with transparent backgrounds and colored borders.

            Args:
                width (int): The width of the outline files in pixels.
                height (int): The height of the outline files in pixels.
                overlay_file (str): The name of the overlay file.
                highlight_file (str): The name of the highlight file.
                selected_file (str): The name of the selected file.
                highlight_border_colour (str, optional): The color of the highlight border. Defaults to "gold".
                select_border_colour (str, optional): The color of the select border. Defaults to "white".

            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - "" if ok otherwise the error message
            """
            assert isinstance(width, int), f"{width=}. Must be int >= 0"
            assert isinstance(height, int), f"{height=} . Must be int >= 0"
            assert (
                isinstance(overlay_file, str) and overlay_file.strip() != ""
            ), f"{overlay_file=}. Must be non-empty str"
            assert (
                isinstance(highlight_file, str) and highlight_file.strip() != ""
            ), f"{highlight_file} . Must be non-empty str"
            assert (
                isinstance(selected_file, str) and selected_file.strip() != ""
            ), f"{selected_file} . Must be non-empty str"
            assert (
                isinstance(highlight_border_colour, str)
                and highlight_border_colour.strip() != ""
            ), f"{highlight_border_colour=} . Must be non-empty str"
            assert (
                isinstance(select_border_colour, str)
                and select_border_colour.strip() != ""
            ), f"{select_border_colour=} . Must be non-empty str"

            # Create the 3 outline files we will need - highlight, select, overlay
            for file in (
                (overlay_file, ""),
                (highlight_file, highlight_border_colour),
                (selected_file, select_border_colour),
            ):
                out_file = file[0]
                border_color = file[1]

                result, message = dvdarch_utils.create_transparent_file(
                    width=width,
                    height=height,
                    out_file=out_file,
                    border_color=border_color,
                )

                if result == -1:
                    return -1, message

            return 1, ""

        def _overlay_files(
            x: int, y: int, files: tuple[(str, str), ...]
        ) -> tuple[int, str]:
            """Places a file on another file at a given x, y coord

            Args:
                x (int): x co-ordinate of image
                y (int): y co-ordinate of image
                files (tuple[(str, str), ...]): A tuple of tuples defining the files to be overlaid.
                tuple[0] is the file to be overlaid, tuple[1] is the file to overlay it on.


            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - "" if ok otherwise the error message
            """
            assert isinstance(x, int), f"{x=}. Must be int >= 0"
            assert isinstance(y, int), f"{y=}. Must be int >= 0"
            assert isinstance(files, tuple), f"{files=}. Must be tuple"
            assert all(
                isinstance(file_tuple, tuple) and len(file_tuple) == 2
                for file_tuple in files
            ), f"{files=}. Must be tuple of tuples"

            for file_tuple in files:
                overlaid_file = file_tuple[0]
                overlay_file = file_tuple[1]

                result, message = dvdarch_utils.overlay_file(
                    in_file=overlaid_file,
                    overlay_file=overlay_file,
                    out_file=overlaid_file,
                    x=x,
                    y=y,
                )

                if result == -1:
                    return 1, message
            return 1, ""

        def _write_spumux_xml(
            page: int,
            prev_page: int,
            canvas_highlight_file: str,
            canvas_select_file: str,
            background_path_name: str,
        ) -> tuple[int, str]:
            """
            Write spumux xml file for a new page.

            Args:
                page (int): The current page number.
                prev_page (int): The previous page number.
                canvas_highlight_file (str): The filename of the highlight overlay file.
                canvas_select_file (str): The filename of the select overlay file.
                background_path_name (str): The path name for the background file.

            Returns:
                tuple[int, str]: A tuple of an integer (1 on success, -1 on failure) and a string message.

            """
            assert isinstance(page, int), f"{page=}. Must be int"
            assert isinstance(prev_page, int), f"{prev_page}. Must be int"
            assert (
                isinstance(canvas_highlight_file, str)
                and canvas_highlight_file.strip() != ""
            ), f"{canvas_highlight_file=}. Must be str"
            assert (
                isinstance(canvas_select_file, str) and canvas_select_file.strip() != ""
            ), f"{canvas_select_file}. Must be str"
            assert (
                isinstance(background_path_name, str)
                and background_path_name.strip() != ""
            ), f"{background_path_name}. Must be str"

            spumux_dict = {
                "subpictures": {
                    "@format": self.dvd_setup.video_standard,
                    "stream": {
                        "spu": {
                            "@force": "yes" if prev_page == 0 else "no",
                            "@start": "00:00:00.00",
                            "@image": canvas_highlight_file,  # canvas_overlay_file,
                            "@highlight": canvas_highlight_file,
                            "@select": canvas_select_file,
                            "@autooutline": "infer",
                            "@outlinewidth": "6",
                            "@autoorder": "rows",
                            # "button": spu_buttons #TODO For Later
                        }
                    },
                }
            }

            spumux_xml = file_handler.file_join(
                background_path_name, f"spumux_{page}", "xml"
            )

            try:
                with open(spumux_xml, "w") as result_file:
                    xmltodict.unparse(
                        input_dict=spumux_dict, output=result_file, pretty=True
                    )
            except IOError:
                return -1, f"Sys Error: Could Not Write {spumux_xml}"

            return 1, ""

        # ===== Main
        assert (
            isinstance(cell_coords, list) and len(cell_coords) > 0
        ), f"{cell_coords=}. Must be a non-empty list"

        file_handler = file_utils.File()

        # TODO Black Choices - make user configurable
        pointer_left = "pointer_left"
        pointer_right = "pointer_right"

        right_pointer_file = "pointer.black.right"
        left_pointer_file = "pointer.black.left"
        pointer_file_extn = "png"

        left_pointer_icon_path = file_handler.file_join(
            sys_consts.ICON_PATH,
            left_pointer_file,
            pointer_file_extn,
        )

        right_pointer_icon_path = file_handler.file_join(
            sys_consts.ICON_PATH,
            right_pointer_file,
            pointer_file_extn,
        )

        pointer_width, pointer_height, message = dvdarch_utils.get_image_size(
            left_pointer_icon_path
        )  # Assume left and right are the same size

        if pointer_width == -1 and pointer_height == -1:
            return -1, message

        (
            background_path_name,
            background_file_name,
            back_ground_file_extn,
        ) = file_handler.split_file_path(self._background_canvas_file)

        canvas_width, canvas_height, message = dvdarch_utils.get_image_size(
            self._background_canvas_file
        )

        if canvas_width == -1 and canvas_height == -1:
            return -1, message

        max_page_no = 0
        prev_page = -1

        left_x = SPUMUX_BUFFER
        left_y = canvas_height - (pointer_height + SPUMUX_BUFFER)
        right_x = canvas_width - (pointer_width + SPUMUX_BUFFER)
        right_y = canvas_height - (pointer_height + SPUMUX_BUFFER)

        for coords in cell_coords:
            if coords.page != prev_page:
                prev_page = coords.page
                max_page_no += 1

        # ----- Write out spumux files # TODO Enhance with button name/pos/action, split out to another method then
        prev_page = cell_coords[0].page
        (
            result,
            canvas_overlay_file,
            canvas_highlight_file,
            canvas_select_file,
            canvas_images_file,
        ) = _get_canvas_overlay_files(
            background_path_name=background_path_name,
            background_file_name=background_file_name,
            page_no=0,
        )

        if result == -1:
            return (
                -1,
                canvas_overlay_file,
            )  # Holds error message if result is -1

        result, message = _write_spumux_xml(
            page=0,
            prev_page=-1,
            canvas_highlight_file=canvas_highlight_file,
            canvas_select_file=canvas_select_file,
            background_path_name=background_path_name,
        )

        if result == -1:
            return -1, message

        for cell_index, cell_coord in enumerate(cell_coords):
            if (
                prev_page != cell_coord.page or cell_index == len(cell_coords) - 1
            ):  # Page break
                prev_page = cell_coord.page

                result, message = _write_spumux_xml(
                    page=cell_coord.page,
                    prev_page=-prev_page,
                    canvas_highlight_file=canvas_highlight_file,
                    canvas_select_file=canvas_select_file,
                    background_path_name=background_path_name,
                )

                if result == -1:
                    return -1, message

                (
                    result,
                    canvas_overlay_file,
                    canvas_highlight_file,
                    canvas_select_file,
                    canvas_images_file,
                ) = _get_canvas_overlay_files(
                    background_path_name=background_path_name,
                    background_file_name=background_file_name,
                    page_no=cell_coord.page,
                )

                if result == -1:
                    return (
                        -1,
                        canvas_overlay_file,
                    )  # Holds error message if result is -1

        else:
            result, message = _write_spumux_xml(
                page=cell_coord.page,
                prev_page=-prev_page,
                canvas_highlight_file=canvas_highlight_file,
                canvas_select_file=canvas_select_file,
                background_path_name=background_path_name,
            )

            if result == -1:
                return -1, message

        # ---------- Write Out Required graphics Files
        prev_page = -1

        for cell_index, cell_coord in enumerate(cell_coords):
            (
                button_overlay_file,
                button_highlight_file,
                button_select_file,
                button_text_file,
            ) = cell_coord.get_mask_filenames()

            width, height, message = dvdarch_utils.get_image_size(button_text_file)

            if width == -1 and height == -1:
                return -1, message

            x_padding = math.floor((cell_coord.width - width) / 2)
            y_padding = math.floor((cell_coord.height - height) / 2)

            button_x = cell_coord.x0 + x_padding
            button_y = (
                cell_coord.y0
                + y_padding  # - (pointer_height) if max_page_no > 1 else 0
            )

            if (
                prev_page != cell_coord.page or cell_index > len(cell_coords) - 1
            ):  # Page break
                prev_page = cell_coord.page

                (
                    result,
                    canvas_overlay_file,
                    canvas_highlight_file,
                    canvas_select_file,
                    canvas_images_file,
                ) = _get_canvas_overlay_files(
                    background_path_name=background_path_name,
                    background_file_name=background_file_name,
                    page_no=cell_coord.page,
                )

                if result == -1:
                    return (
                        -1,
                        canvas_overlay_file,
                    )  # Holds error message if result is -1

                command = [
                    sys_consts.CONVERT,
                    self._background_canvas_file,
                    canvas_images_file,
                ]

                result, message = dvdarch_utils.execute_check_output(commands=command)

                if result == -1:
                    return -1, message

                if cell_coord.page <= len(self.dvd_setup.menu_title) - 1:
                    menu_title = self.dvd_setup.menu_title[cell_coord.page]
                else:
                    menu_title = ""

                if menu_title.strip() != "":
                    result, message = dvdarch_utils.overlay_text(
                        in_file=canvas_images_file,
                        text=menu_title,
                        text_font=self.dvd_setup.menu_font,
                        text_pointsize=self.dvd_setup.menu_font_point_size,
                        text_color=self.dvd_setup.menu_font_color,
                        position="top",
                        background_color=self.dvd_setup.menu_background_color,
                        opacity=0.9,
                    )

                    if result == -1:
                        return -1, message

                result, message = _create_canvas_files(
                    width=canvas_width,
                    height=canvas_height,
                    canvas_overlay_file=canvas_overlay_file,
                    canvas_highlight_file=canvas_highlight_file,
                    canvas_select_file=canvas_select_file,
                )

                if result == -1:
                    return -1, message

            # Create button outline files
            result, message = _create_outline_files(
                width=width,
                height=height,
                overlay_file=button_overlay_file,
                highlight_file=button_highlight_file,
                selected_file=button_select_file,
                highlight_border_colour="gold",
                select_border_colour="white",
            )

            if result == -1:
                return -1, message

            # Overlay the button outline files on the canvas
            overlay_files = (
                (canvas_overlay_file, button_overlay_file),
                (canvas_select_file, button_select_file),
                (canvas_highlight_file, button_highlight_file),
                (canvas_images_file, button_text_file),
            )

            result, message = _overlay_files(
                x=button_x, y=button_y, files=overlay_files
            )

            if result == -1:
                return -1, message

            if max_page_no > 1:  # Need pointers to access pages
                path_name, _, _ = file_handler.split_file_path(
                    cell_coord.video_file.menu_image_file_path
                )
                left_pointer_path = file_handler.file_join(
                    path_name,
                    f"{pointer_left}_{cell_coord.page}",
                    pointer_file_extn,
                )

                right_pointer_path = file_handler.file_join(
                    path_name,
                    f"{pointer_right}_{cell_coord.page}",
                    pointer_file_extn,
                )

                (
                    left_pointer_overlay_file,
                    left_pointer_highlight_file,
                    left_pointer_select_file,
                    _,
                ) = cell_coord.get_mask_filenames(left_pointer_path)

                (
                    right_pointer_overlay_file,
                    right_pointer_highlight_file,
                    right_pointer_select_file,
                    _,
                ) = cell_coord.get_mask_filenames(right_pointer_path)

                # Create pointer outline files
                result, message = _create_outline_files(
                    width=pointer_width,
                    height=pointer_height,
                    overlay_file=left_pointer_overlay_file,
                    highlight_file=left_pointer_highlight_file,
                    selected_file=left_pointer_select_file,
                    highlight_border_colour="gold",
                    select_border_colour="white",
                )

                if result == -1:
                    return -1, message

                result, message = _create_outline_files(
                    width=pointer_width,
                    height=pointer_height,
                    overlay_file=right_pointer_overlay_file,
                    highlight_file=right_pointer_highlight_file,
                    selected_file=right_pointer_select_file,
                    highlight_border_colour="gold",
                    select_border_colour="white",
                )

                if result == -1:
                    return -1, message

                # Overlay the pointer outline files on the canvas
                left_overlay_files = (
                    (canvas_overlay_file, left_pointer_overlay_file),
                    (canvas_select_file, left_pointer_select_file),
                    (canvas_highlight_file, left_pointer_highlight_file),
                    (canvas_images_file, left_pointer_icon_path),
                )

                right_overlay_files = (
                    (canvas_overlay_file, right_pointer_overlay_file),
                    (canvas_select_file, right_pointer_select_file),
                    (canvas_highlight_file, right_pointer_highlight_file),
                    (canvas_images_file, right_pointer_icon_path),
                )

                result, message = _overlay_files(
                    x=left_x, y=left_y, files=left_overlay_files
                )

                if result == -1:
                    return -1, message

                result, message = _overlay_files(
                    x=right_x, y=right_y, files=right_overlay_files
                )

                if result == -1:
                    return -1, message

        return 1, ""

    def _resize_menu_button_images(self, cell_coords: list[_Cell_Coords]):
        """Resize the menu buttons to fit on the grid layout

        Args:
            cell_coords (list[_Cell_Coords]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok

        """
        for index, input_video in enumerate(self.dvd_setup.input_videos):
            result, message = dvdarch_utils.resize_image(
                input_file=input_video.menu_image_file_path,
                out_file=input_video.menu_image_file_path,
                width=cell_coords[index].width,
                height=cell_coords[index].height,
                ignore_aspect=True,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _extract_menu_images(self) -> tuple[int, str]:
        """Extracts a random video image for the menu button

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        for video_file in self.dvd_setup.input_videos:
            if "video_frame_count" not in video_file.file_info:
                return -1, f"No video frame count found for {video_file.file_info}"

            if (
                video_file.video_file_settings.menu_button_frame == -1
            ):  # No frame number provided, pick a random frame
                menu_image_frame = randint(
                    1, video_file.file_info["video_frame_count"][1]
                )
            else:
                menu_image_frame = video_file.video_file_settings.menu_button_frame

            if menu_image_frame > video_file.file_info["video_frame_count"][1]:
                return (
                    -1,
                    (
                        f"{menu_image_frame=} is greater than video frame count"
                        f" {video_file.file_info['video_frame_count'][1]}"
                    ),
                )

            (
                result,
                image_file,
            ) = dvdarch_utils.generate_menu_image_from_file(
                video_file=video_file.file_path,
                frame_number=menu_image_frame,
                out_folder=self._menu_image_folder,
            )

            if result == -1:
                return result, image_file
            else:
                video_file.menu_image_file_path = image_file

        return 1, ""

    def _convert_to_m2v(
        self, cell_coords: list[_Cell_Coords], frames: int = 360
    ) -> tuple[int, str]:
        """Converts the background_canvas_images_file into a short video stream

        Args:
            cell_coords (list[_Cell_Coords]): The calculated grid layout
            frames (int, optional): Number of video frames in stream. Defaults to 360.

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        path_name, file_name, file_extn = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for coord in cell_coords:
            if prev_page != coord.page:
                prev_page = coord.page

                background_canvas_images_file = file_handler.file_join(
                    path_name, f"{file_name}_images_{coord.page}", file_extn
                )
                m2v_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{coord.page}", "m2v"
                )

                if not file_handler.file_exists(background_canvas_images_file):
                    return (
                        -1,
                        f"Sys Error : {background_canvas_images_file} does not exist!",
                    )

                if self._dvd_setup.video_standard == sys_consts.PAL:
                    framerate = "25:1"
                    pixel_aspect = "59:54"
                    fmt = "p"
                else:  # NTSC
                    framerate = "30000:1001"
                    pixel_aspect = "10:11"
                    fmt = "n"
                if self._dvd_setup.menu_aspect_ratio == sys_consts.AR169:
                    aspect = "3"
                else:
                    aspect = "2"

                result = subprocess.run(
                    [sys_consts.CONVERT, background_canvas_images_file, "ppm:-"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                )

                # Chained pipes here so be cognisant of that when modifying
                if result.returncode == 0:
                    result = subprocess.run(
                        [
                            sys_consts.PPMTOY4M,
                            "-n",
                            f"{frames}",
                            "-F",
                            f"{framerate}",
                            "-A",
                            f"{pixel_aspect}",
                            "-I",
                            "p",
                            "-r",
                            "-S",
                            "420mpeg2",
                        ],
                        input=result.stdout,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                    )

                    if result.returncode == 0:
                        result: subprocess.CompletedProcess[bytes] = subprocess.run(
                            [
                                sys_consts.MPEG2ENC,
                                "-n",
                                fmt,
                                "-f",
                                "8",
                                "-b",
                                "5000",
                                "-a",
                                aspect,
                                "-o",
                                m2v_file,
                            ],
                            input=result.stdout,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                        )

                    if result.returncode != 0:
                        return -1, f"Sys Error: Failed To Produce Menu Video {m2v_file}"

        return 1, ""

    def _convert_audio(
        self, cell_coords: list[_Cell_Coords], frames: int = 300
    ) -> tuple[int, str]:
        """Generates the audio for the menu. By default it is a empty soundtrack
        TODO Allow user selection of an audio file

        Args:
            cell_coords (list[_Cell_Coords]): The calculated grid layout
            frames (int, optional): Number of video frames - determines length of
            audio. Defaults to 300.

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for coord in cell_coords:
            if prev_page != coord.page:
                prev_page = coord.page

                ac3_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{coord.page}", "ac3"
                )

                if self._dvd_setup.video_standard == sys_consts.PAL:
                    framerate = 25
                else:
                    framerate = 30000 / 1001

                duration = math.floor(frames / framerate)

                # TODO Allow an audio file of the users choice
                # Generate an empty audio file
                commands = [
                    sys_consts.FFMPG,
                    "-t",
                    f"{duration}",
                    "-f lavfi",
                    "-i anullsrc=channel_layout=5.1:sample_rate=48000",
                    "-c:a ac3",
                    "-b:a 224000",
                    ac3_file,
                ]

                commands = [
                    sys_consts.FFMPG,
                    "-f",
                    "lavfi",
                    "-i",
                    "anullsrc=channel_layout=5.1:sample_rate=48000",
                    "-t",
                    f"{duration}",
                    "-b:a",
                    "224000",
                    "-c:a",
                    "ac3",
                    ac3_file,
                ]

                result, message = dvdarch_utils.execute_check_output(commands=commands)

                if result == -1:
                    return -1, message

        return 1, ""

    def _multiplex_audio_video(
        self, cell_coords: list[_Cell_Coords]
    ) -> tuple[int, str]:
        """Multiplexes the menu m2v file and the menu ac3 file to peoduce the menu mgp file

        Args:
            cell_coords (list[_Cell_Coords]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for coord in cell_coords:
            if prev_page != coord.page:
                prev_page = coord.page

                ac3_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{coord.page}", "ac3"
                )
                m2v_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{coord.page}", "m2v"
                )
                menu_video_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{coord.page}", "mpg"
                )

                commands = [
                    sys_consts.MPLEX,
                    "-f",
                    "8",
                    "-o",
                    menu_video_file,
                    m2v_file,
                    ac3_file,
                ]

                result, message = dvdarch_utils.execute_check_output(commands=commands)

                if result == -1:
                    return -1, message
        return 1, ""

    def _create_menu_mpg(self, cell_coords: list[_Cell_Coords]) -> tuple[int, str]:
        """Creates the DVD menu mpg file via the dvdauthor application spumux

        Args:
            cell_coords (list[_Cell_Coords]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for coord in cell_coords:
            if prev_page != coord.page:
                prev_page = coord.page

                menu_video_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{coord.page}", "mpg"
                )
                menu_video_buttons_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_buttons_{coord.page}", "mpg"
                )

                spumux_xml = file_handler.file_join(
                    path_name, f"spumux_{coord.page}", "xml"
                )

                env = {"VIDEO_FORMAT": self.dvd_setup.video_standard}

                commands = [
                    sys_consts.SPUMUX,
                    "-m",
                    "dvd",
                    "-s",
                    str(0),
                    spumux_xml,
                ]

                try:
                    input_file = open(menu_video_file, "rb")
                    output_file = open(menu_video_buttons_file, "wb")

                    result = subprocess.run(
                        commands,
                        env=env,
                        stdin=input_file,
                        stdout=output_file,
                        stderr=subprocess.PIPE,
                        text=True,
                    )

                    if result.returncode != 0:
                        return -1, result.stderr.strip()
                except IOError as e:
                    return -1, f"Error opening file: {e}"
                finally:
                    input_file.close()
                    output_file.close()

        return 1, ""

    def _create_dvd_image(self, buttons_per_page: int) -> tuple[int, str]:
        """Creates the DVD Folder/File structure via the dvdauthor application

        Args:
                buttons_per_page (int): The maximum number of buttons to display per page.

        Returns:
            tuple[int, str]: arg 1 : 1 Ok, -1 Fail, arg 2 : "" if Ok otherwise Error Message
        """
        assert (
            isinstance(buttons_per_page, int) and buttons_per_page > 0
        ), f"{buttons_per_page=}. Must be int > 0"

        file_handler = file_utils.File()
        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        video_dict = {
            "@format": self.dvd_setup.video_standard,
            "@aspect": self.dvd_setup.menu_aspect_ratio,
        }

        # Create the main DVD author structure
        dvd_author_dict = {
            "dvdauthor": {
                "@dest": "DVD",
                "@jumppad": "1",
                "vmgm": {"menus": {}},
                "titleset": [],
            }
        }

        page_max = math.ceil(len(self.dvd_setup.input_videos) / buttons_per_page)
        page_count = 0
        button_count = 1
        buttons_per_page = min(len(self.dvd_setup.input_videos), buttons_per_page)
        pgc = {"button": [], "vob": {"@pause": "inf"}}
        pgcs = []
        button_index = 0
        arrow_index = 0

        # Build menu pass
        for menu_index, input_video in enumerate(self.dvd_setup.input_videos):
            button_index += 1
            # TODO Specifically use buttons indicies rather than relying on the auro feature of spumux
            # pgc["button"].append({"@name":f"btn-{button_index}","#text":f"jump title {menu_index + 1};"})
            pgc["button"].append(f"jump title {menu_index + 1};")

            if (
                button_count == buttons_per_page
                or menu_index == len(self.dvd_setup.input_videos) - 1
            ):
                page_count += 1

                if page_max > 1:
                    prev_index = page_count - 1 if page_count > 1 else page_max
                    next_index = page_count + 1 if page_count < page_max else 1

                    arrow_index += 1
                    # pgc["button"].append({"@name":f"ar-{arrow_index}","#text":f"jump vmgm menu {prev_index};"})
                    pgc["button"].append(f"jump vmgm menu {prev_index};")

                    arrow_index += 1
                    # pgc["button"].append({"@name":f"ar-{arrow_index}","#text":f"jump vmgm menu {next_index};"})
                    pgc["button"].append(f"jump vmgm menu {next_index};")

                menu_video_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_buttons_{page_count - 1}.mpg"
                )

                pgc["vob"]["@file"] = menu_video_file

                pgcs.append(pgc)

                pgc = {"button": [], "vob": {"@pause": "inf"}}
                button_count = 0

            button_count += 1

        dvd_author_dict["dvdauthor"]["vmgm"]["menus"] = {
            "video": video_dict,
            "pgc": pgcs,
        }

        # Build titleset pass
        for input_video in self.dvd_setup.input_videos:
            _, video_name, _ = file_handler.split_file_path(input_video.file_path)
            vob_file = file_handler.file_join(self._vob_folder, video_name, "vob")

            pgc = {"vob": {"@file": vob_file}}

            pgc["vob"]["@pause"] = "inf"

            dvd_author_dict["dvdauthor"]["titleset"].append(
                {"titles": {"video": video_dict, "pgc": pgc}}
            )

        dvd_author_file = file_handler.file_join(path_name, "dvd_author", "xml")

        try:
            with open(dvd_author_file, "w") as result_file:
                (
                    xmltodict.unparse(
                        input_dict=dvd_author_dict, output=result_file, pretty=True
                    )
                )
        except IOError:
            return -1, f"Sys Error: Could Not Write {dvd_author_file}"

        # Run the DVDauthor XML control file
        env = {"VIDEO_FORMAT": self.dvd_setup.video_standard}

        commands = [
            sys_consts.DVDAUTHOR,
            "-x",
            dvd_author_file,
            "-o",
            self._dvd_out_folder,
        ]

        # Had to use shell if I did not run like this
        result = subprocess.run(
            commands, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )

        if result.returncode == 0:
            iso_folder = file_handler.file_join(self._iso_out_folder, "dvd_iso")

            return dvdarch_utils.create_dvd_iso(self._dvd_out_folder, iso_folder)

        else:
            return -1, result.stderr.strip()
