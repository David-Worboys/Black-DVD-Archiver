"""
Produces a DVD folder with an autogenerated menu

Copyright (C) 2022  David Worboys (-:alumnus Moyhu Primary School et al.:-)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import dataclasses
import datetime
import locale
import math
import subprocess
from random import randint
from typing import Final, Literal

import xmltodict

import dvdarch_utils
import QTPYGUI.file_utils as file_utils
import sys_consts
import QTPYGUI.utils as utils
from archive_management import Archive_Manager
from sys_config import Video_Data


@dataclasses.dataclass
class DVD_Config:
    """Configuration for the DVD archiver"""

    _archive_folder: str = ""
    _archive_size: str = sys_consts.DVD_ARCHIVE_SIZE
    _input_videos: list[Video_Data] | tuple[Video_Data] = dataclasses.field(
        default_factory=tuple
    )
    _menu_title: list[str] | tuple[str] = dataclasses.field(default_factory=tuple)
    _menu_background_color: str = "wheat"
    _menu_font_color: str = "gold"
    _menu_font_point_size: int = 24
    _menu_font: str = ""
    _button_background_color: str = "darkgray"
    _button_background_transparency: float = 0.8
    _button_font_color: str = "white"
    _button_font_point_size: int = 12
    _button_font: str = ""
    _menu_aspect_ratio: str = sys_consts.AR43  #
    _menu_buttons_across: int = 2
    _menu_buttons_per_page: int = 4
    _page_pointer_left_file: str = ""
    _page_pointer_right_file: str = ""
    _project_name: str = ""
    _serial_number: str = ""
    _streaming_folder: str = ""
    _timestamp_font: str = ""
    _timestamp_font_point_size: int = 11
    _timestamp_prefix: str = "DVD Build Date:"
    _timestamp: str = ""
    _transcode_type: str = sys_consts.TRANSCODE_NONE
    _video_standard: str = sys_consts.PAL

    def __post_init__(self):
        """
        Set the defaults
        """
        # Set the default values
        if self.menu_background_color.strip() == "":
            self.menu_background_color = "wheat"

        # Get the current locale settings and store them
        current_locale = locale.getlocale(locale.LC_TIME)

        # Set the locale to the user's default locale
        locale.setlocale(locale.LC_TIME, "")

        # Format the timestamp using the user's default locale
        self.timestamp = (
            f"{self.timestamp_prefix} {datetime.datetime.now().strftime('%x %H:%M')}"
        )

        # Restore the previous locale settings
        locale.setlocale(locale.LC_TIME, current_locale)

    @property
    def archive_folder(self) -> str:
        """
            Gets the archive folder
        Returns:
            str: The archive folder
        """
        return self._archive_folder

    @archive_folder.setter
    def archive_folder(self, value: str):
        """
            Sets the archive folder
        Args:
            value (str): The path to the archive folder
        """
        assert isinstance(value, str), f"{value=}. Must be str"

        self._archive_folder = value

    @property
    def archive_size(self) -> str:
        """
            Gets the archive size
        Returns:
            str: The archive size ( BLUERAY_ARCHIVE_SIZE | DVD_ARCHIVE_SIZE )
        """
        return self._archive_size

    @archive_size.setter
    def archive_size(self, value: str):
        """
            Sets the archive size
        Args:
            value (str): The archive size ( BLUERAY_ARCHIVE_SIZE | DVD_ARCHIVE_SIZE )
        """
        assert isinstance(value, str) and value in (
            sys_consts.BLUERAY_ARCHIVE_SIZE,
            sys_consts.DVD_ARCHIVE_SIZE,
        ), f"{value=}, Must be BLUERAY_ARCHIVE_SIZE | DVD_ARCHIVE_SIZE"
        self._archive_size = value

    @property
    def input_videos(self) -> list[Video_Data] | tuple[Video_Data]:
        """
            Gets the input videos
        Returns:
            list[Video_Data] | tuple[Video_Data]: The input videos
        """
        return self._input_videos

    @input_videos.setter
    def input_videos(self, value: list[Video_Data] | tuple[Video_Data]) -> None:
        """
            Sets the input videos
        Args:
            value (list[Video_Data] | tuple[Video_Data]): The input videos
        """
        assert isinstance(value, (list, tuple)), (
            f"{value=}. Must be a list | tuple of Video_Data"
        )

        for video_file in value:
            assert isinstance(video_file, Video_Data), (
                f"{video_file=}. Must be a File_Def"
            )

            assert file_utils.File().path_exists(video_file.video_folder), (
                f"{video_file.video_folder=}. Must be a valid file folder"
            )

        self._input_videos = value

    @property
    def menu_background_color(self) -> str:
        """
            Gets the menu background color
        Returns:
            str: The menu background color
        """
        return self._menu_background_color

    @menu_background_color.setter
    def menu_background_color(self, value: str) -> None:
        """
            Sets the menu background color
        Args:
            value (str): The menu background color
        """
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._menu_background_color = value

    @property
    def menu_title(self) -> list[str] | tuple[str]:
        """
            Gets the menu title
        Returns:
            list[str] | tuple[str]: The menu title
        """
        return self._menu_title

    @menu_title.setter
    def menu_title(self, value: list[str] | tuple[str]) -> None:
        """
            Sets the menu title
        Args:
            value (list[str] | tuple[str]): The menu title
        """
        assert isinstance(value, (list, tuple)), f"{value=}. Must be a list | tuple str"
        assert all(isinstance(title, str) for title in value), (
            f"{value=} must be list | tuple of str"
        )

        self._menu_title = value

    @property
    def menu_aspect_ratio(self) -> str:
        """
            Gets the menu aspect ratio
        Returns:
            str: The menu aspect ratio (AR169 | AR43)
        """
        return self._menu_aspect_ratio

    @menu_aspect_ratio.setter
    def menu_aspect_ratio(self, value: str) -> None:
        """
            Sets the menu aspect ratio
        Args:
            value (str): The menu aspect ratio (AR169 | AR43)
        """
        assert isinstance(value, str), f"{value=}. Must be a string"
        assert value.upper() in (
            sys_consts.AR169,
            sys_consts.AR43,
        ), f"{value=}. Must be AR169 | AR43"

        self._menu_aspect_ratio = value.upper()

    @property
    def menu_font(self) -> str:
        """
            Gets the menu font
        Returns:
            str: The menu font
        """
        return self._menu_font

    @menu_font.setter
    def menu_font(self, value: str) -> None:
        """
            Sets the menu font
        Args:
            value (str): The menu font

        Returns:

        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        file_handler = file_utils.File()

        if file_handler.file_exists(value):
            self._menu_font = value

            return
        else:  # Try to find a default system font
            for font in dvdarch_utils.Get_Fonts():
                if font[0] == value:
                    self._menu_font = font[1]

                    return

        # Try to use the supplied app font if we can't find a default font
        if file_handler.file_exists(
            file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )
        ):
            self._menu_font = file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )

            return

        # At this point, something is really wrong
        raise RuntimeError(f"{value=}. Menu Font not found")

    @property
    def page_pointer_left_file(self) -> str:
        """
        Returns the left page pointer file

        Args:

        Returns:
            str: The left page pointer file
        """

        return self._page_pointer_left_file

    @page_pointer_left_file.setter
    def page_pointer_left_file(self, value: str) -> None:
        """
        Sets the left page pointer file.

        Args:
            value (str): The left page pointer file
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be non-empty str"
        )

        self._page_pointer_left_file = value

    @property
    def page_pointer_right_file(self) -> str:
        """
        Returns the right page pointer file

        Args:

        Returns:
            str: The right page pointer file

        """
        return self._page_pointer_right_file

    @page_pointer_right_file.setter
    def page_pointer_right_file(self, value: str) -> None:
        """
        Sets the right page pointer file.

        Args:
            value (str): The right page pointer file
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be non-empty str"
        )

        self._page_pointer_right_file = value

    @property
    def button_background_color(self) -> str:
        """
        Returns the button background color

        Returns:
            str: The button background color

        """
        return self._button_background_color

    @button_background_color.setter
    def button_background_color(self, value: str):
        """
        Sets the button background color

        Args:
            value (str): The button background color

        """
        assert isinstance(value, str), "Button background color must be a string."
        self._button_background_color = value

    @property
    def button_background_transparency(self) -> float:
        """
        Returns the button background transparency

        Returns:
            float: The button background transparency

        """
        return self._button_background_transparency

    @button_background_transparency.setter
    def button_background_transparency(self, value: float):
        """
            Sets the button background transparency
        Args:
            value (float): The button background transparency <= 1.0
        """
        assert isinstance(value, float) and 0 <= value <= 1, (
            f"{value=}.  0 <= Must be float <= 1"
        )

        self._button_background_transparency = value

    @property
    def button_font_color(self) -> str:
        """
        Returns the button font color

        Returns:
            str: The button font color

        """
        return self._button_font_color

    @button_font_color.setter
    def button_font_color(self, value: str):
        """
        Sets the button font color

        Args:
            value (str): The button font color

        """
        assert isinstance(value, str), "Button font color must be a string."
        self._button_font_color = value

    @property
    def button_font_point_size(self) -> int:
        """
            Returns the button font point size
        Returns:
            int: The button font point size
        """
        return self._button_font_point_size

    @button_font_point_size.setter
    def button_font_point_size(self, value: int):
        """
            Sets the button font point size
        Args:
            value (int): The button font point size
        """
        assert isinstance(value, int), "Button font point size must be an integer."
        self._button_font_point_size = value

    @property
    def button_font(self) -> str:
        """
            Returns the button font
        Returns:
            str: The button font
        """
        return self._button_font

    @button_font.setter
    def button_font(self, value: str):
        """
            Sets the button font
        Args:
            value (str): The button font
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )
        file_handler = file_utils.File()

        if file_handler.file_exists(value):
            self._button_font = value
            return
        else:
            for font in dvdarch_utils.Get_Fonts():
                if font[0] == value:
                    self._button_font = font[1]
                    return
        if file_handler.file_exists(
            file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )
        ):
            self._menu_font = file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )

            return

        # At this point something is really wrong
        raise RuntimeError(f"{value=}. Button Font not found")

    @property
    def menu_font_color(self) -> str:
        """
            Returns the menu font color
        Returns:
            str: The menu font color
        """
        return self._menu_font_color

    @menu_font_color.setter
    def menu_font_color(self, value: str) -> None:
        """
            Sets the menu font color
        Args:
            value (str): The menu font color
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._menu_font_color = value

    @property
    def menu_font_point_size(self) -> int:
        """
            Returns the menu font point size
        Returns:
            int: The menu font point size
        """
        return self._menu_font_point_size

    @menu_font_point_size.setter
    def menu_font_point_size(self, value: int) -> None:
        """
            Sets the menu font point size
        Args:
            value (int): The menu font point size
        """
        assert isinstance(value, int) and value > 1, f"{value=}. Must be an int > 1"

        self._menu_font_point_size = value

    @property
    def menu_buttons_across(self) -> int:
        """
            Returns the menu buttons across
        Returns:
            int: The menu buttons across
        """
        return self._menu_buttons_across

    @menu_buttons_across.setter
    def menu_buttons_across(self, value: int) -> None:
        """
            Sets the menu buttons across
        Args:
            value (int): The menu buttons across
        """
        assert isinstance(value, int) and value > 0, f"{value=}. Must be an int > 0"

        self._menu_buttons_across = value

    @property
    def menu_buttons_per_page(self) -> int:
        """
            Returns the menu buttons per page
        Returns:
            int: The menu buttons per page
        """
        return self._menu_buttons_per_page

    @menu_buttons_per_page.setter
    def menu_buttons_per_page(self, value: int) -> None:
        """
            Sets the menu buttons per page
        Args:
            value (int): The menu buttons per page
        """
        assert isinstance(value, int) and value > 0, f"{value=}. Must be an int > 0"

        self._menu_buttons_per_page = value

    @property
    def project_name(self) -> str:
        """
            Returns the project name
        Returns:
            str: The project name
        """
        return self._project_name

    @project_name.setter
    def project_name(self, value: str) -> None:
        """
            Sets the project name
        Args:
            value (str): The project name
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non_empty str"
        )
        self._project_name = value

    @property
    def serial_number(self) -> str:
        """
            Returns the serial number
        Returns:
            str: The serial number
        """
        return self._serial_number

    @serial_number.setter
    def serial_number(self, value: str) -> None:
        """
            Sets the serial number
        Args:
            value (str): The serial number
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._serial_number = value

    @property
    def streaming_folder(self) -> str:
        """
            Returns the streaming folder
        Returns:
            str: The streaming folder
        """
        return self._streaming_folder

    @streaming_folder.setter
    def streaming_folder(self, value: str):
        """
            Sets the streaming folder
        Args:
            value (str): The streaming folder
        """
        assert isinstance(value, str), f"{value=}. Must be str"

        self._streaming_folder = value

    @property
    def timestamp_font(self) -> str:
        """
            Returns the timestamp font
        Returns:
            str: The timestamp font
        """
        return self._timestamp_font

    @timestamp_font.setter
    def timestamp_font(self, value: str) -> None:
        """
            Sets the timestamp font
        Args:
            value (str): The timestamp font
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        file_handler = file_utils.File()

        if file_handler.path_exists(value):
            self._timestamp_font = value
            return
        else:
            for font in dvdarch_utils.Get_Fonts():
                if font[0] == value:
                    self._timestamp_font = font[1]
                    return

        if file_handler.file_exists(
            file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )
        ):
            self._menu_font = file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )

            return

        # At this point, something is really wrong

        raise RuntimeError(f"{value=}. Timestamp Font not found")

    @property
    def timestamp_font_point_size(self) -> int:
        """
            Returns the timestamp font point size
        Returns:
            int: The timestamp font point size
        """
        return self._timestamp_font_point_size

    @timestamp_font_point_size.setter
    def timestamp_font_point_size(self, value: int) -> None:
        """
            Sets the timestamp font point size
        Args:
            value (int): The timestamp font point size
        """
        assert isinstance(value, int) and value > 1, f"{value=}. Must be an int > 1"

        self._timestamp_font_point_size = value

    @property
    def timestamp_prefix(self) -> str:
        """
            Returns the timestamp prefix
        Returns:
            str: The timestamp prefix
        """
        return self._timestamp_prefix

    @timestamp_prefix.setter
    def timestamp_prefix(self, value: str) -> None:
        """
            Sets the timestamp prefix
        Args:
            value (str): The timestamp prefix
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._timestamp_prefix = value

    @property
    def timestamp(self) -> str:
        """
            Returns the timestamp
        Returns:
            str: The timestamp
        """
        return self._timestamp

    @timestamp.setter
    def timestamp(self, value: str) -> None:
        """
            Sets the timestamp
        Args:
            value (str): The timestamp
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._timestamp = value

    @property
    def transcode_type(self) -> str:
        """
            Returns the transcode type
        Returns:
            str: The transcode type (sys_consts.TRANSCODE_NONE | TRANSCODE_FFV1ARCHIVAL | TRANSCODE_H264 | TRANSCODE_H265)
        """
        return self._transcode_type

    @transcode_type.setter
    def transcode_type(self, value: str):
        """
            Sets the transcode type
        Args:
            value (str): The transcode type (sys_consts.TRANSCODE_NONE | TRANSCODE_FFV1ARCHIVAL | TRANSCODE_H264 | TRANSCODE_H265)
        """
        assert isinstance(value, str) and value in (
            sys_consts.TRANSCODE_NONE,
            sys_consts.TRANSCODE_FFV1ARCHIVAL,
            sys_consts.TRANSCODE_H264,
            sys_consts.TRANSCODE_H265,
        ), (
            f"{value=}, Must be Be TRANSCODE_NONE | sys_consts.TRANSCODE_FFV1ARCHIVAL |"
            " TRANSCODE_H264 | TRANSCODE_H265"
        )
        self._transcode_type = value

    @property
    def video_standard(self):
        """
            Returns the video standard
        Returns:
            str: The video standard
        """
        return self._video_standard

    @video_standard.setter
    def video_standard(self, value: str) -> None:
        """
            Sets the video standard
        Args:
            value (str): The video standard (sys_consts.PAL | sys_consts.NTSC)
        """
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._video_standard = value.upper()

        assert value in (
            sys_consts.PAL,
            sys_consts.NTSC,
        ), f"{value=}. Must be NTSC or PAL"


@dataclasses.dataclass(slots=True)
class _Cell_Coord:
    name: str = ""
    x0: int = 0
    y0: int = 0
    x1: int = 0
    y1: int = 0
    width: int = 0
    height: int = 0
    page: int = 0
    video_data: Video_Data | None = dataclasses.field(default_factory=Video_Data)
    cargo: dict = dataclasses.field(default_factory=dict)

    def __post_init__(self):
        assert isinstance(self.name, str), f"{self.name=}. Must be str"
        assert isinstance(self.x0, int) and self.x0 >= 0, (
            f"{self.x0=}. Must be int >= 0"
        )
        assert isinstance(self.y0, int) and self.y0 >= 0, (
            f"{self.y0=}. Must be int >= 0"
        )
        assert isinstance(self.x1, int) and self.x1 >= 0, (
            f"{self.x1=}. Must be int >= 0"
        )
        assert isinstance(self.y1, int) and self.y1 >= 0, (
            f"{self.y1=}. Must be int >= 0"
        )
        assert isinstance(self.width, int) and self.width >= 0, (
            f"{self.width=}. Must be int >=0"
        )
        assert isinstance(self.height, int) and self.height >= 0, (
            f"{self.height=}. Must be int >= 0"
        )
        assert isinstance(self.page, int) and self.page >= 0, (
            f"{self.page=}. Must be int >= 0"
        )
        assert isinstance(self.video_data, Video_Data) or self.video_data is None, (
            f"{self.video_data=}. Must be Video_Data Or None"
        )
        assert isinstance(self.cargo, dict), f"{self.cargo=}. Must be dict"

    def get_mask_filenames(self, alternate_file_path: str = "") -> tuple[str, ...]:
        """Generate the file names for overlay, highlight, select, and text masks.

        Args:
            alternate_file_path (str) : If provided, use this file path instead of the
                video_file.menu_image_file_path.

        Returns:
            A tuple of four strings representing the file names of the following:
            - overlay_file: A PNG file containing the overlay mask.
            - highlight_file: A PNG file containing the highlight mask.
            - select_file: A PNG file containing the select mask.
            - text_file: A file containing the text (with extension specified by file_extn).
        """
        file_handler = file_utils.File()

        if alternate_file_path:
            path_name, file_name, file_extn = file_handler.split_file_path(
                alternate_file_path
            )
        else:
            if self.video_data is None:
                return ("", "", "", "")

            path_name, file_name, file_extn = file_handler.split_file_path(
                self.video_data.menu_image_file_path
            )

        suffixes = ["_overlay", "_highlight", "_select", "_text"]
        filenames = []

        for suffix in suffixes:
            if suffix == "_text":
                filename = (
                    file_handler.file_join(
                        path_name, f"{file_name}{suffix}_{self.page}", file_extn
                    )
                    if file_extn
                    else ""
                )
            else:
                filename = file_handler.file_join(
                    path_name, f"{file_name}{suffix}_{self.page}", "png"
                )
            filenames.append(filename)

        return tuple(filenames)


# ===== Public Class
@dataclasses.dataclass
class DVD:
    """Does the grunt work needed to automatically turn video files into a
    DVD Folder/File structure with an auto generated menu"""

    _BACKGROUND_CANVAS_FILE: Final[str] = "background_canvas.png"

    # Defaults to 43 pixels. Takes only 2 possible pixel unit values - 33 (AR169) and 43 (AR43). spumux is very sensitive
    # to this setting
    _SPUMUX_BUFFER: Literal[33, 43] = 43

    # Internal instance vars
    _dvd_config: DVD_Config = dataclasses.field(default_factory=DVD_Config)
    _dvd_timestamp_x_offset: int = 10  # TODO Make user configurable

    # folders
    _working_folder: str = ""
    _dvd_working_folder: str = ""
    _dvd_out_folder: str = ""
    _iso_out_folder: str = ""
    _menu_image_folder: str = ""
    _tmp_folder: str = ""
    _vob_folder: str = ""

    # file names
    _background_canvas_file: str = ""

    def __post_init__(self) -> None:
        pass

    @dataclasses.dataclass(slots=True)
    class _Menu_Pointer_Data:
        """Dataclass to hold data for the menu pointer icon"""

        # public
        background_canvas_file: str
        dvd_config: DVD_Config
        spumux_buffer: int

        # private
        _width: int = -1
        _height: int = -1
        _left_icon_path: str = ""
        _left_x_offset: int = -1
        _left_y_offset: int = -1
        _right_icon_path: str = ""
        _right_x_offset: int = -1
        _right_y_offset: int = -1
        _error_code: int = 1
        _error_message: str = ""

        def __post_init__(self):
            """Initialize the class"""
            assert (
                isinstance(self.background_canvas_file, str)
                and self.background_canvas_file.strip() != ""
            ), f"{self.background_canvas_file=}. Must be a str"
            assert isinstance(self.dvd_config, DVD_Config), (
                f"{self.dvd_config=}. Must be a DVD_Config"
            )
            assert isinstance(self.spumux_buffer, int) and self.spumux_buffer > 0, (
                f"{self.spumux_buffer=}. Must be an int > 0"
            )

            file_handler = file_utils.File()

            # TODO Make sys_consts.ICON_PATH user configurable
            page_pointer_left_file = file_handler.file_join(
                sys_consts.ICON_PATH, self.dvd_config.page_pointer_left_file
            )
            page_pointer_right_file = file_handler.file_join(
                sys_consts.ICON_PATH, self.dvd_config.page_pointer_right_file
            )

            _, left_file, left_extn = file_handler.split_file_path(
                page_pointer_left_file
            )
            _, right_file, _ = file_handler.split_file_path(page_pointer_right_file)

            right_pointer_file = right_file
            left_pointer_file = left_file
            pointer_file_extn = left_extn

            self.left_icon_path = file_handler.file_join(
                sys_consts.ICON_PATH,
                left_pointer_file,
                pointer_file_extn,
            )

            self.right_icon_path = file_handler.file_join(
                sys_consts.ICON_PATH,
                right_pointer_file,
                pointer_file_extn,
            )

            self.width, self.height, message = dvdarch_utils.Get_Image_Size(
                self.left_icon_path
            )  # Assume left and right are the same size

            if self.width == -1 and self.height == -1:
                self.error_code = -1
                self.error_message = message

            canvas_width, canvas_height, message = dvdarch_utils.Get_Image_Size(
                self.background_canvas_file
            )

            if canvas_width == -1 and canvas_height == -1:
                self.error_code = -1
                self.error_message = message

            self.left_x_offset = self.spumux_buffer
            self.left_y_offset = canvas_height - (self.height + self.spumux_buffer)
            self.right_x_offset = canvas_width - (self.width + self.spumux_buffer)
            self.right_y_offset = canvas_height - (self.height + self.spumux_buffer)

        @property
        def error_code(self) -> int:
            """
                Gets the error code
            Returns:
                int: The error code
            """
            return self._error_code

        @error_code.setter
        def error_code(self, value: int):
            """
                Sets the error code
            Args:
                value(int): The error code

            Returns:

            """
            assert isinstance(value, int) and value in (-1, 0), (
                f"{value=} must be -1 or 0"
            )

            self._error_code = value

        @property
        def error_message(self) -> str:
            """
                Gets the error message
            Returns:
                str: The error message
            """
            return self._error_message

        @error_message.setter
        def error_message(self, value: str):
            """
                Sets the error message
            Args:
                value(str): The error message

            Returns:

            """
            assert isinstance(value, str), f"{value=} must be str"

            self._error_message = value

        @property
        def width(self) -> int:
            """
                Gets the width of the pointer icon
            Returns:
                int: The width of the pointer icon
            """
            return self._width

        @width.setter
        def width(self, value: int):
            """
                Sets the width of the pointer icon
            Args:
                value(int): The width of the pointer icon

            Returns:

            """
            assert isinstance(value, int) and value > 0, f"{value=} must  > 0"

            self._width = value

        @property
        def height(self) -> int:
            """
                Gets the height of the pointer icon
            Returns:
                int: The height of the pointer icon
            """
            return self._height

        @height.setter
        def height(self, value: int):
            """
                Sets the height of the pointer icon
            Args:
                value(int): The height of the pointer icon

            Returns:

            """
            assert isinstance(value, int) and value > 0, f"{value=} must  > 0"

            self._height = value

        @property
        def left_icon_path(self) -> str:
            """
                Gets the path of the left pointer icon.

            Returns:
                str: The path of the left pointer icon

            """
            return self._left_icon_path

        @left_icon_path.setter
        def left_icon_path(self, value: str):
            """
                Sets the path of the left pointer icon.
            Args:
                value(str): The path of the left pointer icon

            Returns:

            """
            assert isinstance(value, str) and value.strip() != "", (
                f"{value=} must be a non-empty str"
            )

            self._left_icon_path = value

        @property
        def left_x_offset(self) -> int:
            """
                Gets the x offset of the left pointer.

            Returns:
                int: The x offset of the left pointer

            """
            return self._left_x_offset

        @left_x_offset.setter
        def left_x_offset(self, value: int):
            """
                Sets the x offset of the left pointer.

            Args:
                value(int): The x offset of the left pointer

            Returns:

            """
            assert isinstance(value, int) and value > 0, f"{value=} must be > 0"

            self._left_x_offset = value

        @property
        def left_y_offset(self) -> int:
            """
                Gets the y offset of the left pointer.

            Returns:
                int: The y offset of the left pointer

            """
            return self._left_y_offset

        @left_y_offset.setter
        def left_y_offset(self, value: int):
            """
            Sets the y offset of the left pointer.

            Args:
                value(int): The y offset of the left pointer

            Returns:

            """
            assert isinstance(value, int) and value > 0, f"{value=} must be > 0"

            self._left_y_offset = value

        @property
        def right_icon_path(self) -> str:
            """
                Gets the path of the right pointer icon.

            Returns:
                str: The path of the right pointer icon
            """
            return self._right_icon_path

        @right_icon_path.setter
        def right_icon_path(self, value: str):
            """

            Sets the path of the right pointer icon.
            Args:
                value (str): The path of the right pointer icon

            Returns:

            """
            assert isinstance(value, str) and value.strip() != "", (
                f"{value=} must be a non-empty str"
            )

            self._right_icon_path = value

        @property
        def right_x_offset(self) -> int:
            """
                Gets the x offset of the right pointer.

            Returns:
                int: The x offset of the right pointer

            """
            return self._right_x_offset

        @right_x_offset.setter
        def right_x_offset(self, value: int):
            """
            Sets the x offset of the right pointer.

            Args:
                value (int): The x offset of the right pointer

            Returns:
                int: The x offset of the right pointer.

            """
            assert isinstance(value, int) and value > 0, f"{value=} must be > 0"

            self._right_x_offset = value

        @property
        def right_y_offset(self) -> int:
            """
            Gets the y offset of the right pointer.

            Returns:
                int: The y offset of the right pointer.

            """
            return self._right_y_offset

        @right_y_offset.setter
        def right_y_offset(self, value: int):
            """
            Sets the y offset of the right pointer.

            Args:
                value (int): The y offset of the right pointer
            """

            assert isinstance(value, int) and value > 0, f"{value=} must be > 0"

            self._right_y_offset = value

    @property
    def dvd_config(self) -> DVD_Config:
        return self._dvd_config

    @dvd_config.setter
    def dvd_config(self, value: DVD_Config) -> None:
        assert isinstance(value, DVD_Config), f"{value=}. Must be a DVD_Setup"

        self._dvd_config = value
        if self.dvd_config.menu_aspect_ratio == sys_consts.AR43:
            self._SPUMUX_BUFFER = (
                43  # pixel unit, spumux is very sensitive to this setting
            )
        else:  # sys_consts.AR169
            self._SPUMUX_BUFFER = (
                33  # pixel unit, spumux is very sensitive to this setting
            )

    @property
    def dvd_working_folder(self) -> str:
        return self._dvd_working_folder

    @property
    def working_folder(self) -> str:
        return self._working_folder

    @working_folder.setter
    def working_folder(self, value: str) -> None:
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._working_folder = value

    @property
    def dvd_image_folder(self) -> str:
        return self._dvd_out_folder

    @property
    def iso_folder(self) -> str:
        return self._iso_out_folder

    def build(self) -> tuple[int, str]:
        """Builds the  DVD Folder/File structure

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert len(self.dvd_config.input_videos) > 0, (
            "Must have at least one input video"
        )

        error_no, error_message = self._build_working_folders()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._encode_video()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._extract_menu_images()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._create_dvd_menu()

        if error_no == -1:
            return error_no, error_message

        return 1, ""

    def _archive_dvd_files(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """
        Archives the specified video files into a DVD image and saves the ISO image to the specified folder.

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout
            representing the video files to be archived.

        Returns:
            tuple[int, str]:
            - arg 1:1 Ok . -1 otherwise.
            - arg 2: "" if ok, otherwise an error message

        """

        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        if (
            self.dvd_config.archive_folder and cell_coords
        ):  # Only archive if an archive folder is specified.
            archive_manager = Archive_Manager(
                archive_folder=self.dvd_config.archive_folder,
                streaming_folder=self.dvd_config.streaming_folder,
                archive_size=self.dvd_config.archive_size,
                transcode_type=self.dvd_config.transcode_type,
            )
            menu_layout: list[tuple[str, list[Video_Data]]] = []
            video_list: list[Video_Data] = []

            page_index = cell_coords[0].page

            for cell_coord in cell_coords:
                if cell_coord.video_data is None:
                    continue

                if page_index != cell_coord.page:  # page break
                    if video_list:
                        menu_layout.append((
                            (
                                f"menu_{page_index}"
                                if self.dvd_config.menu_title[page_index].strip() == ""
                                else self.dvd_config.menu_title[page_index]
                            ),
                            video_list,
                        ))
                    page_index = cell_coord.page
                    video_list = []
                video_list.append(cell_coord.video_data)
            else:
                if video_list:
                    menu_layout.append((
                        (
                            f"menu_{page_index}"
                            if self.dvd_config.menu_title[page_index].strip() == ""
                            else self.dvd_config.menu_title[page_index]
                        ),
                        video_list,
                    ))
            result, message = archive_manager.archive_dvd_build(
                dvd_name=(
                    f"{self.dvd_config.serial_number} - {self._dvd_config.project_name}"
                ),
                dvd_folder=self.dvd_image_folder,
                iso_folder=self.iso_folder,
                menu_layout=menu_layout,
            )

            if result == -1:
                return -1, message

            file_handler = file_utils.File()

            if utils.Is_Complied():
                result, message = file_handler.remove_dir_contents(
                    self.dvd_working_folder
                )

            if result == -1:
                return -1, message

        return 1, ""

    def _build_working_folders(self) -> tuple[int, str]:
        """Builds the working file structure.

        All of these files are disposable once the DVD image is created

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()
        working_folder_name = utils.Get_Unique_Id()

        self._dvd_working_folder = file_handler.file_join(
            self.working_folder, sys_consts.DVD_BUILD_FOLDER_NAME
        )

        if not file_handler.path_exists(self.working_folder):
            if file_handler.path_writeable(self.working_folder):
                result = file_handler.make_dir(self._dvd_working_folder)

                if result == -1:
                    return -1, f"{self._dvd_working_folder=}. Could Not Be Created"
            else:
                return -1, f"{self._dvd_working_folder=}. Is Not Writeable"

        self._dvd_working_folder = file_handler.file_join(
            self._dvd_working_folder, working_folder_name
        )

        file_handler.make_dir(self._dvd_working_folder)

        if file_handler.path_exists(
            self._dvd_working_folder
        ) and file_handler.path_writeable(self._dvd_working_folder):
            self._dvd_out_folder = file_handler.file_join(
                self._dvd_working_folder, "dvd_image"
            )
            self._iso_out_folder = file_handler.file_join(
                self._dvd_working_folder, "iso_image"
            )
            self._menu_image_folder = file_handler.file_join(
                self._dvd_working_folder, "menu_images"
            )
            self._tmp_folder = file_handler.file_join(self._dvd_working_folder, "tmp")
            self._vob_folder = file_handler.file_join(self._dvd_working_folder, "vobs")

            if file_handler.make_dir(self._dvd_out_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._dvd_out_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._iso_out_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._iso_out_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._menu_image_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._menu_image_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._tmp_folder) == -1:
                return (
                    -1,
                    f"{self._tmp_folder=}. Could Not Be Created Or Is Not Writeable",
                )
            if file_handler.make_dir(self._vob_folder) == -1:
                return (
                    -1,
                    f"{self._vob_folder=}. Could Not Be Created Or Is Not Writeable",
                )

        if not file_handler.path_exists(
            self._dvd_working_folder
        ) and not file_handler.path_writeable(self._dvd_working_folder):
            return (
                -1,
                (
                    f"{self._dvd_working_folder=}. Could Not Be Created Or Is Not"
                    " Writeable"
                ),
            )

        # Build mandatory file paths
        self._background_canvas_file = file_handler.file_join(
            self._tmp_folder, self._BACKGROUND_CANVAS_FILE
        )

        return 1, ""

    def _encode_video(self) -> tuple[int, str]:
        """Encodes the input video files as DVD VOB (mpeg2) files

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        # Black Video Choices
        average_bit_rate = sys_consts.AVERAGE_BITRATE

        black_border_size = 12  # TODO Black choice for now

        # Black filter Choices for now TODO Allow some user configuration
        debug = False
        normalise_video_filter = (  # Try to improve exposure of video
            "normalize=blackpt=black:whitept=white:smoothing=11:independence=0.5"
        )

        video_denoise_filter = "nlmeans=1.0:7:5:3:3"  # Light but fairly fast denoise
        # video_denoise_filter = "nlmeans=7.0:7:5:0:9"  # Light but fairly fast denoise
        # video_denoise_filter ="owdenoise"
        # video_denoise_filter ="vaguedenoiser"
        # video_denoise_filter ="atadenoise"
        # video_denoise_filter="hqdn3d=2.0:3.0:3.0:4.5"

        color_correct_filter = "colorcorrect=analyze='median'"  # Fixes white balance
        usharp_filter = "unsharp=luma_amount=0.2"  # Gentle sharpening of luma channel

        # Black frame around the video to hide things like head switching noise
        filter_commands = [
            f"drawbox=x=0:y=0:w=iw:h={black_border_size}:color=black:t=fill",
            f"drawbox=x=0:y=ih-{black_border_size}:w=iw:h={black_border_size}:color=black:t=fill",
            f"drawbox=x=0:y={black_border_size}:w={black_border_size}:h=ih-{black_border_size * 2}:color=black:t=fill",
            f"drawbox=x=iw-{black_border_size}:y={black_border_size}:w={black_border_size}:h=ih-{black_border_size * 2}:color=black:t=fill",
        ]
        black_box_filter = ",".join(filter_commands)

        for video_file in self.dvd_config.input_videos:
            vob_file = file_handler.file_join(
                self._vob_folder, video_file.video_file, "vob"
            )

            # Tries to dering and lighten dark videos somewhat
            auto_bright = (
                "pp=dr/al" if video_file.video_file_settings.auto_bright else "pp=dr"
            )

            if (
                video_file.encoding_info.video_height <= 0
                or video_file.encoding_info.video_width <= 0
            ):
                return (
                    -1,
                    f"{video_file.video_path=}. Does Not Specify Height and/or Width",
                )

            if not video_file.encoding_info.video_ar:
                return (
                    -1,
                    f"Unrecognised Aspect Ratio : {video_file.encoding_info.video_ar}",
                )

            if video_file.video_file_settings.filters_off:
                video_filter_options = [
                    f" {black_box_filter}",  # video filters applied
                ]
            else:
                video_filter_options = [auto_bright]

                if video_file.video_file_settings.normalise:
                    video_filter_options.append(normalise_video_filter)

                if video_file.video_file_settings.white_balance:
                    video_filter_options.append(color_correct_filter)

                if video_file.video_file_settings.denoise:
                    video_filter_options.append(video_denoise_filter)

                if video_file.video_file_settings.sharpen:
                    video_filter_options.append(usharp_filter)

                video_filter_options.append(black_box_filter)

            video_filters = ["-vf", ",".join(video_filter_options)]

            video_width = video_file.encoding_info.video_width
            video_height = video_file.encoding_info.video_height
            video_interlaced = (
                True
                if video_file.encoding_info.video_scan_type.lower().startswith(
                    "interlaced"
                )
                else False
            )

            # Do not forget-widescreen stretches the file on display, so wide screen and standard screen are the
            # same size here
            if self.dvd_config.video_standard == sys_consts.PAL:
                frame_rate = f"{sys_consts.PAL_FRAME_RATE}"

                if (
                    video_width == sys_consts.PAL_SPECS.width_43
                    and video_height == sys_consts.PAL_SPECS.height_43
                ):
                    video_size = f"{video_width}x{video_height}"
                else:
                    if video_height > sys_consts.PAL_SPECS.height_43:
                        video_size = f"{-1}x{sys_consts.PAL_SPECS.height_43}"

                    elif video_height > sys_consts.PAL_SPECS.height_43:
                        if not video_interlaced:
                            video_size = f"{sys_consts.PAL_SPECS.width_43}x{sys_consts.PAL_SPECS.height_43}"

                            if (
                                video_file.encoding_info.video_frame_rate
                                == sys_consts.PAL_FIELD_RATE
                            ):  # We interlace
                                video_filter_options.append(
                                    "tinterlace=interleave_bottom"
                                )
                                video_filters = ["-vf", ",".join(video_filter_options)]
                            elif (
                                video_file.encoding_info.video_frame_rate
                                == sys_consts.PAL_FRAME_RATE
                            ):
                                video_size = f"{sys_consts.PAL_SPECS.width_43}x{sys_consts.PAL_SPECS.height_43}"
                                frame_rate = str(
                                    video_file.encoding_info.video_frame_rate
                                )
                        elif video_interlaced:
                            video_size = f"{sys_consts.PAL_SPECS.width_43}x{sys_consts.PAL_SPECS.height_43}"
                        else:
                            return (
                                -1,
                                (
                                    "Video can not be made to conform with DVD PAL specifications"
                                ),
                            )
                    else:
                        return (
                            -1,
                            (
                                f"Video {video_width=}x{video_height} does not conform to PAL specifications"
                            ),
                        )
            else:  # NTSC
                frame_rate = f"{sys_consts.NTSC_SPECS.frame_rate}"

                if (
                    video_width == sys_consts.NTSC_SPECS.width_43
                    and video_height == sys_consts.NTSC_SPECS.height_43
                ):
                    video_size = f"{video_width}x{video_height}"
                elif video_height > sys_consts.NTSC_SPECS.height_43:
                    if not video_interlaced:
                        video_size = f"{sys_consts.NTSC_SPECS.width_43}x{sys_consts.NTSC_SPECS.height_43}"

                        if (
                            video_file.encoding_info.video_frame_rate
                            == sys_consts.NTSC_FIELD_RATE
                        ):  # We interlace
                            video_filter_options.append("tinterlace=interleave_bottom")
                            video_filters = ["-vf", ",".join(video_filter_options)]
                        elif video_file.encoding_info.video_frame_rate in (
                            sys_consts.NTSC_FRAME_RATE,
                            30,
                        ):
                            video_size = f"{sys_consts.NTSC_SPECS.width_43}x{sys_consts.NTSC_SPECS.height_43}"
                            frame_rate = str(video_file.encoding_info.video_frame_rate)
                    elif video_interlaced:
                        video_size = f"{sys_consts.NTSC_SPECS.width_43}x{sys_consts.NTSC_SPECS.height_43}"
                    else:
                        return (
                            -1,
                            (
                                "Video can not be made to conform with DVD NTSC specifications"
                            ),
                        )
                else:
                    return (
                        -1,
                        (
                            f"Video {video_width=}x{video_height} does not conform to NTSC specifications"
                        ),
                    )

            if debug:
                command_header = [
                    sys_consts.FFMPG,  # the ffmpeg executable
                    "-report",  # Generate verbose output for debug
                ]
            else:
                command_header = [sys_consts.FFMPG]

            interlaced_flags = []
            if video_interlaced:
                interlaced_flags = [
                    "-flags:v:0",  # video flags for the first video stream
                    "+ilme+ildct",  # include interlaced motion estimation and interlaced DCT
                    "-alternate_scan:v:0",  # set alternate scan for first video stream (interlace)
                    "1",  # alternate scan value is 1
                ]

            command = (
                command_header
                + [
                    "-fflags",  # set ffmpeg flags
                    "+genpts",  # generate presentation timestamps
                    "-threads",
                    dvdarch_utils.Get_Thread_Count(),
                    "-i",  # input flag
                    video_file.video_path,  # path to video file
                ]
                + interlaced_flags
                + [
                    "-f",  # set output format
                    "dvd",  # output format is DVD
                    "-c:v:0",  # codec for the first video stream
                    "mpeg2video",  # use mpeg2video codec
                    "-aspect",  # set aspect ratio
                    video_file.encoding_info.video_ar,  # aspect ratio value
                    "-s",  # set resolution
                    video_size,  # resolution value
                    "-r",  # set frame rate
                    frame_rate,  # frame rate value
                    "-g",  # set GOP (group of pictures) size
                    "15",  # GOP size is 15
                    "-pix_fmt",  # set pixel format
                    "yuv420p",  # use YUV 420p pixel format
                    "-b:v",  # set video bitrate
                    f"{average_bit_rate}k",  # average video bitrate is kilobits/sec
                    "-maxrate:v",  # set maximum video rate
                    "9000k",  # maximum video rate is 9000 kilobits/sec
                    "-minrate:v",  # set minimum video rate
                    "0",  # minimum video rate is 0
                    "-bufsize:v",  # set video buffer size
                    "1835008",  # video buffer size is 1835008 bits
                    "-packetsize",  # set packet size
                    "2048",  # packet size is 2048 bits
                    "-muxrate",  # set mux rate
                    "10080000",  # mux rate is 10080000 bits/sec
                    "-force_key_frames",  # force key frames
                    "expr:if(isnan(prev_forced_n),1,eq(n,prev_forced_n + 15))",  # set key frame expression (Closes each GOP)
                ]
                + video_filters
                + [
                    "-b:a",  # set audio bitrate
                    "192000",  # audio bitrate is 192000 bits/sec
                    "-ar",  # set audio sample rate
                    "48000",  # audio sample rate is 48000 samples/sec
                    "-c:a:0",  # codec for the first audio stream
                    "ac3",  # use ac3 codec
                    "-filter:a:0",  # audio filter for the first audio stream
                    "loudnorm=I=-16:LRA=11:TP=-1.5",  # use loudnorm filter with specified parameters
                    "-map",  # set mapping
                    "0:V",  # map first video stream
                    "-map",  # set mapping
                    "0:a",  # map first audio stream
                    "-map",  # set mapping
                    "-0:s",  # exclude first subtitle stream
                    "-threads",
                    dvdarch_utils.Get_Thread_Count(),
                    vob_file,  # Output encoded VOB file for inclusion in DVD
                ]
            )

            result, message = dvdarch_utils.Execute_Check_Output(
                commands=command, debug=False
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _create_dvd_menu(self) -> tuple[int, str]:
        """Creates the DVD menu automagically

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        debug = False

        timestamp_height = 0
        buttons_per_page = self.dvd_config.menu_buttons_per_page
        buttons_across = self.dvd_config.menu_buttons_across

        dvd_dims = dvdarch_utils.Get_DVD_Dims(
            self.dvd_config.menu_aspect_ratio, self.dvd_config.video_standard
        )

        if dvd_dims.display_height == -1:
            return -1, "Failed To Get DVD Dimensions"

        result, message = self._create_canvas_image(
            width=dvd_dims.storage_width, height=dvd_dims.storage_height
        )
        if result == -1:
            return result, message

        if all(
            file_def.dvd_page >= 0 for file_def in self.dvd_config.input_videos
        ):  # Manual Layout
            cell_coords, message = self._dvd_page_calc_layout(
                buttons_per_page=buttons_per_page,
                buttons_across=buttons_across,
                button_aspect_ratio=4
                / 3,  # Actually does not matter because a 16/9 menu will stretch button
                dvd_dims=dvd_dims,
                border_top=10,
                border_bottom=10 + timestamp_height,
                border_left=10,  # + timestamp_height,
                border_right=10,  # + timestamp_height,
            )
        else:  # Auto calc layout
            cell_coords, message = self._auto_calc_layout(
                num_buttons=len(self.dvd_config.input_videos),
                buttons_per_page=buttons_per_page,
                buttons_across=buttons_across,
                button_aspect_ratio=4
                / 3,  # Actually does not matter because a 16/9 menu will stretch button
                dvd_dims=dvd_dims,
                border_top=10,
                border_bottom=10 + timestamp_height,
                border_left=10,  # + timestamp_height,
                border_right=10,  # + timestamp_height,
            )

        if not cell_coords:
            return -1, message

        result, message = self._resize_menu_button_images(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_labels(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._prepare_buttons(
            cell_coords=cell_coords,
        )

        if result == -1:
            return -1, message

        result, message = self._convert_to_m2v(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._convert_audio(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._multiplex_audio_video(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_menu_mpg(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_dvd_image(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._archive_dvd_files(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        if debug and not utils.Is_Complied():
            canvas_height, message = dvdarch_utils.Get_Image_Height(
                self._background_canvas_file
            )
            if canvas_height == -1:
                return -1, message

            canvas_width, message = dvdarch_utils.Get_Image_Width(
                self._background_canvas_file
            )
            if canvas_width == -1:
                return -1, message

            print("=============================")
            print(f"DBG  {canvas_height=} {canvas_width=} ")
            print(f"DBG {dvd_dims=}")
            print(f"DBG {cell_coords=}")
            print("=============================")

        return 1, ""

    def _create_labels(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """
        Create images for each label to be placed on the button images.

        Args:
            cell_coords (list[_Cell_Coord]): The list of cell coordinates.

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail,
            - arg2: error message or "" if ok
        """
        # Black Choice
        # label_line_height = 0
        # label_lines = 2
        # font: str = "DejaVu-Sans-Bold"
        # pointsize: int = 15
        # fill: str = "white"
        # fill: str = "gold"
        # stroke: str = "black"
        # strokewidth: int = 0
        # word_spacing: int = 0
        # clear_inner_stroke: bool = True
        # line_height: int = 0
        # max_width: int = 0
        # max_lines: int = 1
        # size: int = 0
        # undercolor = "RoyalBlue"
        # background: str = "none"
        # gravity: str = "center"

        file_handler = file_utils.File()

        for cell_coord in cell_coords:
            if cell_coord.video_data is None:
                continue

            path_name, file_name, file_extn = file_handler.split_file_path(
                cell_coord.video_data.menu_image_file_path
            )

            # Setup required files
            menu_button_file = file_handler.file_join(path_name, file_name, file_extn)
            menu_button_text_file = file_handler.file_join(
                path_name, f"{file_name}_text_{cell_coord.page}", file_extn
            )

            if not file_handler.file_exists(menu_button_file):
                return -1, f"Video File Does Not Exist : {menu_button_file}"

            menu_text = cell_coord.video_data.video_file_settings.button_title

            result, message = dvdarch_utils.Overlay_Text(
                in_file=menu_button_file,
                out_file=menu_button_text_file,
                text=menu_text,
                text_font=self.dvd_config.button_font,
                text_pointsize=self.dvd_config.button_font_point_size,
                text_color=self.dvd_config.button_font_color,
                position="bottom",
                background_color=self.dvd_config.button_background_color,
                opacity=self.dvd_config.button_background_transparency,
                y_offset=10,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _build_page_grid(
        self,
        num_buttons: int,
        num_pages: int,
        buttons_per_page: int,
        buttons_across: int,
    ) -> tuple[list[list], int, int]:
        """Builds a page grid.  Empty cells are represented by -1, Non-empty cells are represented by 1.

        Args:
            num_buttons (int): Total number of buttons in the dvd menu.
            num_pages (int): Total number of pages in the dvd menu.
            buttons_per_page (int): Number of buttons on a single page.
            buttons_across (int): Number of buttons across a single page.

        Returns:
            tuple[list[list], int, int]:
            - arg 1: A list of page grids.
            - arg 2: Number of rows in the page grid.
            - arg 3: Number of columns in the page grid.
        """
        assert isinstance(num_buttons, int) and num_buttons > 0, (
            f"{num_buttons=}. Must be int > 0"
        )
        assert isinstance(buttons_per_page, int) and buttons_per_page > 0, (
            f"{buttons_per_page=}. Must be int > 0"
        )
        assert isinstance(buttons_across, int) and buttons_across > 0, (
            f"{buttons_across=}. Must be int > 0"
        )

        pages = []
        button_count = 0
        num_rows = 0
        num_cols = 0

        if buttons_per_page == 1:
            buttons_down = 1
        else:
            buttons_down = math.ceil(buttons_per_page / buttons_across)

        for _ in range(num_pages):
            page_grid = [
                [-1 for _ in range(buttons_across)] for _ in range(buttons_down)
            ]

            button_num = 0
            for row_index in range(buttons_down):
                for col_index in range(buttons_across):
                    if button_num > buttons_per_page - 1:
                        break
                    elif button_count < num_buttons:
                        page_grid[row_index][col_index] = 1
                        button_count += 1
                    else:
                        break

                    button_num += 1

                if button_num > buttons_per_page - 1 or button_count == num_buttons:
                    break

            pages.append(page_grid)
            num_rows = max(num_rows, len(page_grid))
            num_cols = max(num_cols, len(page_grid[0]))
        return pages, num_rows, num_cols

    def _auto_calc_layout(
        self,
        num_buttons: int,
        buttons_per_page: int,
        buttons_across,
        button_aspect_ratio: float,
        dvd_dims: dvdarch_utils.Dvd_Dims,
        border_top: int = 0,
        border_left: int = 0,
        border_bottom: int = 15,
        border_right: int = 0,
    ) -> tuple[list[_Cell_Coord], str]:
        """
        Generates a layout of rectangles with fixed size borders on each edge,
        arranged to fit within a canvas of fixed aspect ratio.

        Args:
            num_buttons (int): The number of num_buttons to be arranged.
            buttons_per_page (int): The number of buttons on the DVD menu page
            buttons_across (int): The number of buttons across the DVD menu (buttons down is calculated).
            button_aspect_ratio (float): The aspect ratio of the button rectangles (height/width).
            dvd_dims (dvdarch_utils.dvd_dims): The DVD dimensions
            border_top (int): The width of the border at the top edge of the canvas.
            border_left (int): The width of the border at the left edge of the canvas.
            border_bottom (int): The width of the border at the bottom edge of the canvas.
            border_right (int): The width of the border at the right edge of the canvas.

        Returns:
            tuple[list[_Cell_Coord], str]:
            - arg 1: A list of _Cell_Coords objects representing the layout of the rectangles within the canvas.
            - arg 2 : An error message if there is an error.

        """
        assert isinstance(num_buttons, int) and num_buttons > 0, (
            f"{num_buttons=}. Must be int > 0"
        )
        assert isinstance(button_aspect_ratio, float) and button_aspect_ratio > 0, (
            f"{button_aspect_ratio=}. Must be float > 0"
        )
        assert isinstance(dvd_dims, dvdarch_utils.Dvd_Dims), (
            f"{dvd_dims=}. Must be a valid dvd_dims object"
        )
        assert isinstance(border_top, int) and border_top >= 0, (
            f"{border_top=}. Must be int >= 0"
        )
        assert isinstance(border_left, int) and border_left >= 0, (
            f"{border_left=}. Must be int >= 0"
        )
        assert isinstance(border_bottom, int) and border_bottom >= 0, (
            f"{border_bottom=}. Must be int >= 0"
        )
        assert isinstance(border_right, int) and border_right >= 0, (
            f"{border_right=}. Must be int >= 0"
        )

        # TODO Make these values configurable
        header_pad = 10  # Feel good thing
        button_padding = 20  # Min value that works with spumux

        pointer_path_data: "_Menu_Pointer_Data" = None

        # This keeps spumux happy
        if border_right < self._SPUMUX_BUFFER:
            border_right = self._SPUMUX_BUFFER

        if border_left < self._SPUMUX_BUFFER:
            border_left = self._SPUMUX_BUFFER

        if not self.dvd_config.menu_title:  # Header pad is only for titles
            header_pad = 0

        # Compute the canvas size and ratio
        canvas_width = dvd_dims.storage_width - (border_left + border_right)
        canvas_height = dvd_dims.storage_height - (
            border_top + border_bottom + header_pad
        )

        num_pages = math.ceil(num_buttons / buttons_per_page)

        if num_pages > 1:
            pointer_path_data = self._Menu_Pointer_Data(
                background_canvas_file=self._background_canvas_file,
                dvd_config=self.dvd_config,
                spumux_buffer=self._SPUMUX_BUFFER,
            )

            if pointer_path_data.error_code == -1:
                return (
                    [],
                    "Failed To Get Page Pointer Path & Size",
                )

        pages, num_rows, num_cols = self._build_page_grid(
            num_buttons=num_buttons,
            num_pages=num_pages,
            buttons_per_page=buttons_per_page,
            buttons_across=buttons_across,
        )

        max_button_height = canvas_height // max(
            num_rows, 4
        )  # Do not change as spumux very sensitive to this

        # Compute the maximum width of each rectangle based on the number of columns across all pages
        rect_width_max = (
            (canvas_width // num_cols)
            - (num_cols * button_padding)
            - (border_left + border_right)
        )

        # Compute the dimensions of each rectangle and the padding between them
        rect_width = rect_width_max
        rect_height = int(min(canvas_height / num_rows, max_button_height))
        rect_aspect_ratio = rect_width / rect_height

        if rect_aspect_ratio > button_aspect_ratio:
            rect_width = int(rect_height * button_aspect_ratio)
        else:
            rect_height = int(rect_width / button_aspect_ratio)

        # Compute the vertical padding between the rectangles
        if num_rows > 1:
            rect_padding = (canvas_height - rect_height * num_rows) / (num_rows - 1)
        else:
            rect_padding = canvas_height - rect_height * num_rows

        # We do not want the padding to be too big or small, so we max it at
        # twice the horizontal spacing between the rectangles and min it at button_padding.
        if rect_padding < button_padding or rect_padding > 2 * button_padding:
            rect_padding = 2 * button_padding

        # Want buttons in same pos on all pages, so we calc based on first page
        num_non_empty_rows = sum(1 for row in pages[0] if any(col != -1 for col in row))

        # Calculate the total height of the grid
        total_height = (
            num_non_empty_rows * rect_height + (num_non_empty_rows - 1) * rect_padding
        )

        if total_height > canvas_height:
            return (
                [],
                f"Too Many Buttons Down: {total_height=}  >  {canvas_height=}",
            )

        # Calculate the y offset
        y_offset = ((canvas_height - total_height) // 2) + border_top + header_pad

        cell_cords = []
        file_index = 0
        for page_index, page in enumerate(pages):
            for row_index, row in enumerate(page):
                row_col_count = len([col for col in row if col != -1])

                total_width = (row_col_count * rect_width) + (
                    button_padding * (row_col_count - 1)
                )

                if total_width > canvas_width:
                    return (
                        [],
                        f"Too Many Buttons Across: {total_width=}  >  {canvas_width=}",
                    )

                x_offset = (canvas_width - total_width) // 2 + border_right

                col_index = 0
                for col_value in row:
                    if col_value == -1:  # Ignore not on grid
                        continue

                    x = int(x_offset + col_index * (rect_width + button_padding))
                    y = int(y_offset + row_index * (rect_height + rect_padding))

                    if file_index > len(self.dvd_config.input_videos) - 1:
                        return (
                            [],
                            (
                                "File index out of range 0 -"
                                f" {len(self.dvd_config.input_videos) - 1}"
                            ),
                        )

                    cell_cords.append(
                        _Cell_Coord(
                            name=f"button_{file_index}",
                            x0=x,
                            y0=y,
                            x1=x + rect_width,
                            y1=y + rect_height,
                            width=rect_width
                            - button_padding,  # Provide space between buttons
                            height=rect_height
                            - button_padding,  # Provide space between buttons
                            page=page_index,
                            video_data=self.dvd_config.input_videos[file_index],
                        )
                    )
                    file_index += 1
                    col_index += 1
            if pointer_path_data:  # Add page pointers
                # Left Pointer
                cell_cords.append(
                    _Cell_Coord(
                        name=f"left_pointer_{file_index + 1}",
                        x0=pointer_path_data.left_x_offset,
                        y0=pointer_path_data.left_y_offset,
                        x1=pointer_path_data.left_x_offset + pointer_path_data.width,
                        y1=pointer_path_data.left_y_offset + pointer_path_data.height,
                        width=pointer_path_data.width
                        + button_padding,  # Provide space between buttons
                        height=pointer_path_data.height
                        + button_padding,  # Provide space between buttons
                        page=page_index,
                        video_data=None,
                        cargo={
                            "pointer_data": pointer_path_data,
                            "left": page_index - 1 if page_index > 0 else num_pages,
                        },
                    )
                )

                # Right Pointer
                cell_cords.append(
                    _Cell_Coord(
                        name=f"right_pointer_{file_index + 2}",
                        x0=pointer_path_data.right_x_offset,
                        y0=pointer_path_data.right_y_offset,
                        x1=pointer_path_data.right_x_offset + pointer_path_data.width,
                        y1=pointer_path_data.right_y_offset + pointer_path_data.height,
                        width=pointer_path_data.width
                        + button_padding,  # Provide space between buttons
                        height=pointer_path_data.height
                        + button_padding,  # Provide space between buttons
                        page=page_index,
                        video_data=None,
                        cargo={
                            "pointer_data": pointer_path_data,
                            "right": page_index + 1
                            if page_index < num_pages - 1
                            else 0,
                        },
                    )
                )

        return cell_cords, ""

    def _dvd_page_calc_layout(
        self,
        buttons_per_page: int,
        buttons_across,
        button_aspect_ratio: float,
        dvd_dims: dvdarch_utils.Dvd_Dims,
        border_top: int = 0,
        border_left: int = 0,
        border_bottom: int = 15,
        border_right: int = 0,
    ) -> tuple[list[_Cell_Coord], str]:
        """
        Generates a layout of rectangles with fixed size borders on each edge,
        arranged to fit, according to assigned dvd pages.

        Args:
            buttons_per_page (int): The number of buttons on the DVD menu page
            buttons_across (int): The number of buttons across the DVD menu (buttons down is calculated).
            button_aspect_ratio (float): The aspect ratio of the button rectangles (height/width).
            dvd_dims (dvdarch_utils.dvd_dims): The DVD dimensions
            border_top (int): The width of the border at the top edge of the canvas.
            border_left (int): The width of the border at the left edge of the canvas.
            border_bottom (int): The width of the border at the bottom edge of the canvas.
            border_right (int): The width of the border at the right edge of the canvas.
        Returns:
            tuple[list[_Cell_Coord], str]:
            - arg 1: A list of _Cell_Coords objects representing the layout of the rectangles within the canvas.
            - arg 2 : An error message if there is an error.

        """
        assert isinstance(buttons_per_page, int) and buttons_per_page > 0, (
            f"{buttons_per_page=}. Must be int > 0"
        )
        assert isinstance(buttons_across, int) and buttons_across > 0, (
            f"{buttons_across=}. Must be int > 0"
        )
        assert isinstance(button_aspect_ratio, float) and button_aspect_ratio > 0, (
            f"{button_aspect_ratio=}. Must be float > 0"
        )
        assert isinstance(button_aspect_ratio, float) and button_aspect_ratio > 0, (
            f"{button_aspect_ratio=}. Must be float > 0"
        )
        assert isinstance(dvd_dims, dvdarch_utils.Dvd_Dims), (
            f"{dvd_dims=}. Must be a valid dvd_dims object"
        )
        assert isinstance(border_top, int) and border_top >= 0, (
            f"{border_top=}. Must be int >= 0"
        )
        assert isinstance(border_left, int) and border_left >= 0, (
            f"{border_left=}. Must be int >= 0"
        )
        assert isinstance(border_bottom, int) and border_bottom >= 0, (
            f"{border_bottom=}. Must be int >= 0"
        )
        assert isinstance(border_right, int) and border_right >= 0, (
            f"{border_right=}. Must be int >= 0"
        )

        # TODO Make these values configurable
        header_pad = 10  # Feel good thing
        button_padding = 20  # Min value that works with spumux

        pointer_path_data: "_Menu_Pointer_Data" = None

        # This keeps spumux happy
        if border_right < self._SPUMUX_BUFFER:
            border_right = self._SPUMUX_BUFFER

        if border_left < self._SPUMUX_BUFFER:
            border_left = self._SPUMUX_BUFFER

        if not self.dvd_config.menu_title:  # Header pad is only for titles
            header_pad = 0

        # Compute the canvas size and ratio
        canvas_width = dvd_dims.storage_width - (border_left + border_right)
        canvas_height = dvd_dims.storage_height - (
            border_top + border_bottom + header_pad
        )

        num_pages = (
            self.dvd_config.input_videos[-1].dvd_page + 1
        )  # dvd_page is zero based

        if num_pages > 1:
            pointer_path_data = self._Menu_Pointer_Data(
                background_canvas_file=self._background_canvas_file,
                dvd_config=self.dvd_config,
                spumux_buffer=self._SPUMUX_BUFFER,
            )

            if pointer_path_data.error_code == -1:
                return (
                    [],
                    "Failed To Get Page Pointer Path & Size",
                )

        if buttons_per_page == 1:
            buttons_down = 1
        else:
            buttons_down = math.ceil(buttons_per_page / buttons_across)

        max_button_height = canvas_height // max(
            buttons_down, 4
        )  # Do not change as spumux very sensitive to this

        # Compute the maximum width of each rectangle based on the number of columns across all pages
        rect_width_max = (
            (canvas_width // buttons_across)
            - (buttons_across * button_padding)
            - (border_left + border_right)
        )

        # Compute the dimensions of each rectangle and the padding between them
        rect_width = rect_width_max
        rect_height = int(min(canvas_height / buttons_down, max_button_height))
        rect_aspect_ratio = rect_width / rect_height

        if rect_aspect_ratio > button_aspect_ratio:
            rect_width = int(rect_height * button_aspect_ratio)
        else:
            rect_height = int(rect_width / button_aspect_ratio)

        # Compute the vertical padding between the rectangles
        if buttons_down > 1:
            rect_padding = (canvas_height - rect_height * buttons_down) / (
                buttons_down - 1
            )
        else:
            rect_padding = canvas_height - rect_height * buttons_down

        # We do not want the padding to be too big or small, so we max it at
        # twice the horizontal spacing between the rectangles and min it at button_padding.
        if rect_padding < button_padding or rect_padding > 2 * button_padding:
            rect_padding = 2 * button_padding

        dvd_menu_pages = []
        num_non_empty_rows = 0
        for page_index in range(num_pages):
            page_file_defs = [
                file_def
                for file_def in sorted(
                    self.dvd_config.input_videos, key=lambda item: item.dvd_page
                )
                if file_def.dvd_page == page_index
            ]

            dvd_page = []

            for row_index in range(buttons_down):
                row = []
                for col_index in range(buttons_across):
                    if row_index * buttons_across + col_index >= len(page_file_defs):
                        break

                    row.append(page_file_defs[row_index * buttons_across + col_index])

                if row_index > num_non_empty_rows:
                    num_non_empty_rows = row_index

                dvd_page.append(row)

            dvd_menu_pages.append(dvd_page)

        cell_cords = []
        file_index = 0

        for page_index, page in enumerate(dvd_menu_pages):
            # Num of rows could vary per page so need to calc for each page
            num_non_empty_rows = len([item for item in page if item])

            # Calculate the total height of the grid
            total_height = (
                num_non_empty_rows * rect_height
                + (num_non_empty_rows - 1) * rect_padding
            )

            # Calculate the y offset
            y_offset = ((canvas_height - total_height) // 2) + border_top + header_pad

            for row_index, row in enumerate(page):
                row_col_count = len(row)

                total_width = (row_col_count * rect_width) + (
                    button_padding * (row_col_count - 1)
                )

                if total_width > canvas_width:
                    return (
                        [],
                        f"Too Many Buttons Across: {total_width=}  >  {canvas_width=}",
                    )

                x_offset = (canvas_width - total_width) // 2 + border_right

                col_index = 0
                for col_value in row:
                    if col_value == -1:  # Ignore not on grid
                        continue

                    x = int(x_offset + col_index * (rect_width + button_padding))
                    y = int(y_offset + row_index * (rect_height + rect_padding))

                    if file_index > len(self.dvd_config.input_videos) - 1:
                        return (
                            [],
                            (
                                "File index out of range 0 -"
                                f" {len(self.dvd_config.input_videos) - 1}"
                            ),
                        )

                    cell_cords.append(
                        _Cell_Coord(
                            name=f"button_{file_index}",
                            x0=x,
                            y0=y,
                            x1=x + rect_width,
                            y1=y + rect_height,
                            width=rect_width
                            - button_padding,  # Provide space between buttons
                            height=rect_height
                            - button_padding,  # Provide space between buttons
                            page=page_index,
                            video_data=self.dvd_config.input_videos[file_index],
                        )
                    )
                    file_index += 1
                    col_index += 1
            if pointer_path_data:  # Add page pointers
                # Left Pointer
                cell_cords.append(
                    _Cell_Coord(
                        name=f"left_pointer_{file_index + 1}",
                        x0=pointer_path_data.left_x_offset,
                        y0=pointer_path_data.left_y_offset,
                        x1=pointer_path_data.left_x_offset + pointer_path_data.width,
                        y1=pointer_path_data.left_y_offset + pointer_path_data.height,
                        width=pointer_path_data.width,
                        height=pointer_path_data.height
                        + button_padding,  # Provide space between buttons
                        page=page_index,
                        video_data=None,
                        cargo={
                            "pointer_data": pointer_path_data,
                            "left": page_index - 1 if page_index > 0 else num_pages,
                        },
                    )
                )

                # Right Pointer
                cell_cords.append(
                    _Cell_Coord(
                        name=f"right_button_{file_index + 2}",
                        x0=pointer_path_data.right_x_offset,
                        y0=pointer_path_data.right_y_offset,
                        x1=pointer_path_data.right_x_offset + pointer_path_data.width,
                        y1=pointer_path_data.right_y_offset + pointer_path_data.height,
                        width=pointer_path_data.width,
                        height=pointer_path_data.height
                        + button_padding,  # Provide space between buttons
                        page=page_index,
                        video_data=None,
                        cargo={
                            "pointer_data": pointer_path_data,
                            "right": page_index + 1
                            if page_index < num_pages - 1
                            else 0,
                        },
                    )
                )

        return cell_cords, ""

    def _create_canvas_image(self, width: int, height: int) -> tuple[int, str]:
        """Creates a background canvas to place the menu elements on

        Args:
            width (int): Width in pixels
            height (int ): Height in pixels

        Returns:
            tuple[int,str]
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(width, int) and width > 0, f"{width=}. Must be int > 0"
        assert isinstance(width, int) and width > 0, f"{height=}. Must be int > 0"

        commands = [
            sys_consts.CONVERT,
            "-size",
            f"{width}x{height}",
            f"xc:{self.dvd_config.menu_background_color}",
            self._background_canvas_file,
        ]

        result, message = dvdarch_utils.Execute_Check_Output(commands=commands)

        if result == -1:
            return -1, message

        if self.dvd_config.timestamp_font and self.dvd_config.timestamp:
            _, timestamp_height = dvdarch_utils.Get_Text_Dims(
                text=self.dvd_config.timestamp,
                font=self.dvd_config.timestamp_font,
                pointsize=self.dvd_config.timestamp_font_point_size,
            )

            if timestamp_height == -1:
                return -1, "Failed to get timestamp height"

            result, message = dvdarch_utils.Write_Text_On_File(
                input_file=self._background_canvas_file,
                text=self.dvd_config.timestamp,
                x=self._dvd_timestamp_x_offset,
                y=height - timestamp_height,
                pointsize=self.dvd_config.timestamp_font_point_size,
                color=self.dvd_config.menu_font_color,
                font=self.dvd_config.timestamp_font,
            )

            if result == -1:
                return -1, message

        if self.dvd_config.timestamp_font and self.dvd_config.serial_number:
            serial_num_width, serial_num_height = dvdarch_utils.Get_Text_Dims(
                text=self.dvd_config.serial_number,
                font=self.dvd_config.timestamp_font,
                pointsize=self.dvd_config.timestamp_font_point_size,
            )

            if serial_num_height == -1:
                return -1, "Failed to get serial number height"

            result, message = dvdarch_utils.Write_Text_On_File(
                input_file=self._background_canvas_file,
                text=self.dvd_config.serial_number,
                x=width - serial_num_width - self._dvd_timestamp_x_offset,
                y=height - serial_num_height,
                pointsize=self.dvd_config.timestamp_font_point_size,
                color=self.dvd_config.menu_font_color,
                font=self.dvd_config.timestamp_font,
            )

            if result == -1:
                return -1, message

            calling_card = (
                f"{sys_consts.PROGRAM_NAME} (c)"
                f" {sys_consts.AUTHOR} {sys_consts.COPYRIGHT_YEAR()}"
            )

            progname_width, progname_height = dvdarch_utils.Get_Text_Dims(
                text=calling_card,
                font=self.dvd_config.timestamp_font,
                pointsize=self.dvd_config.timestamp_font_point_size,
            )

            if progname_height == -1:
                return -1, "Failed to get calling card height"

            result, message = dvdarch_utils.Write_Text_On_File(
                input_file=self._background_canvas_file,
                text=calling_card,
                x=width // 2 - progname_width // 2,
                y=height - progname_height,
                pointsize=self.dvd_config.timestamp_font_point_size,
                color=self.dvd_config.menu_font_color,
                font=self.dvd_config.timestamp_font,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _prepare_buttons(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Prepares the buttons and places them on the requisite image files required to build a dvd menu.

        Args:
            cell_coords (list[_Cell_Coord]): The list of cell coordinates.

        Returns:
            tuple[int, str]: A tuple containing the following values:
                - arg1: 1: ok, -1: fail
                - arg2: error message or "" if ok
        """

        # ===== Helper
        def _get_canvas_overlay_files(
            background_path_name: str, background_file_name: str, page_no: int
        ) -> tuple[int, str, str, str, str]:
            """Returns a tuple containing the paths of canvas overlay, highlight, select, and images files.

            Args:
                background_path_name (str): The path of the background file.
                background_file_name (str): The name of the background file.
                page_no (int): The page number for which the canvas files are required.

            Returns:
                tuple[int, str, str, str, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - The path of the canvas overlay file or error_message of not ok .
                    - The path of the canvas highlight file.
                    - The path of the canvas select file.
                    - The path of the canvas images file.
            """
            assert (
                isinstance(background_path_name, str)
                and background_path_name.strip() != ""
            ), f"{background_path_name=}. Must be non-empty str"
            assert (
                isinstance(background_file_name, str)
                and background_file_name.strip() != ""
            ), f"{background_file_name=}. Must be non-empty str"
            assert isinstance(page_no, int) and page_no >= 0, (
                f"{page_no=}. Must be int >= 0"
            )

            canvas_overlay_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_overlay_{page_no}",
                "png",
            )
            canvas_highlight_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_highlight_{page_no}",
                "png",
            )
            canvas_select_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_select_{page_no}",
                "png",
            )
            canvas_images_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_images_{page_no}",
                "png",
            )

            command = [
                sys_consts.CONVERT,
                self._background_canvas_file,
                canvas_images_file,
            ]

            result, message = dvdarch_utils.Execute_Check_Output(commands=command)

            if result == -1:
                return -1, message, "", "", ""

            return (
                1,
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
                canvas_images_file,
            )

        def _create_canvas_files(
            width: int,
            height: int,
            canvas_overlay_file: str,
            canvas_highlight_file: str,
            canvas_select_file: str,
        ) -> tuple[int, str]:
            """Create canvas image files with specified width and height.

            Args:
                width (int): Width of the canvas image files to create.
                height (int): Height of the canvas image files to create.
                canvas_overlay_file (str): Filename for the canvas overlay file.
                canvas_highlight_file (str): Filename for the canvas highlight file.
                canvas_select_file (str): Filename for the canvas select file.

            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if successful, otherwise -1.
                    - "" if successful, otherwise the error message.
            """
            # Check that the width and height are positive integers
            assert isinstance(width, int) and width > 0, f"{width=}. Must be int >= 0 "
            assert isinstance(height, int) and height > 0, (
                f"{height=}. Must be int >= 0 "
            )
            assert (
                isinstance(canvas_overlay_file, str)
                and canvas_overlay_file.strip() != ""
            ), f"{canvas_overlay_file=}. Cannot be empty."
            assert (
                isinstance(canvas_highlight_file, str)
                and canvas_highlight_file.strip() != ""
            ), f"{canvas_highlight_file=}. Cannot be empty."
            assert (
                isinstance(canvas_select_file, str) and canvas_select_file.strip() != ""
            ), f"{canvas_select_file=}. Cannot be empty."

            for file in (
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
            ):
                result, message = dvdarch_utils.Create_Transparent_File(
                    width=width,
                    height=height,
                    out_file=file,
                )

                if result == -1:
                    return -1, message
            return 1, ""

        def _create_outline_files(
            width: int,
            height: int,
            overlay_file: str,
            highlight_file: str,
            selected_file: str,
            highlight_border_colour: str = "gold",
            select_border_colour: str = "white",
        ) -> tuple[int, str]:
            """Creates three outline files (highlight, select, and overlay) with transparent backgrounds and colored borders.

            Args:
                width (int): The width of the outline files in pixels.
                height (int): The height of the outline files in pixels.
                overlay_file (str): The name of the overlay file.
                highlight_file (str): The name of the highlight file.
                selected_file (str): The name of the selected file.
                highlight_border_colour (str, optional): The color of the highlight border. Defaults to "gold".
                select_border_colour (str, optional): The color of the select border. Defaults to "white".

            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - "" if ok otherwise the error message
            """
            assert isinstance(width, int), f"{width=}. Must be int >= 0"
            assert isinstance(height, int), f"{height=} . Must be int >= 0"
            assert isinstance(overlay_file, str) and overlay_file.strip() != "", (
                f"{overlay_file=}. Must be non-empty str"
            )
            assert isinstance(highlight_file, str) and highlight_file.strip() != "", (
                f"{highlight_file} . Must be non-empty str"
            )
            assert isinstance(selected_file, str) and selected_file.strip() != "", (
                f"{selected_file} . Must be non-empty str"
            )
            assert (
                isinstance(highlight_border_colour, str)
                and highlight_border_colour.strip() != ""
            ), f"{highlight_border_colour=} . Must be non-empty str"
            assert (
                isinstance(select_border_colour, str)
                and select_border_colour.strip() != ""
            ), f"{select_border_colour=} . Must be non-empty str"

            # Create the 3 outline files we will need - highlight, select, overlay
            for file in (
                (overlay_file, "transparent"),
                (highlight_file, highlight_border_colour),
                (selected_file, select_border_colour),
            ):
                out_file = file[0]
                border_color = file[1]

                result, message = dvdarch_utils.Create_Transparent_File(
                    width=width,
                    height=height,
                    out_file=out_file,
                    border_color=border_color,
                )

                if result == -1:
                    return -1, message

            return 1, ""

        def _overlay_files(
            x: int, y: int, files: tuple[(str, str), ...]
        ) -> tuple[int, str]:
            """Places a file on another file at a given x, y coord

            Args:
                x (int): x co-ordinate of image
                y (int): y co-ordinate of image
                files (tuple[(str, str), ...]): A tuple of tuples defining the files to be overlaid.
                tuple[0] is the file to be overlaid, tuple[1] is the file to overlay it on.


            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - "" if ok otherwise the error message
            """
            assert isinstance(x, int), f"{x=}. Must be int >= 0"
            assert isinstance(y, int), f"{y=}. Must be int >= 0"
            assert isinstance(files, tuple), f"{files=}. Must be tuple"
            assert all(
                isinstance(file_tuple, tuple) and len(file_tuple) == 2
                for file_tuple in files
            ), f"{files=}. Must be tuple of tuples"

            for file_tuple in files:
                overlaid_file = file_tuple[0]
                overlay_file = file_tuple[1]

                result, message = dvdarch_utils.Overlay_File(
                    in_file=overlaid_file,
                    overlay_file=overlay_file,
                    out_file=overlaid_file,
                    x=x,
                    y=y,
                )

                if result == -1:
                    return 1, message
            return 1, ""

        def _write_spumux_xml(
            page: int,
            spu_buttons: list[dict[str, str]],
            background_path_name: str,
        ) -> tuple[int, str]:
            """
            Writes a spumux xml file for the page.

            Args:
                page (int): The current page number.
                spu_buttons (list[dict[str, str]]): A list of dictionaries defining the spu buttons.
                background_path_name (str): The path name for the background file.

            Returns:
                tuple[int, str]: A tuple of an integer (1 on success, -1 on failure) and a string message.

            """
            assert isinstance(page, int), f"{page=}. Must be int"

            assert (
                isinstance(background_path_name, str)
                and background_path_name.strip() != ""
            ), f"{background_path_name}. Must be str"

            file_handler = file_utils.File()

            (
                result,
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
                _,
            ) = _get_canvas_overlay_files(
                background_path_name=background_path_name,
                background_file_name=background_file_name,
                page_no=page_number,
            )

            if result == -1:
                return (
                    -1,
                    canvas_overlay_file,
                )  # Holds error message if result is -1

            spumux_xml = file_handler.file_join(
                background_path_name, f"spumux_{page_number}", "xml"
            )

            try:
                with open(spumux_xml, "w") as result_file:
                    xmltodict.unparse(
                        input_dict={
                            "subpictures": {
                                "@format": self.dvd_config.video_standard,
                                "stream": {
                                    "spu": {
                                        "@force": "yes",
                                        "@start": "00:00:00.00",
                                        "@image": canvas_overlay_file,
                                        "@highlight": canvas_highlight_file,
                                        "@select": canvas_select_file,
                                        "button": spu_buttons,
                                    }
                                },
                            }
                        },
                        output=result_file,
                        pretty=True,
                    )
            except IOError:
                return -1, f"Sys Error: Could Not Write {spumux_xml}"

            return 1, ""

        # ===== Main
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        file_handler = file_utils.File()

        background_path_name, background_file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        # ----- Write out spumux files #
        spu_pages = {}

        canvas_width, canvas_height, message = dvdarch_utils.Get_Image_Size(
            self._background_canvas_file
        )

        if canvas_width == -1:  # Error
            return -1, message

        for cell_index, cell_coord in enumerate(cell_coords):
            page_number = cell_coord.page  # Get the page number from the cell

            if page_number not in spu_pages:
                spu_pages[page_number] = []

            spu_pages[page_number].append(cell_coord)

        button_index = 0

        for page_number in spu_pages:
            spu_buttons = []
            for cell_coord in spu_pages[page_number]:
                button_x0 = cell_coord.x0
                button_y0 = cell_coord.y0
                button_x1 = cell_coord.x0 + cell_coord.width
                button_y1 = cell_coord.y0 + cell_coord.height

                # Need to ensure y co-ordinates are even to keep some DVD players happy
                if button_y0 % 2 != 0:
                    button_y0 = button_y0 - 1 if button_y0 > 0 else button_y0 + 1

                if button_y1 % 2 != 0:
                    button_y1 += 1

                spu_buttons.append(
                    {
                        "@name": f"{cell_coord.name}",
                        "@x0": button_x0,
                        "@y0": button_y0,
                        "@x1": button_x1,
                        "@y1": button_y1,
                    },
                )

                button_index += 1

            if spu_buttons:  # Write out spumux file
                resut, message = _write_spumux_xml(
                    page=page_number,
                    spu_buttons=spu_buttons,
                    background_path_name=background_path_name,
                )

                if resut == -1:
                    return -1, message

            # Now generate required image files
            (
                result,
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
                canvas_images_file,
            ) = _get_canvas_overlay_files(
                background_path_name=background_path_name,
                background_file_name=background_file_name,
                page_no=page_number,
            )

            if result == -1:
                return (
                    -1,
                    canvas_overlay_file,
                )  # Holds error message if result is -1

            command = [
                sys_consts.CONVERT,
                self._background_canvas_file,
                canvas_images_file,
            ]

            result, message = dvdarch_utils.Execute_Check_Output(commands=command)

            if result == -1:
                return -1, message

            menu_title = self.dvd_config.menu_title[page_number]

            if menu_title.strip() != "":
                result, message = dvdarch_utils.Overlay_Text(
                    in_file=canvas_images_file,
                    text=menu_title,
                    text_font=self.dvd_config.menu_font,
                    text_pointsize=self.dvd_config.menu_font_point_size,
                    text_color=self.dvd_config.menu_font_color,
                    position="top",
                    background_color=self.dvd_config.menu_background_color,
                    opacity=0.9,
                )

                if result == -1:
                    return -1, message

            result, message = _create_canvas_files(
                width=canvas_width,
                height=canvas_height,
                canvas_overlay_file=canvas_overlay_file,
                canvas_highlight_file=canvas_highlight_file,
                canvas_select_file=canvas_select_file,
            )

            if result == -1:
                return -1, message

            for cell_coord in spu_pages[page_number]:
                if cell_coord.video_data is None:  # Menu pointer images
                    if "pointer_data" not in cell_coord.cargo:
                        return -1, "Error: pointer_data not in cell_coord.cargo"

                    pointer_data: "_Menu_Pointer_Data" = cell_coord.cargo[
                        "pointer_data"
                    ]

                    (
                        left_pointer_overlay_file,
                        left_pointer_highlight_file,
                        left_pointer_select_file,
                        _,
                    ) = cell_coord.get_mask_filenames(pointer_data.left_icon_path)

                    (
                        right_pointer_overlay_file,
                        right_pointer_highlight_file,
                        right_pointer_select_file,
                        _,
                    ) = cell_coord.get_mask_filenames(pointer_data.right_icon_path)

                    result, message = _create_outline_files(
                        width=pointer_data.width,
                        height=pointer_data.height,
                        overlay_file=left_pointer_overlay_file,
                        highlight_file=left_pointer_highlight_file,
                        selected_file=left_pointer_select_file,
                        highlight_border_colour="gold",
                        select_border_colour="white",
                    )

                    if result == -1:
                        return -1, message

                    result, message = _create_outline_files(
                        width=pointer_data.width,
                        height=pointer_data.height,
                        overlay_file=right_pointer_overlay_file,
                        highlight_file=right_pointer_highlight_file,
                        selected_file=right_pointer_select_file,
                        highlight_border_colour="gold",
                        select_border_colour="white",
                    )

                    if result == -1:
                        return -1, message

                    # Overlay the pointer outline files on the canvas
                    left_overlay_files = (
                        (canvas_overlay_file, left_pointer_overlay_file),
                        (canvas_select_file, left_pointer_select_file),
                        (canvas_highlight_file, left_pointer_highlight_file),
                        (canvas_images_file, pointer_data.left_icon_path),
                    )

                    right_overlay_files = (
                        (canvas_overlay_file, right_pointer_overlay_file),
                        (canvas_select_file, right_pointer_select_file),
                        (canvas_highlight_file, right_pointer_highlight_file),
                        (canvas_images_file, pointer_data.right_icon_path),
                    )

                    result, message = _overlay_files(
                        x=pointer_data.left_x_offset,
                        y=pointer_data.left_y_offset,
                        files=left_overlay_files,
                    )

                    if result == -1:
                        return -1, message

                    result, message = _overlay_files(
                        x=pointer_data.right_x_offset,
                        y=pointer_data.right_y_offset,
                        files=right_overlay_files,
                    )

                    if result == -1:
                        return -1, message

                else:  # Vido Button images
                    (
                        button_overlay_file,
                        button_highlight_file,
                        button_select_file,
                        button_text_file,
                    ) = cell_coord.get_mask_filenames()

                    width, height, message = dvdarch_utils.Get_Image_Size(
                        button_text_file
                    )

                    if width == -1 or height == -1:
                        return -1, message

                    # Create button outline files
                    result, message = _create_outline_files(
                        width=cell_coord.width,
                        height=cell_coord.height,
                        overlay_file=button_overlay_file,
                        highlight_file=button_highlight_file,
                        selected_file=button_select_file,
                        highlight_border_colour="gold",
                        select_border_colour="white",
                    )

                    if result == -1:
                        return -1, message

                    # Overlay the button outline files on the canvas
                    overlay_files = (
                        (canvas_overlay_file, button_overlay_file),
                        (canvas_select_file, button_select_file),
                        (canvas_highlight_file, button_highlight_file),
                        (canvas_images_file, button_text_file),
                    )

                    result, message = _overlay_files(
                        x=cell_coord.x0, y=cell_coord.y0, files=overlay_files
                    )

                    if result == -1:
                        return -1, message
        return 1, ""

    def _resize_menu_button_images(
        self, cell_coords: list[_Cell_Coord]
    ) -> tuple[int, str]:
        """Resize the menu buttons to fit on the grid layout

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok

        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        for cell_coord in cell_coords:
            if (
                cell_coord.video_data is None
                or cell_coord.video_data.menu_image_file_path == ""
            ):
                continue

            result, message = dvdarch_utils.Resize_Image(
                input_file=cell_coord.video_data.menu_image_file_path,
                out_file=cell_coord.video_data.menu_image_file_path,
                width=cell_coord.width,
                height=cell_coord.height,
                ignore_aspect=True,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _extract_menu_images(self) -> tuple[int, str]:
        """Extracts a random video image for the menu button

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        for video_data in self.dvd_config.input_videos:
            if video_data.encoding_info.video_frame_count <= 0:
                return -1, f"No video frame count found for {video_data.video_path}"

            if (
                video_data.video_file_settings.menu_button_frame == -1
            ):  # No frame number provided, pick a random frame
                menu_image_frame = randint(
                    1, video_data.encoding_info.video_frame_count
                )
            else:
                menu_image_frame = video_data.video_file_settings.menu_button_frame

            if menu_image_frame > video_data.encoding_info.video_frame_count:
                return (
                    -1,
                    (
                        f"{menu_image_frame=} is greater than video frame count"
                        f" {video_data.encoding_info.video_frame_count}"
                    ),
                )

            (
                result,
                image_file,
            ) = dvdarch_utils.Generate_Menu_Image_From_File(
                video_file=video_data.video_path,
                frame_number=menu_image_frame,
                out_folder=self._menu_image_folder,
            )

            if result == -1:
                return result, image_file
            else:
                video_data.menu_image_file_path = image_file

        return 1, ""

    def _convert_to_m2v(
        self, cell_coords: list[_Cell_Coord], frames: int = 300
    ) -> tuple[int, str]:
        """Converts the background_canvas_images_file into a short video stream for the DVD menu

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout
            frames (int, optional): Number of video frames in stream. Defaults to 300

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()

        path_name, file_name, file_extn = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for cell_coord in cell_coords:
            if cell_coord.video_data is None:
                continue

            if prev_page != cell_coord.page:
                prev_page = cell_coord.page

                background_canvas_images_file = file_handler.file_join(
                    path_name, f"{file_name}_images_{cell_coord.page}", file_extn
                )

                jpg_file = file_handler.file_join(
                    path_name, f"{file_name}_jpgcvrt_{cell_coord.page}", "jpg"
                )

                m2v_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "m2v"
                )

                if not file_handler.file_exists(background_canvas_images_file):
                    return (
                        -1,
                        f"Sys Error : {background_canvas_images_file} does not exist!",
                    )

                if self._dvd_config.video_standard == sys_consts.PAL:
                    frame_rate = sys_consts.PAL_SPECS.frame_rate
                else:  # NTSC
                    frame_rate = sys_consts.NTSC_SPECS.frame_rate

                # In theory FFMPEG should take png and make this step unnecessary TODO look into how ffmeg was compiled
                result, message = dvdarch_utils.Execute_Check_Output(
                    [sys_consts.CONVERT, background_canvas_images_file, jpg_file],
                    debug=False,
                    # stderr_to_stdout=True,
                )

                if result == -1:
                    return -1, message

                command = [
                    sys_consts.FFMPG,
                    "-loop",
                    "1",
                    "-t",
                    f"{frames}",
                    "-i",
                    jpg_file,
                    "-f",
                    "lavfi",
                    "-i",
                    "anullsrc=r=48000:cl=stereo",
                    "-t",
                    "10",
                    "-c:v",
                    "mpeg2video",
                    "-q:v",
                    "2",
                    "-r",
                    f"{frame_rate}",
                    "-c:a",
                    "mp2",
                    "-b:a",
                    "192k",
                    "-y",
                    m2v_file,
                ]

                result, message = dvdarch_utils.Execute_Check_Output(
                    command, debug=False
                )

                if result == -1:
                    return -1, message

        return 1, ""

    def _convert_audio(
        self, cell_coords: list[_Cell_Coord], frames: int = 300
    ) -> tuple[int, str]:
        """Generates the audio for the DVD menu. By default it is a empty soundtrack
        TODO Allow user selection of an audio file

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout
            frames (int, optional): Number of video frames - determines length of
            audio. Defaults to 300.

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for cell_coord in cell_coords:
            if cell_coord.video_data is None:
                continue

            if prev_page != cell_coord.page:
                prev_page = cell_coord.page

                ac3_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "ac3"
                )

                if self._dvd_config.video_standard == sys_consts.PAL:
                    framerate = 25
                else:
                    framerate = 30000 / 1001

                duration = math.floor(frames / framerate)

                # TODO Allow an audio file of the users choice
                # Generate an empty audio file
                commands = [
                    sys_consts.FFMPG,
                    "-f",
                    "lavfi",
                    "-i",
                    "anullsrc=channel_layout=5.1:sample_rate=48000",
                    "-t",
                    f"{duration}",
                    "-b:a",
                    "224000",
                    "-c:a",
                    "ac3",
                    ac3_file,
                ]

                result, message = dvdarch_utils.Execute_Check_Output(commands=commands)

                if result == -1:
                    return -1, message

        return 1, ""

    def _multiplex_audio_video(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Multiplexes the menu m2v file and the menu ac3 file to produce the menu mgp file

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for cell_coord in cell_coords:
            if cell_coord.video_data is None:
                continue

            if prev_page != cell_coord.page:
                prev_page = cell_coord.page

                ac3_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "ac3"
                )
                m2v_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "m2v"
                )
                menu_video_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "mpg"
                )

                commands = [
                    sys_consts.MPLEX,
                    "-f",
                    "8",
                    "-o",
                    menu_video_file,
                    m2v_file,
                    ac3_file,
                ]

                result, message = dvdarch_utils.Execute_Check_Output(commands=commands)

                if result == -1:
                    return -1, message
        return 1, ""

    def _create_menu_mpg(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Creates the DVD menu mpg file via the dvdauthor application spumux

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for coord in cell_coords:
            if prev_page != coord.page:
                prev_page = coord.page

                menu_video_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{coord.page}", "mpg"
                )
                menu_video_buttons_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_buttons_{coord.page}", "mpg"
                )

                spumux_xml = file_handler.file_join(
                    path_name, f"spumux_{coord.page}", "xml"
                )

                env = {"VIDEO_FORMAT": self.dvd_config.video_standard}

                commands = [
                    sys_consts.SPUMUX,
                    "-m",
                    "dvd",
                    "-s",
                    str(0),
                    spumux_xml,
                ]

                try:
                    input_file = open(menu_video_file, "rb")
                    output_file = open(menu_video_buttons_file, "wb")

                    result = subprocess.run(
                        commands,
                        env=env,
                        stdin=input_file,
                        stdout=output_file,
                        stderr=subprocess.PIPE,
                        text=True,
                    )

                    if result.returncode != 0:
                        return -1, result.stderr.strip()
                except IOError as e:
                    return -1, f"Error opening file: {e}"
                finally:
                    input_file.close()
                    output_file.close()

        return 1, ""

    def _create_dvd_image(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Creates the DVD Folder/File structure via the dvdauthor application

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int, str]: arg 1 : 1 Ok, -1 Fail, arg 2 : "" if Ok otherwise Error Message
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()
        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        # Create the main DVD author structure
        dvd_author_dict = {
            "dvdauthor": {
                "@dest": "DVD",
                "@jumppad": "1",
                "vmgm": {"menus": {}},
                "titleset": [],
            }
        }

        spu_pages = {}
        pgcs = []
        title_set_index = 0

        # Create the DVD menu spu pages dictionary
        for cell_index, cell_coord in enumerate(cell_coords):
            page_number = cell_coord.page

            if page_number not in spu_pages:
                spu_pages[page_number] = []

            spu_pages[page_number].append(cell_coord)

        # Build dictionary of menu/button/title entries
        for page_index, spu_page in enumerate(spu_pages):
            prev_index = page_index - 1 if page_index > 0 else len(spu_pages) - 1
            next_index = page_index + 1 if page_index < len(spu_pages) - 1 else 0

            # Note: The buttons. titles and menu indicies are 1 based so need to add 1
            menu_video_file = file_handler.file_join(
                path_name, f"{file_name}_menu_video_buttons_{page_index}.mpg"
            )
            pgc = {"vob": {"@pause": "inf"}, "button": []}

            for cell_coord in spu_pages[spu_page]:
                pgc["vob"]["@file"] = menu_video_file
                if cell_coord.name.startswith("button"):
                    pgc["button"].append({
                        "@name": f"{cell_coord.name}",  # cell_coord.name,
                        "#text": f"jump title {title_set_index + 1};",
                    })
                elif cell_coord.name.startswith("left"):
                    pgc["button"].append({
                        "@name": f"{cell_coord.name}",  # cell_coord.name,
                        "#text": f"jump vmgm menu {prev_index + 1};",
                    })
                elif cell_coord.name.startswith("right"):
                    pgc["button"].append({
                        "@name": f"{cell_coord.name}",  # cell_coord.name,
                        "#text": f"jump vmgm menu {next_index + 1};",
                    })

                if cell_coord.video_data is not None:
                    vob_file = file_handler.file_join(
                        self._vob_folder, cell_coord.video_data.video_file, "vob"
                    )

                    dvd_author_dict["dvdauthor"]["titleset"].append({
                        "titles": {
                            "video": {
                                "@format": self.dvd_config.video_standard,
                                "@aspect": cell_coord.video_data.encoding_info.video_ar,
                            },
                            "pgc": {
                                "vob": {"@file": vob_file},
                                "post": {f"call vmgm menu {page_index + 1};"},
                            },
                        }
                    })

                    title_set_index += 1

            pgcs.append(pgc)

        dvd_author_dict["dvdauthor"]["vmgm"]["menus"] = {
            "video": {
                "@format": self.dvd_config.video_standard,
                "@aspect": self.dvd_config.menu_aspect_ratio,
            },
            "pgc": pgcs,
        }

        # Generate the DVDAuthor XML file
        dvd_author_file = file_handler.file_join(path_name, "dvd_author", "xml")

        try:
            with open(dvd_author_file, "w") as result_file:
                (
                    xmltodict.unparse(
                        input_dict=dvd_author_dict, output=result_file, pretty=True
                    )
                )
        except IOError:
            return -1, f"Sys Error: Could Not Write {dvd_author_file}"

        # Run the DVDauthor XML control file
        env = {"VIDEO_FORMAT": self.dvd_config.video_standard}

        commands = [
            sys_consts.DVDAUTHOR,
            "-x",
            dvd_author_file,
            "-o",
            self._dvd_out_folder,
        ]

        # Had to use shell if I did not run like this
        result = subprocess.run(
            commands, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )

        if result.returncode == 0:
            iso_folder = file_handler.file_join(self._iso_out_folder, "dvd_iso")

            return dvdarch_utils.Create_DVD_Iso(self._dvd_out_folder, iso_folder)

        else:
            return -1, result.stderr.strip()
