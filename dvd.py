"""
    Produces a DVD folder with an autogenerated menu

    Copyright (C) 2022  David Worboys (-:alumnus Moyhu Primary School et al.:-)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

# Tell Black to leave this block alone (realm of isort)
# fmt: off
import dataclasses
import datetime
import hashlib
import math
import subprocess
from random import randint
from typing import Optional

import psutil
import xmltodict

import dvdarch_utils
import file_utils
import sqldb
import sys_consts

# fmt: on

# ===== Public API class for class DVD use


@dataclasses.dataclass
class File_Def:
    _path: str = ""
    _file_name: str = ""
    _menu_image_frame: int = -1
    _mneu_image_file_path: str = ""
    _file_info: dict = dataclasses.field(default_factory=dict)

    @property
    def path(self) -> str:
        return self._path

    @path.setter
    def path(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a file path"

        assert file_utils.File().path_exists(value), f"{value=}. Path does not exist"

        self._path = value

    @property
    def file_name(self) -> str:
        return self._file_name

    @file_name.setter
    def file_name(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a file name"

        self._file_name = value

    @property
    def file_info(self) -> dict:
        return self._file_info

    @file_info.setter
    def file_info(self, value: dict):
        assert isinstance(value, dict), f"{value=}. Must be a dict of file properties"

        self._file_info = value

    @property
    def menu_image_file_path(self) -> str:
        return self._mneu_image_file_path

    @menu_image_file_path.setter
    def menu_image_file_path(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a file path"

        assert file_utils.File().file_exists(value), f"{value=}. Path does not exist"

        self._mneu_image_file_path = value

    @property
    def menu_image_frame(self) -> int:
        return self._menu_image_frame

    @menu_image_frame.setter
    def menu_image_frame(self, value: int):
        assert (
            isinstance(value, int) and value >= 0
        ), f"{value=}. Must be a non-negative integer"

        self._menu_image_frame = value

    @property
    def file_path(self) -> str:
        assert (
            self.path != "" and self.file_name != ""
        ), f"{self.path=}, {self.file_name=}. Must be set"

        return file_utils.File().file_join(self.path, self.file_name)


@dataclasses.dataclass
class DVD_Config:
    _input_videos: list[File_Def] | tuple[File_Def] = ()
    _menu_labels: list[str] | tuple[str] = ()
    _menu_title: str = ""
    _menu_background_color: str = "wheat"
    _menu_font_color: str = "gold"
    _menu_font_point_size: int = 24
    _menu_font: str = ""
    _menu_aspect_ratio: str = sys_consts.AR43
    _serial_number: str = ""
    _timestamp_font: str = ""
    _timestamp_font_point_size: int = 11
    _timestamp_prefix: str = "DVD Build Date:"
    _timestamp: str = (
        f"{_timestamp_prefix} : {datetime.datetime.now().strftime('%x %Y %H:%M')}"
    )
    _video_standard: str = sys_consts.PAL

    @property
    def input_videos(self):
        return self._input_videos

    @input_videos.setter
    def input_videos(self, value: list[File_Def] | tuple[File_Def]):
        assert isinstance(
            value, (list, tuple)
        ), f"{value=}. Must be a list | tuple of File_Def"

        for video_file in value:
            assert isinstance(
                video_file, File_Def
            ), f"{video_file=}. Must be a File_Def"

            assert file_utils.File().path_exists(
                video_file.path
            ), f"{video_file.path=}. Must be a valid file path"

        self._input_videos = value

    @property
    def menu_labels(self):
        return self._menu_labels

    @menu_labels.setter
    def menu_labels(self, value: list[str] | tuple[str]):
        assert isinstance(
            value, (list, tuple)
        ), f"{value=}. Must be a list | tuple of str"

        for menu_label in value:
            assert (
                isinstance(menu_label, str) and menu_label.strip() != ""
            ), f"{menu_label=}. Must be a non-empty string"

        self._menu_labels = value

    @property
    def menu_background_color(self):
        return self._menu_background_color

    @menu_background_color.setter
    def menu_background_color(self, value: str):
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._menu_background_color = value

    @property
    def menu_title(self):
        return self._menu_title

    @menu_title.setter
    def menu_title(self, value: str):
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._menu_title = value

    @property
    def menu_aspect_ratio(self):
        return self._menu_aspect_ratio

    @menu_aspect_ratio.setter
    def menu_aspect_ratio(self, value: str):
        assert isinstance(value, str), f"{value=}. Must be a string"
        assert value.upper() in (
            sys_consts.AR169,
            sys_consts.AR43,
        ), f"{value=}. Must be AR169 | AR43"

        self._menu_aspect_ratio = value.upper()

    @property
    def menu_font(self) -> str:
        return self._menu_font

    @menu_font.setter
    def menu_font(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        if file_utils.File().file_exists(value):
            self._menu_font = value
            return
        else:
            for font in dvdarch_utils.get_fonts():
                if font[0] == value:
                    self._menu_font = font[1]
                    return

        raise RuntimeError(f"{value=}. Font not found")

    @property
    def menu_font_color(self) -> str:
        return self._menu_font_color

    @menu_font_color.setter
    def menu_font_color(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._menu_font_color = value

    @property
    def menu_font_point_size(self) -> int:
        return self._menu_font_point_size

    @menu_font_point_size.setter
    def menu_font_point_size(self, value: int):
        assert isinstance(value, int) and value > 1, f"{value=}. Must be an int > 1"

        self._menu_font_point_size = value

    @property
    def serial_number(self) -> str:
        return self._serial_number

    @serial_number.setter
    def serial_number(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._serial_number = value

    @property
    def timestamp_font(self) -> str:
        return self._timestamp_font

    @timestamp_font.setter
    def timestamp_font(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        if file_utils.File().path_exists(value):
            self._timestamp_font = value
            return
        else:
            for font in dvdarch_utils.get_fonts():
                if font[0] == value:
                    self._timestamp_font = font[1]
                    return

        raise RuntimeError(f"{value=}. Font not found")

    @property
    def timestamp_font_point_size(self) -> int:
        return self._timestamp_font_point_size

    @timestamp_font_point_size.setter
    def timestamp_font_point_size(self, value: int):
        assert isinstance(value, int) and value > 1, f"{value=}. Must be an int > 1"

        self._timestamp_font_point_size = value

    @property
    def timestamp_prefix(self) -> str:
        return self._timestamp_prefix

    @timestamp_prefix.setter
    def timestamp_prefix(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._timestamp_prefix = value

    @property
    def timestamp(self) -> str:
        return self._timestamp

    @timestamp.setter
    def timestamp(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._timestamp = value

    @property
    def video_standard(self):
        return self._video_standard

    @video_standard.setter
    def video_standard(self, value: str):
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._video_standard = value.upper()

        assert value in (
            sys_consts.PAL,
            sys_consts.NTSC,
        ), f"{value=}. Must be NTSC or PAL"

    def __post_init__(self):
        if self.menu_background_color.strip() == "":
            self.menu_background_color = "wheat"


@dataclasses.dataclass(slots=True)
class _Cell_Coords:
    x0: int = 0
    y0: int = 0
    x1: int = 0
    y1: int = 0
    width: int = 0
    height: int = 0


# ===== Public Class
@dataclasses.dataclass
class DVD:
    """Does the grunt work needed to automatically turn video files into a
    DVD Folder/File structure with an auto generated menu"""

    _BACKGROUND_CANVAS_FILE: str = "background_canvas.png"

    # Database
    _db_settings: sqldb.App_Settings = sqldb.App_Settings(sys_consts.PROGRAM_NAME)
    _application_db: Optional[sqldb.SQLDB] = None

    # Internal instance vars
    _dvd_setup: DVD_Config = None
    _dvd_timestamp_x_offset: int = 10  # TODO Make user configurable

    # folders
    _working_folder: str = ""
    _dvd_working_folder: str = ""
    _dvd_out_folder: str = ""
    _iso_out_folder: str = ""
    _menu_image_folder: str = ""
    _tmp_folder: str = ""
    _vob_folder: str = ""

    # file names
    _background_canvas_file: str = ""

    def __post_init__(self):
        pass

    @property
    def dvd_setup(self) -> DVD_Config:
        return self._dvd_setup

    @dvd_setup.setter
    def dvd_setup(self, value: DVD_Config):
        assert isinstance(value, DVD_Config), f"{value=}. Must be a DVD_Setup"

        self._dvd_setup = value

    @property
    def working_folder(self) -> str:
        return self._working_folder

    @working_folder.setter
    def working_folder(self, value: str):
        assert (
            isinstance(value, str) and value.strip() != ""
        ), f"{value=}. Must be a non-empty string"

        self._working_folder = value

    @property
    def application_db(self) -> sqldb.SQLDB:
        return self._application_db

    @application_db.setter
    def application_db(self, value: sqldb.SQLDB | None):
        assert (
            isinstance(value, sqldb.SQLDB)
        ) or value is None, f"{value=}. Must be an instance of sqldb.SQLDB or None"

        self._application_db = value

    @property
    def dvd_image_folder(self) -> str:
        return self._dvd_out_folder

    @property
    def iso_folder(self) -> str:
        return self._iso_out_folder

    def build(self) -> tuple[int, str]:
        """Builds the  DVD Folder/File structure

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert (
            len(self.dvd_setup.input_videos) > 0
        ), "Must have at least one input video"
        assert len(self.dvd_setup.menu_labels) > 0, "Must have at least one menu label"
        assert len(self.dvd_setup.input_videos) == len(
            self.dvd_setup.menu_labels
        ), "Input videos and menu_labels must be the same length"

        error_no, error_message = self._build_working_folders()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._encode_video()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._extract_menu_images()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._create_dvd_menu()

        if error_no == -1:
            return error_no, error_message

        error_no, error_message = self._create_dvd_image()

        if error_no == -1:
            return error_no, error_message

        return 1, ""

    def generate_dvd_serial_number(
        self, product_code: str = "HV", product_description="Home Video"
    ) -> str:
        """
        Generates a DVD serial number with the format "DVD-AB-000001-5"

        Parameters:
            product_code (str): A string that identifies the product code, e.g. "HV" for home video.
            product_description (str): A string that describes the product code, e.g. "Home Video" for home video.

        Returns:
            str: A string containing the generated DVD serial number.
        """
        assert (
            isinstance(product_code, str) and product_code.strip() != ""
        ), f"{product_code=}. Must be a non-empty string"
        assert (
            isinstance(product_description, str) and product_description.strip() != ""
        ), f"{product_description=}. Must be a non-empty string"

        # Increment the sequential number for each DVD produced
        if not self._db_settings.setting_exist("serial_number"):
            self._db_settings.setting_set("serial_number", 0)

        serial_number = self._db_settings.setting_get("serial_number")
        serial_number += 1
        self._db_settings.setting_set("serial_number", serial_number)

        # Generate the serial number string
        serial_number_str = "{:06d}".format(serial_number)
        serial_number_checksum = hashlib.md5(serial_number_str.encode()).hexdigest()[0]
        serial_number_str = (
            f"DVD-{product_code}-{serial_number_str}-{serial_number_checksum}"
        )

        return serial_number_str

    def _build_working_folders(self) -> tuple[int, str]:
        """Builds the working file structure.

        All of these files are disposable once the DVD image is created

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        self._dvd_working_folder = file_handler.file_join(
            self.working_folder, f"{sys_consts.PROGRAM_NAME} DVD Builder"
        )

        if file_handler.path_exists(
            self._dvd_working_folder
        ) and file_handler.path_writeable(
            self._dvd_working_folder
        ):  # Blow it away
            result, message = file_handler.remove_dir_contents(self._dvd_working_folder)

            if result == -1:
                return -1, message

        if file_handler.path_exists(
            self.working_folder
        ) and file_handler.path_writeable(self.working_folder):
            file_handler.make_dir(self._dvd_working_folder)

        if file_handler.path_exists(
            self._dvd_working_folder
        ) and file_handler.path_writeable(self._dvd_working_folder):
            self._dvd_out_folder = file_handler.file_join(
                self._dvd_working_folder, "dvd_image"
            )
            self._iso_out_folder = file_handler.file_join(
                self._dvd_working_folder, "iso_image"
            )
            self._menu_image_folder = file_handler.file_join(
                self._dvd_working_folder, "menu_images"
            )
            self._tmp_folder = file_handler.file_join(self._dvd_working_folder, "tmp")
            self._vob_folder = file_handler.file_join(self._dvd_working_folder, "vobs")

            try:
                file_handler.make_dir(self._dvd_out_folder)
                file_handler.make_dir(self._iso_out_folder)
                file_handler.make_dir(self._menu_image_folder)
                file_handler.make_dir(self._tmp_folder)
                file_handler.make_dir(self._vob_folder)
            except OSError as error:
                return -1, f"{error.errno} {error.strerror}"

        if not file_handler.path_exists(
            self._dvd_working_folder
        ) and not file_handler.path_writeable(self._dvd_working_folder):
            return (
                -1,
                (
                    f"{self._dvd_working_folder=}. Could Not Be Created Or Is Not"
                    " Writeable"
                ),
            )

        # Build mandatory file paths
        self._background_canvas_file = file_handler.file_join(
            self._tmp_folder, self._BACKGROUND_CANVAS_FILE
        )

        return 1, ""

    def _encode_video(self) -> tuple[int, str]:
        """Encodes the input video files as DVD VOB (mpeg2) files

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        # Black Video Choices
        average_bit_rate = sys_consts.AVERAGE_BITRATE
        apply_video_filters = True

        # Black filter Choices for now TODO Allow some user configuration
        debug = False
        normalise_video_filter = (  # Try to improve exposure of video
            "normalize=blackpt=black:whitept=white:smoothing=12:independence=1"
        )

        video_denoise_filter = "nlmeans=1.0:7:5:3:3"  # Light but fairly fast denoise
        color_correct_filter = "colorcorrect=analyze='average'"  # Fixes white balance
        usharp_filter = "unsharp=luma_amount=0.2"  # Gentle sharpening of luma channel

        # Black frame around the video to hide things like head switching noise
        black_box_filter = "drawbox=y=ih-h:w=0:h=10:t=fill"

        # Tries to lighten dark videos somewhat
        auto_bright = "pp=dr/al"

        if apply_video_filters:
            video_filters = [
                "-vf",  # set video filters,
                (  # video filters applied
                    f"{normalise_video_filter},{auto_bright},{video_denoise_filter},"
                    f" {color_correct_filter}, {usharp_filter},"
                    f" {black_box_filter}"
                ),
            ]
        else:
            video_filters = []

        for video_file in self.dvd_setup.input_videos:
            _, file_name, _ = file_handler.split_file_path(video_file.file_path)
            vob_file = file_handler.file_join(self._vob_folder, file_name, "vob")

            if (
                "video_height" not in video_file.file_info
                or "video_width" not in video_file.file_info
            ):
                return (
                    -1,
                    f"{video_file.file_path=}. Does Not Specify Height and/or Width",
                )

            if "video_ar" not in video_file.file_info:
                return -1, f"{video_file.file_path=}. Does Not Video Aspect Ratio"

            if str(video_file.file_info["video_ar"][1]).startswith("1.33"):
                aspect_ratio = sys_consts.AR43
            elif str(video_file.file_info["video_ar"][1]).startswith("1.78"):
                aspect_ratio = sys_consts.AR169
            else:
                return (
                    -1,
                    (
                        "Unrecognised Aspect Ratio :"
                        f" {video_file.file_info['video_ar'][1]}"
                    ),
                )

            video_width = video_file.file_info["video_width"][1]
            video_height = video_file.file_info["video_height"][1]

            if self.dvd_setup.video_standard == sys_consts.PAL:
                frame_rate = f"{sys_consts.PAL_FRAMERATE}"
                if video_width == 720 and video_height == 576:
                    video_size = f"{video_width}x{video_height}"
                else:
                    # TODO Add Resize Filter
                    return (
                        -1,
                        (
                            f"Video {video_width=}x{video_height} does not conform to"
                            " PAL standard size 720x576"
                        ),
                    )
            else:  # NTSC
                frame_rate = f"{sys_consts.NTSC_FRAMERATE}"
                # TODO Add Resize Filter
                if video_width == 720 and video_height == 480:
                    video_size = f"{video_width}x{video_height}"
                else:
                    return (
                        -1,
                        (
                            f"Video {video_width=}x{video_height} does not conform to"
                            " NTSC standard size 720x480"
                        ),
                    )

            if debug:
                command_header = [
                    sys_consts.FFMPG,  # the ffmpeg executable
                    "-report",  # Generate verbose output for debug
                ]
            else:
                command_header = [sys_consts.FFMPG]

            interlaced_flags = []
            if "video_scan_type" in video_file.file_info:
                if (
                    str(video_file.file_info["video_scan_type"][1])
                    .lower()
                    .startswith("interlaced")
                ):
                    interlaced_flags = [
                        "-flags:v:0",  # video flags for the first video stream
                        "+ilme+ildct",  # include interlaced motion estimation and interlaced DCT
                        "-alternate_scan:v:0",  # set alternate scan for first video stream (interlace)
                        "1",  # alternate scan value is 1
                    ]

            command = (
                command_header
                + [
                    "-fflags",  # set ffmpeg flags
                    "+genpts",  # generate presentation timestamps
                    "-threads",  # set number of threads to use
                    f"{psutil.cpu_count(logical=False) - 1}",  # To be responsive use 1 core less than is in the system
                    "-i",  # input flag
                    video_file.file_path,  # path to video file
                ]
                + interlaced_flags
                + [
                    "-f",  # set output format
                    "dvd",  # output format is DVD
                    "-c:v:0",  # codec for the first video stream
                    "mpeg2video",  # use mpeg2video codec
                    "-aspect",  # set aspect ratio
                    aspect_ratio,  # aspect ratio value
                    "-s",  # set resolution
                    video_size,  # resolution value
                    "-r",  # set frame rate
                    frame_rate,  # frame rate value
                    "-g",  # set GOP (group of pictures) size
                    "15",  # GOP size is 15
                    "-pix_fmt",  # set pixel format
                    "yuv420p",  # use YUV 420p pixel format
                    "-b:v",  # set video bitrate
                    f"{average_bit_rate}k",  # average video bitrate is kilobits/sec
                    "-maxrate:v",  # set maximum video rate
                    "9000k",  # maximum video rate is 9000 kilobits/sec
                    "-minrate:v",  # set minimum video rate
                    "0",  # minimum video rate is 0
                    "-bufsize:v",  # set video buffer size
                    "1835008",  # video buffer size is 1835008 bits
                    "-packetsize",  # set packet size
                    "2048",  # packet size is 2048 bits
                    "-muxrate",  # set mux rate
                    "10080000",  # mux rate is 10080000 bits/sec
                    "-force_key_frames",  # force key frames
                    "expr:if(isnan(prev_forced_n),1,eq(n,prev_forced_n + 15))",  # set key frame expression (Closes each GOP)
                ]
                + video_filters
                + [
                    "-b:a",  # set audio bitrate
                    "192000",  # audio bitrate is 192000 bits/sec
                    "-ar",  # set audio sample rate
                    "48000",  # audio sample rate is 48000 samples/sec
                    "-c:a:0",  # codec for the first audio stream
                    "ac3",  # use ac3 codec
                    "-filter:a:0",  # audio filter for the first audio stream
                    "loudnorm=I=-16:LRA=11:TP=-1.5",  # use loudnorm filter with specified parameters
                    "-map",  # set mapping
                    "0:V",  # map first video stream
                    "-map",  # set mapping
                    "0:a",  # map first audio stream
                    "-map",  # set mapping
                    "-0:s",  # exclude first subtitle stream
                    vob_file,  # Output encoded VOB file for inclusion in DVD
                ]
            )

            result, message = dvdarch_utils.execute_check_output(commands=command)

            if result == -1:
                return -1, message

        return 1, ""

    def _create_dvd_menu(self) -> tuple[int, str]:
        """Creates the DVD menu automagically

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        debug = False

        menu_title_height = 0
        timestamp_height = 0

        dvd_dims = dvdarch_utils.get_dvd_dims(
            self.dvd_setup.menu_aspect_ratio, self.dvd_setup.video_standard
        )
        if dvd_dims.display_height == -1:
            return -1, "Failed To Get DVD Dimensions"

        if self.dvd_setup.menu_title:
            _, menu_title_height = dvdarch_utils.get_text_dims(
                text=self.dvd_setup.menu_title,
                font=self.dvd_setup.menu_font,
                pointsize=self.dvd_setup.menu_font_point_size,
            )

            if menu_title_height == -1:
                print(f"DBG {self.dvd_setup.menu_title=}")
                return -1, "Failed To Get Menu Title Dimensions"

        if self.dvd_setup.timestamp:
            _, timestamp_height = dvdarch_utils.get_text_dims(
                text=self.dvd_setup.timestamp,
                font=self.dvd_setup.timestamp_font,
                pointsize=self.dvd_setup.timestamp_font_point_size,
            )

            if timestamp_height == -1:
                return -1, "Failed To Get TimEstamp Dimensions"

        cell_coords, message = self._calc_layout(
            num_buttons=len(self.dvd_setup.input_videos),
            button_aspect_ratio=4 / 3,
            dvd_dims=dvd_dims,
            border_top=10 + menu_title_height,
            border_bottom=10 + timestamp_height,
            border_left=10,  # + timestamp_height,
            border_right=10,  # + timestamp_height,
        )

        if not cell_coords:
            return -1, message

        result, message = self._create_canvas_image(
            width=dvd_dims.display_width, height=dvd_dims.display_height
        )
        if result == -1:
            return result, message

        canvas_height, message = dvdarch_utils.get_image_height(
            self._background_canvas_file
        )
        if canvas_height == -1:
            return -1, message

        canvas_width, message = dvdarch_utils.get_image_width(
            self._background_canvas_file
        )
        if canvas_width == -1:
            return -1, message

        result, message = self._resize_menu_button_images(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_labels()

        if result == -1:
            return -1, message

        if debug:
            print("=============================")
            print(f"DBG  {canvas_height=} {canvas_width=} ")
            print(f"DBG {dvd_dims=}")
            print(f"DBG {cell_coords=}")
            print("=============================")

        result, message = self._prepare_buttons(
            cell_coords=cell_coords,
            max_cell_width=0,  # cell_width_max,
            max_cell_height=0,  # cell_height_max,
        )

        if result == -1:
            return -1, message

        result, message = self._convert_to_m2v()

        if result == -1:
            return -1, message

        result, message = self._convert_audio()

        if result == -1:
            return -1, message

        result, message = self._multiplex_audio_video()

        if result == -1:
            return -1, message

        result, message = self._create_menu_mpg()

        if result == -1:
            return -1, message

        return 1, ""

    def _create_labels(self) -> tuple[int, str]:
        """
        Create images for each label to be placed on the button images.

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail,
            - arg2: error message or "" if ok
        """
        # Black Choice
        # label_line_height = 0
        # label_lines = 2
        font: str = "DejaVu-Sans-Bold"
        pointsize: int = 20
        # fill: str = "white"
        # fill: str = "gold"
        # stroke: str = "black"
        # strokewidth: int = 0
        # word_spacing: int = 0
        # clear_inner_stroke: bool = True
        # line_height: int = 0
        # max_width: int = 0
        # max_lines: int = 1
        # size: int = 0
        # undercolor = "RoyalBlue"
        # background: str = "none"
        # gravity: str = "center"

        file_handler = file_utils.File()

        for input_video in self.dvd_setup.input_videos:
            path_name, file_name, file_extn = file_handler.split_file_path(
                input_video.menu_image_file_path
            )

            # Setup required files
            menu_button_file = file_handler.file_join(path_name, file_name, file_extn)
            menu_button_text_file = file_handler.file_join(
                path_name, f"{file_name}_text", file_extn
            )

            if not file_handler.file_exists(menu_button_file):
                return -1, f"Video File Does Not Exist : {menu_button_file}"

            menu_text = file_utils.File().extract_title(file_name)

            result, message = dvdarch_utils.overlay_text(
                in_file=menu_button_file,
                out_file=menu_button_text_file,
                text=menu_text,
                text_font=font,
                text_pointsize=pointsize,
                text_color="white",
                position="bottom",
                background_color="black",
                opacity=0.8,
                y_offset=10,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _calc_layout(
        self,
        num_buttons: int,
        button_aspect_ratio: float,
        dvd_dims: dvdarch_utils.dvd_dims,
        border_top: int = 0,
        border_left: int = 0,
        border_bottom: int = 15,
        border_right: int = 0,
    ) -> tuple[list[_Cell_Coords], str]:
        """
        Generates a layout of rectangles with fixed size borders on each edge,
        arranged to fit within a canvas of fixed aspect ratio.

        Args:
            num_buttons (int): The number of num_buttons to be arranged.
            button_aspect_ratio (float): The aspect ratio of the button rectangles (height/width).
            dvd_dims (dvdarch_utils.dvd_dims): The DVD dimenstions
            border_top (int): The width of the border at the top edge of the canvas.
            border_left (int): The width of the border at the left edge of the canvas.
            border_bottom (int): The width of the border at the bottom edge of the canvas.
            border_right (int): The width of the border at the right edge of the canvas.
        Returns:
            tuple[list[_Cell_Coords], str]:
            - arg 1: A list of _Cell_Coords objects representing the layout of the rectangles within the canvas.
            - arg 2 : An error message if there is an error.

        """
        assert (
            isinstance(num_buttons, int) and num_buttons > 0
        ), f"{num_buttons=}. Must be int > than zero"
        assert (
            isinstance(button_aspect_ratio, float) and button_aspect_ratio > 0
        ), f"{button_aspect_ratio=}. Must be float > than zero"
        assert isinstance(
            dvd_dims, dvdarch_utils.dvd_dims
        ), f"{dvd_dims=}. Must be a valid dvd_dims object"
        assert (
            isinstance(border_top, int) and border_top >= 0
        ), f"{border_top=}. Must be int >= than zero"
        assert (
            isinstance(border_left, int) and border_left >= 0
        ), f"{border_left=}. Must be int >= than zero"
        assert (
            isinstance(border_bottom, int) and border_bottom >= 0
        ), f"{border_bottom=}. Must be int >= than zero"
        assert (
            isinstance(border_right, int) and border_right >= 0
        ), f"{border_right=}. Must be int >= than zero"

        # TODO Make these values configurable
        buttons_across = 1
        header_pad = 10
        button_padding = 10

        if self.dvd_setup.menu_title == "":  # Header pad is only for titles
            header_pad = 0

        # Compute the canvas size and ratio
        canvas_width = dvd_dims.display_width - (border_left + border_right)
        canvas_height = dvd_dims.display_height - (
            border_top + border_bottom + header_pad
        )
        max_button_height = canvas_height // 2

        # Create a list to store the button cells
        rows = []
        col_index = -1
        cols = []
        col_count = 0

        for row in range(num_buttons):
            col_index += 1
            cols.append(col_index)

            if col_index == buttons_across - 1 or row == num_buttons - 1:
                rows.append(cols)
                col_count = max(col_count, len(cols))
                cols = [] if row < num_buttons - 1 else cols

        num_rows = len(rows)
        num_cols = len(max(rows, key=len))

        for col in rows:
            diff = num_cols - len(col)
            left_zeros = diff // 2
            right_zeros = diff - left_zeros
            col[:0] = [-1] * left_zeros
            col.extend([-1] * right_zeros)

        rect_width_max = (
            (canvas_width // num_cols)
            - (num_cols * button_padding)
            - (border_left + border_right)
        )

        ## Compute the dimensions of each rectangle and the padding between them
        rect_width = rect_width_max
        rect_height = int(min(canvas_height / num_rows, max_button_height))
        rect_aspect_ratio = rect_width / rect_height

        if rect_aspect_ratio > button_aspect_ratio:
            rect_width = int(rect_height * button_aspect_ratio)
        else:
            rect_height = int(rect_width / button_aspect_ratio)

        # Compute the vertical padding between the rectangles
        if num_rows > 1:
            rect_padding = (canvas_height - rect_height * num_rows) / (num_rows - 1)
        else:
            rect_padding = canvas_height - rect_height * num_rows

        # We do not want the padding to be too big or small, so we max it at
        # twice the horizontal spacing between the rectangles and min it at button_padding.
        if rect_padding < button_padding or rect_padding > 2 * button_padding:
            rect_padding = 2 * button_padding

        # Center the rows in the y direction
        total_height = num_rows * rect_height + (num_rows - 1) * rect_padding
        y_offset = ((canvas_height - total_height) // 2) + border_top + header_pad

        cell_cords = []
        for row_index, row_list in enumerate(rows):
            row_col_count = len([col for col in row_list if col != -1])
            col_index = 0

            for _, col_value in enumerate(row_list):
                if col_value == -1:  # Ignore not on grid
                    continue

                total_width = (
                    row_col_count * rect_width
                    + (row_col_count - 1) * button_padding
                    + border_left
                    + border_right
                )

                x_offset = (canvas_width - total_width) // 2

                x = int(x_offset + col_index * (rect_width + button_padding))
                y = int(y_offset + row_index * (rect_height + rect_padding))

                cell_cords.append(
                    _Cell_Coords(
                        x0=x,
                        y0=y,
                        x1=x + rect_width,
                        y1=y + rect_height,
                        width=rect_width
                        - button_padding,  # Provide space between buttons
                        height=rect_height
                        - button_padding,  # Provide space between buttons
                    )
                )
                col_index += 1

        return cell_cords, ""

    def _create_canvas_image(self, width: int, height: int) -> tuple[int, str]:
        """Creates a background canvas to place the menu elements on

        Args:
            width (int): Width in pixels
            height (int ): Height in pixels

        Returns:
            tuple[int,str]
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(width, int) and width > 0, f"{width=}. Must be int > 0"
        assert isinstance(width, int) and width > 0, f"{height=}. Must be int > 0"

        pointsize = self.dvd_setup.menu_font_point_size
        font = self.dvd_setup.menu_font

        pointsize = self.dvd_setup.menu_font_point_size
        font = self.dvd_setup.menu_font
        menu_title = self.dvd_setup.menu_title

        commands = [
            sys_consts.CONVERT,
            "-size",
            f"{width}x{height}",
            f"xc:{self.dvd_setup.menu_background_color}",
            self._background_canvas_file,
        ]

        result, message = dvdarch_utils.execute_check_output(commands=commands)

        if result == -1:
            return -1, message

        if menu_title.strip() != "":
            result, message = dvdarch_utils.overlay_text(
                in_file=self._background_canvas_file,
                text=menu_title,
                text_font=self.dvd_setup.menu_font,
                text_pointsize=self.dvd_setup.menu_font_point_size,
                text_color=self.dvd_setup.menu_font_color,
                position="top",
                background_color=self.dvd_setup.menu_background_color,
                opacity=0.9,
            )

            if result == -1:
                return -1, message

        if self.dvd_setup.timestamp_font and self.dvd_setup.timestamp:
            _, timestamp_height = dvdarch_utils.get_text_dims(
                text=self.dvd_setup.timestamp,
                font=self.dvd_setup.timestamp_font,
                pointsize=self.dvd_setup.timestamp_font_point_size,
            )

            if timestamp_height == -1:
                return -1, "Failed to get timestamp height"

            result, message = dvdarch_utils.write_text_on_file(
                input_file=self._background_canvas_file,
                text=self.dvd_setup.timestamp,
                x=self._dvd_timestamp_x_offset,
                y=height - timestamp_height,
                pointsize=self.dvd_setup.timestamp_font_point_size,
                color=self.dvd_setup.menu_font_color,
                font=self.dvd_setup.timestamp_font,
            )

            if result == -1:
                return -1, message

        if self.dvd_setup.timestamp_font and self.dvd_setup.serial_number:
            serial_num_width, serial_num_height = dvdarch_utils.get_text_dims(
                text=self.dvd_setup.serial_number,
                font=self.dvd_setup.timestamp_font,
                pointsize=self.dvd_setup.timestamp_font_point_size,
            )

            if timestamp_height == -1:
                return -1, "Failed to get timestamp height"

            result, message = dvdarch_utils.write_text_on_file(
                input_file=self._background_canvas_file,
                text=self.dvd_setup.serial_number,
                x=width - serial_num_width - self._dvd_timestamp_x_offset,
                y=height - serial_num_height,
                pointsize=self.dvd_setup.timestamp_font_point_size,
                color=self.dvd_setup.menu_font_color,
                font=self.dvd_setup.timestamp_font,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _prepare_buttons(
        self, cell_coords: list[_Cell_Coords], max_cell_width: int, max_cell_height: int
    ) -> tuple[int, str]:
        """Prepares the menu buttons by creating background files with the image
        outlines placed on them for the overlay, highlight and the select state that
        are used when the DVD menu is navigated

        Creates the spumux xml file used to create the menu video file

        Args:
            cell_coords (list[_Cell_Coords]): Precalculated co-ordinates for each button
            max_cell_width (int): Maximum cell (button) width
            max_cell_height (int): Maximum cell (button) height

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        # Black choices, could be user configured if needed and stored in database
        color: str = "none"
        button_border_color = "white"
        button_border_thickness = 5
        button_highlight_color = "gold"
        button_highlight_thickness = 10
        button_select_color = "white"

        # ===== Helper functions
        def _create_transparent_file(
            width: int, height: int, out_file: str, border_color=""
        ):
            """Creates a transparent file of a given width and height.
            If a border color is provided a rectangle of that color is drawn
            around the edge of the file

            Args:
                width (int): Width of the new file
                height (int): Height of the new file
                out_file (str): The path for the new transparent file
                border_color (str, optional): The corder color of the transparent
                file. Defaults to "".

            Returns:
                tuple[int,str]:
                - arg1 1: ok, -1: fail,
                - arg2: error message or "" if ok
            """
            border_width = 10

            if border_color == "":
                command = [
                    sys_consts.CONVERT,
                    "-size",
                    f"{width}x{height}",
                    "xc:none",
                    out_file,
                ]
            else:
                command = [
                    sys_consts.CONVERT,
                    "-size",
                    f"{width}x{height}",
                    "xc:transparent",
                    "-fill",
                    "none",
                    "-stroke",
                    border_color,
                    "-strokewidth",
                    f"{border_width}",
                    "-draw",
                    f"rectangle 0,0,{width},{height}",
                    out_file,
                ]

            return dvdarch_utils.execute_check_output(commands=command)

        def _overlay_file(
            in_file: str, overlay_file: str, out_file: str, x: int, y: int
        ) -> tuple[int, str]:
            """Places the overlay_file on the input file at a given x,y co-ord
            saves the combined file to the output file

            Args:
                in_file (str): File which will have the overlay_file placed on it
                overlay_file (str): File which will be overlaid on the in_file
                out_file (str): File which will be saved as the combined file in_file and overlay_file
                x (int): x co-ord of overlay_file
                y (int): y co-ord of overlay_file

            Returns:
                tuple[int,str]:
                - arg1 1: ok, -1: fail
                - arg2: error message or "" if ok
            """
            # Image magick V6 Composite works magick V7 magick composite does not
            command = [
                # "composite",
                sys_consts.COMPOSITE,
                "-geometry",
                f"+{x}+{y}",
                overlay_file,
                in_file,
                out_file,
            ]

            return dvdarch_utils.execute_check_output(commands=command)

        # ===== Main
        file_handler = file_utils.File()
        path_name, file_name, file_extn = file_handler.split_file_path(
            self._background_canvas_file
        )

        canvas_overlay_file = file_handler.file_join(
            path_name, f"{file_name}_overlay", "png"
        )
        canvas_highlight_file = file_handler.file_join(
            path_name, f"{file_name}_highlight", "png"
        )
        canvas_select_file = file_handler.file_join(
            path_name, f"{file_name}_select", "png"
        )
        canvas_images_file = file_handler.file_join(
            path_name, f"{file_name}_images", "png"
        )

        spumux_xml = file_handler.file_join(path_name, "spumux", "xml")

        command = [
            sys_consts.CONVERT,
            self._background_canvas_file,
            canvas_images_file,
        ]

        result, message = dvdarch_utils.execute_check_output(commands=command)

        if result == -1:
            return -1, message

        canvas_width, message = dvdarch_utils.get_image_width(
            self._background_canvas_file
        )

        if canvas_width == -1:
            return -1, message

        canvas_height, message = dvdarch_utils.get_image_height(
            self._background_canvas_file
        )

        if canvas_height == -1:
            return -1, message

        result, message = _create_transparent_file(
            width=canvas_width,
            height=canvas_height,
            out_file=canvas_overlay_file,
        )
        if result == -1:
            return -1, message

        result, message = _create_transparent_file(
            width=canvas_width,
            height=canvas_height,
            out_file=canvas_highlight_file,
        )
        if result == -1:
            return -1, message

        result, message = _create_transparent_file(
            width=canvas_width,
            height=canvas_height,
            out_file=canvas_select_file,
        )

        if result == -1:
            return -1, message

        for video_index, input_video in enumerate(self.dvd_setup.input_videos):
            button_coords = cell_coords[video_index]

            path_name, file_name, file_extn = file_handler.split_file_path(
                input_video.menu_image_file_path
            )

            print(f"DBG {path_name=} {file_name=} {file_extn=}")

            button_overlay_file = file_handler.file_join(
                path_name, f"{file_name}_overlay", "png"
            )
            button_highlight_file = file_handler.file_join(
                path_name, f"{file_name}_highlight", "png"
            )
            button_select_file = file_handler.file_join(
                path_name, f"{file_name}_select", "png"
            )
            button_text_file = file_handler.file_join(
                path_name, f"{file_name}_text", file_extn
            )

            print(
                f"DBG {button_overlay_file=} {button_highlight_file=} {button_select_file=} {button_text_file=}"
            )

            width, message = dvdarch_utils.get_image_width(button_text_file)

            if width == -1:
                return -1, message

            height, message = dvdarch_utils.get_image_height(button_text_file)

            if height == -1:
                return -1, message

            x_padding = math.floor((button_coords.width - width) / 2)
            y_padding = math.floor((button_coords.height - height) / 2)

            button_x = button_coords.x0 + x_padding
            button_y = button_coords.y0 + y_padding

            # Create the 3 outline files we will need - highlight, select, overlay
            result, message = _create_transparent_file(
                width=width, height=height, out_file=button_overlay_file
            )
            if result == -1:
                return -1, message

            result, message = _create_transparent_file(
                width=width,
                height=height,
                out_file=button_highlight_file,
                border_color="gold",
            )
            if result == -1:
                return -1, message

            result, message = _create_transparent_file(
                width=width,
                height=height,
                out_file=button_select_file,
                border_color="white",
            )

            if result == -1:
                return -1, message

            # Overlay the outline files on the approiiate canvas file
            result, message = _overlay_file(
                in_file=canvas_overlay_file,
                overlay_file=button_overlay_file,
                out_file=canvas_overlay_file,
                x=button_x,
                y=button_y,
            )

            if result == -1:
                return -1, message

            result, message = _overlay_file(
                in_file=canvas_select_file,
                overlay_file=button_select_file,
                out_file=canvas_select_file,
                x=button_x,
                y=button_y,
            )
            if result == -1:
                return -1, message

            result, message = _overlay_file(
                in_file=canvas_highlight_file,
                overlay_file=button_highlight_file,
                out_file=canvas_highlight_file,
                x=button_x,
                y=button_y,
            )
            if result == -1:
                return -1, message

            # Place text file on canvas image
            result, message = _overlay_file(
                in_file=canvas_images_file,
                overlay_file=button_text_file,
                out_file=canvas_images_file,
                x=button_x,
                y=button_y,
            )
            if result == -1:
                return -1, message

        # Create the spumux xml control file
        spumux_dict = {
            "subpictures": {
                "@format": self.dvd_setup.video_standard,
                "stream": {
                    "spu": {
                        "@force": "yes",
                        "@start": "00:00:00.00",
                        "@image": canvas_highlight_file,  # canvas_overlay_file,
                        "@highlight": canvas_highlight_file,
                        "@select": canvas_select_file,
                        "@autooutline": "infer",
                        "@outlinewidth": "6",
                        "@autoorder": "rows",
                    }
                },
            }
        }

        try:
            with open(spumux_xml, "w") as result_file:
                (
                    xmltodict.unparse(
                        input_dict=spumux_dict, output=result_file, pretty=True
                    )
                )
        except IOError:
            return -1, f"Sys Error: Cound Not Write {spumux_xml}"

        return 1, ""

    def _resize_menu_button_images(self, cell_coords: list[_Cell_Coords]):
        """Resize the menu buttons to fit on the grid layout

        Args:
            cell_coords (list[_Cell_Coords]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok

        """
        for index, input_video in enumerate(self.dvd_setup.input_videos):
            result, message = dvdarch_utils.resize_image(
                input_file=input_video.menu_image_file_path,
                out_file=input_video.menu_image_file_path,
                width=cell_coords[index].width,
                height=cell_coords[index].height,
                ignore_aspect=True,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _extract_menu_images(self) -> tuple[int, str]:
        """Extracts a random video image for the menu button

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        for video_file in self.dvd_setup.input_videos:
            if "video_frame_count" not in video_file.file_info:
                return -1, f"No video frame count found for {video_file.file_info}"

            if (
                video_file.menu_image_frame == -1
            ):  # No frame number provided, pick a random frame
                menu_image_frame = randint(
                    1, video_file.file_info["video_frame_count"][1]
                )
            else:
                menu_image_frame = video_file.menu_image_frame

            if menu_image_frame > video_file.file_info["video_frame_count"][1]:
                return (
                    -1,
                    (
                        f"{menu_image_frame=} is greater than video frame count"
                        f" {video_file.file_info['video_frame_count'][1]}"
                    ),
                )

            (
                result,
                image_file,
            ) = dvdarch_utils.generate_menu_image_from_file(
                video_file=video_file.file_path,
                frame_number=menu_image_frame,
                out_folder=self._menu_image_folder,
            )

            if result == -1:
                return result, image_file
            else:
                video_file.menu_image_file_path = image_file

        return 1, ""

    def _convert_to_m2v(self, frames: int = 360) -> tuple[int, str]:
        """Converts the background_canvas_images_file into a short video stream

        Args:
            frames (int, optional): Number of video frames in stream. Defaults to 360.

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        path_name, file_name, file_extn = file_handler.split_file_path(
            self._background_canvas_file
        )

        background_canvas_images_file = file_handler.file_join(
            path_name, f"{file_name}_images", file_extn
        )
        m2v_file = file_handler.file_join(path_name, f"{file_name}_menu_video", "m2v")

        if not file_handler.file_exists(background_canvas_images_file):
            return -1, f"Sys Error : {background_canvas_images_file} does not exist!"

        if self._dvd_setup.video_standard == sys_consts.PAL:
            framerate = "25:1"
            pixel_aspect = "59:54"
            fmt = "p"
        else:  # NTSC
            framerate = "30000:1001"
            pixel_aspect = "10:11"
            fmt = "n"
        if self._dvd_setup.menu_aspect_ratio == sys_consts.AR169:
            aspect = "3"
        else:
            aspect = "2"

        result = subprocess.run(
            [sys_consts.CONVERT, background_canvas_images_file, "ppm:-"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )

        # Chained pipes here so be cognisant of that when modifying
        if result.returncode == 0:
            result = subprocess.run(
                [
                    sys_consts.PPMTOY4M,
                    "-n",
                    f"{frames}",
                    "-F",
                    f"{framerate}",
                    "-A",
                    f"{pixel_aspect}",
                    "-I",
                    "p",
                    "-r",
                    "-S",
                    "420mpeg2",
                ],
                input=result.stdout,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )

            if result.returncode == 0:
                result = subprocess.run(
                    [
                        sys_consts.MPEG2ENC,
                        "-n",
                        fmt,
                        "-f",
                        "8",
                        "-b",
                        "5000",
                        "-a",
                        aspect,
                        "-o",
                        m2v_file,
                    ],
                    input=result.stdout,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                )

            if result.returncode == 0:
                return 1, ""

        return -1, f"Sys Error: Failed To Produce Menu Video {m2v_file}"

    def _convert_audio(self, frames: int = 300):
        """Generates the audio for the menu. By default it is a empty soundtrack
        TODO Allow user selection of an audio file

        Args:
            frames (int, optional): Number of video frames - determines length of
            audio. Defaults to 300.

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        ac3_file = file_handler.file_join(path_name, f"{file_name}_menu_video", "ac3")

        if self._dvd_setup.video_standard == sys_consts.PAL:
            framerate = 25
        else:
            framerate = 30000 / 1001

        duration = math.floor(frames / framerate)

        # TODO Allow an audio file of the users choice
        # Generate an empty audio file
        commands = [
            sys_consts.FFMPG,
            "-t",
            f"{duration}",
            "-f lavfi",
            "-i anullsrc=channel_layout=5.1:sample_rate=48000",
            "-c:a ac3",
            "-b:a 224000",
            ac3_file,
        ]

        commands = [
            sys_consts.FFMPG,
            "-f",
            "lavfi",
            "-i",
            "anullsrc=channel_layout=5.1:sample_rate=48000",
            "-t",
            f"{duration}",
            "-b:a",
            "224000",
            "-c:a",
            "ac3",
            ac3_file,
        ]

        return dvdarch_utils.execute_check_output(commands=commands)

    def _multiplex_audio_video(self):
        """Multiplexes the menu m2v file and the menu ac3 file to peoduce the menu mgp file

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        ac3_file = file_handler.file_join(path_name, f"{file_name}_menu_video", "ac3")
        m2v_file = file_handler.file_join(path_name, f"{file_name}_menu_video", "m2v")
        menu_video_file = file_handler.file_join(
            path_name, f"{file_name}_menu_video", "mpg"
        )

        commands = [
            sys_consts.MPLEX,
            "-f",
            "8",
            "-o",
            menu_video_file,
            m2v_file,
            ac3_file,
        ]

        return dvdarch_utils.execute_check_output(commands=commands)

    def _create_menu_mpg(self) -> tuple[int, str]:
        """Creates the DVD menu mpg file via the dvdauthor application spumux

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        menu_video_file = file_handler.file_join(
            path_name, f"{file_name}_menu_video", "mpg"
        )
        menu_video_buttons_file = file_handler.file_join(
            path_name, f"{file_name}_menu_video_buttons", "mpg"
        )
        spumux_xml = file_handler.file_join(path_name, "spumux", "xml")

        env = {"VIDEO_FORMAT": self.dvd_setup.video_standard}

        commands = [
            sys_consts.SPUMUX,
            "-s",
            str(0),
            spumux_xml,
        ]

        result = subprocess.run(
            commands,
            env=env,
            stdin=open(menu_video_file, "rb"),
            stdout=open(menu_video_buttons_file, "wb"),
            stderr=subprocess.PIPE,
            text=True,
        )

        if result.returncode == 0:
            return 1, ""
        else:
            return -1, result.stderr.strip()

    def _create_dvd_image(self) -> tuple[int, str]:
        """Creates the DVD Folder/File structure via the dvdauthor application

        Returns:
            tuple[int, str]: _description_
        """

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        menu_video_file = file_handler.file_join(
            path_name, f"{file_name}_menu_video_buttons", "mpg"
        )
        dvd_author_file = file_handler.file_join(path_name, "dvd_author", "xml")

        # Create the DVDauthor XML control file
        video_dict = {
            "@format": self.dvd_setup.video_standard,
            "@aspect": self.dvd_setup.menu_aspect_ratio,
        }

        pgc_dict = {}
        button_list = []
        title_list = []

        for menu_index, input_video in enumerate(self.dvd_setup.input_videos):
            _, video_name, _ = file_handler.split_file_path(input_video.file_path)
            vob_file = file_handler.file_join(self._vob_folder, video_name, "vob")

            button_list.append(f"jump title {menu_index + 1};")
            title_list.append(
                {
                    "titles": {
                        "video": video_dict,
                        "pgc": {
                            "post": "call vmgm menu 1;",
                            "vob": {"@file": f"{vob_file}"},
                        },
                    }
                }
            )

        pgc_dict = {
            "button": button_list,
            "vob": {"@file": menu_video_file, "@pause": "inf"},
        }

        dvd_dict = {
            "dvdauthor": {
                "@dest": "DVD",
                "vmgm": {
                    "menus": {
                        "video": video_dict,
                        "pgc": pgc_dict,
                    }
                },
                "titleset": title_list,
            },
        }

        try:
            with open(dvd_author_file, "w") as result_file:
                (
                    xmltodict.unparse(
                        input_dict=dvd_dict, output=result_file, pretty=True
                    )
                )
        except IOError:
            return -1, f"Sys Error: Cound Not Write {dvd_author_file}"

        # Run the DVDauthor XML control file
        env = {"VIDEO_FORMAT": self.dvd_setup.video_standard}

        commands = [
            sys_consts.DVDAUTHOR,
            "-x",
            dvd_author_file,
            "-o",
            self._dvd_out_folder,
        ]

        # Had to use shell if I did not run like this
        result = subprocess.run(
            commands, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )

        if result.returncode == 0:
            iso_folder = file_handler.file_join(self._iso_out_folder, "dvd_iso")

            return dvdarch_utils.create_dvd_iso(self._dvd_out_folder, iso_folder)

        else:
            return -1, result.stderr.strip()
