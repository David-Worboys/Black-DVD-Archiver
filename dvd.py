"""
Produces a DVD folder with an autogenerated menu

Copyright (C) 2022  David Worboys (-:alumnus Moyhu Primary School et al.:-)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import dataclasses
import datetime
import inspect
import locale
import math
import subprocess
from random import randint
from typing import Final, Literal, Callable

import xmltodict

import dvdarch_utils
import QTPYGUI.file_utils as file_utils
import sys_consts
import QTPYGUI.utils as utils
from archive_management import Archive_Manager
from background_task_manager import Unpack_Result_Tuple, Task_Dispatcher
from bkp.utils import Get_Unique_Id
from break_circular import Execute_Check_Output, Task_Def
from sys_config import Video_Data

DEBUG: Final[bool] = False

# Note this is the sequence in which operations must happen
VOB_ENCODING: Final[str] = "vob_encoding"
EXTRACT_MENU_IMAGES: Final[str] = "extract_menu_images"
CREATE_DVD_MENU: Final[str] = "create_dvd_menu"
CREATE_DVD_IMAGE: Final[str] = "create_dvd_image"
ARCHIVE_DVD_FILES: Final[str] = "archive_dvd_files"


@dataclasses.dataclass
class DVD_Config:
    """Configuration for the DVD archiver"""

    _archive_folder: str = ""
    _archive_size: str = sys_consts.DVD_ARCHIVE_SIZE
    _input_videos: list[Video_Data] | tuple[Video_Data] = dataclasses.field(
        default_factory=tuple
    )
    _menu_title: list[str] | tuple[str] = dataclasses.field(default_factory=tuple)
    _menu_background_color: str = "wheat"
    _menu_font_color: str = "gold"
    _menu_font_point_size: int = 24
    _menu_font: str = ""
    _button_background_color: str = "darkgray"
    _button_background_transparency: float = 0.8
    _button_font_color: str = "white"
    _button_font_point_size: int = 12
    _button_font: str = ""
    _disk_title: str = ""
    _menu_aspect_ratio: str = sys_consts.AR43  #
    _menu_buttons_across: int = 2
    _menu_buttons_per_page: int = 4
    _page_pointer_left_file: str = ""
    _page_pointer_right_file: str = ""
    _project_name: str = ""
    _serial_number: str = ""
    _streaming_folder: str = ""
    _timestamp_font: str = ""
    _timestamp_font_point_size: int = 11
    _timestamp_prefix: str = "DVD Build Date:"
    _timestamp: str = ""
    _transcode_type: str = sys_consts.TRANSCODE_NONE
    _video_standard: str = sys_consts.PAL

    def __post_init__(self):
        """
        Set the defaults
        """
        # Set the default values
        if self.menu_background_color.strip() == "":
            self.menu_background_color = "wheat"

        # Get the current locale settings and store them
        current_locale = locale.getlocale(locale.LC_TIME)

        # Set the locale to the user's default locale
        locale.setlocale(locale.LC_TIME, "")

        # Format the timestamp using the user's default locale
        self.timestamp = (
            f"{self.timestamp_prefix} {datetime.datetime.now().strftime('%x %H:%M')}"
        )

        # Restore the previous locale settings
        locale.setlocale(locale.LC_TIME, current_locale)

    @property
    def archive_folder(self) -> str:
        """
            Gets the archive folder
        Returns:
            str: The archive folder
        """
        return self._archive_folder

    @archive_folder.setter
    def archive_folder(self, value: str):
        """
            Sets the archive folder
        Args:
            value (str): The path to the archive folder
        """
        assert isinstance(value, str), f"{value=}. Must be str"

        self._archive_folder = value

    @property
    def archive_size(self) -> str:
        """
            Gets the archive size
        Returns:
            str: The archive size ( BLUERAY_ARCHIVE_SIZE | DVD_ARCHIVE_SIZE )
        """
        return self._archive_size

    @archive_size.setter
    def archive_size(self, value: str):
        """
            Sets the archive size
        Args:
            value (str): The archive size ( BLUERAY_ARCHIVE_SIZE | DVD_ARCHIVE_SIZE )
        """
        assert isinstance(value, str) and value in (
            sys_consts.BLUERAY_ARCHIVE_SIZE,
            sys_consts.DVD_ARCHIVE_SIZE,
        ), f"{value=}, Must be BLUERAY_ARCHIVE_SIZE | DVD_ARCHIVE_SIZE"
        self._archive_size = value

    @property
    def input_videos(self) -> list[Video_Data] | tuple[Video_Data]:
        """
            Gets the input videos
        Returns:
            list[Video_Data] | tuple[Video_Data]: The input videos
        """
        return self._input_videos

    @input_videos.setter
    def input_videos(self, value: list[Video_Data] | tuple[Video_Data]) -> None:
        """
            Sets the input videos
        Args:
            value (list[Video_Data] | tuple[Video_Data]): The input videos
        """
        assert isinstance(value, (list, tuple)), (
            f"{value=}. Must be a list | tuple of Video_Data"
        )

        for video_file in value:
            assert isinstance(video_file, Video_Data), (
                f"{video_file=}. Must be a File_Def"
            )

            assert file_utils.File().path_exists(video_file.video_folder), (
                f"{video_file.video_folder=}. Must be a valid file folder"
            )

        self._input_videos = value

    @property
    def menu_background_color(self) -> str:
        """
            Gets the menu background color
        Returns:
            str: The menu background color
        """
        return self._menu_background_color

    @menu_background_color.setter
    def menu_background_color(self, value: str) -> None:
        """
            Sets the menu background color
        Args:
            value (str): The menu background color
        """
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._menu_background_color = value

    @property
    def menu_title(self) -> list[str] | tuple[str]:
        """
            Gets the menu title
        Returns:
            list[str] | tuple[str]: The menu title
        """
        return self._menu_title

    @menu_title.setter
    def menu_title(self, value: list[str] | tuple[str]) -> None:
        """
            Sets the menu title
        Args:
            value (list[str] | tuple[str]): The menu title
        """
        assert isinstance(value, (list, tuple)), f"{value=}. Must be a list | tuple str"
        assert all(isinstance(title, str) for title in value), (
            f"{value=} must be list | tuple of str"
        )

        self._menu_title = value

    @property
    def menu_aspect_ratio(self) -> str:
        """
            Gets the menu aspect ratio
        Returns:
            str: The menu aspect ratio (AR169 | AR43)
        """
        return self._menu_aspect_ratio

    @menu_aspect_ratio.setter
    def menu_aspect_ratio(self, value: str) -> None:
        """
            Sets the menu aspect ratio
        Args:
            value (str): The menu aspect ratio (AR169 | AR43)
        """
        assert isinstance(value, str), f"{value=}. Must be a string"
        assert value.upper() in (
            sys_consts.AR169,
            sys_consts.AR43,
        ), f"{value=}. Must be AR169 | AR43"

        self._menu_aspect_ratio = value.upper()

    @property
    def menu_font(self) -> str:
        """
            Gets the menu font
        Returns:
            str: The menu font
        """
        return self._menu_font

    @menu_font.setter
    def menu_font(self, value: str) -> None:
        """
            Sets the menu font
        Args:
            value (str): The menu font

        Returns:

        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        file_handler = file_utils.File()

        if file_handler.file_exists(value):
            self._menu_font = value

            return
        else:  # Try to find a default system font
            for font in dvdarch_utils.Get_Fonts():
                if font[0] == value:
                    self._menu_font = font[1]

                    return

        # Try to use the supplied app font if we can't find a default font
        if file_handler.file_exists(
            file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )
        ):
            self._menu_font = file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )

            return

        # At this point, something is really wrong
        raise RuntimeError(f"{value=}. Menu Font not found")

    @property
    def page_pointer_left_file(self) -> str:
        """
        Returns the left page pointer file

        Args:

        Returns:
            str: The left page pointer file
        """

        return self._page_pointer_left_file

    @page_pointer_left_file.setter
    def page_pointer_left_file(self, value: str) -> None:
        """
        Sets the left page pointer file.

        Args:
            value (str): The left page pointer file
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be non-empty str"
        )

        self._page_pointer_left_file = value

    @property
    def page_pointer_right_file(self) -> str:
        """
        Returns the right page pointer file

        Args:

        Returns:
            str: The right page pointer file

        """
        return self._page_pointer_right_file

    @page_pointer_right_file.setter
    def page_pointer_right_file(self, value: str) -> None:
        """
        Sets the right page pointer file.

        Args:
            value (str): The right page pointer file
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be non-empty str"
        )

        self._page_pointer_right_file = value

    @property
    def button_background_color(self) -> str:
        """
        Returns the button background color

        Returns:
            str: The button background color

        """
        return self._button_background_color

    @button_background_color.setter
    def button_background_color(self, value: str):
        """
        Sets the button background color

        Args:
            value (str): The button background color

        """
        assert isinstance(value, str), "Button background color must be a string."
        self._button_background_color = value

    @property
    def button_background_transparency(self) -> float:
        """
        Returns the button background transparency

        Returns:
            float: The button background transparency

        """
        return self._button_background_transparency

    @button_background_transparency.setter
    def button_background_transparency(self, value: float):
        """
            Sets the button background transparency
        Args:
            value (float): The button background transparency <= 1.0
        """
        assert isinstance(value, float) and 0 <= value <= 1, (
            f"{value=}.  0 <= Must be float <= 1"
        )

        self._button_background_transparency = value

    @property
    def button_font_color(self) -> str:
        """
        Returns the button font color

        Returns:
            str: The button font color

        """
        return self._button_font_color

    @button_font_color.setter
    def button_font_color(self, value: str):
        """
        Sets the button font color

        Args:
            value (str): The button font color

        """
        assert isinstance(value, str), "Button font color must be a string."
        self._button_font_color = value

    @property
    def button_font_point_size(self) -> int:
        """
            Returns the button font point size
        Returns:
            int: The button font point size
        """
        return self._button_font_point_size

    @button_font_point_size.setter
    def button_font_point_size(self, value: int):
        """
            Sets the button font point size
        Args:
            value (int): The button font point size
        """
        assert isinstance(value, int), "Button font point size must be an integer."
        self._button_font_point_size = value

    @property
    def button_font(self) -> str:
        """
            Returns the button font
        Returns:
            str: The button font
        """
        return self._button_font

    @button_font.setter
    def button_font(self, value: str):
        """
            Sets the button font
        Args:
            value (str): The button font
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )
        file_handler = file_utils.File()

        if file_handler.file_exists(value):
            self._button_font = value

            return

        else:
            for font in dvdarch_utils.Get_Fonts():
                if font[0] == value:
                    self._button_font = font[1]
                    return

        if file_handler.file_exists(
            file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )
        ):
            self._menu_font = file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )

            return

        # At this point something is really wrong
        raise RuntimeError(f"{value=}. Button Font not found")

    @property
    def menu_font_color(self) -> str:
        """
            Returns the menu font color
        Returns:
            str: The menu font color
        """
        return self._menu_font_color

    @property
    def disk_title(self) -> str:
        return self._disk_title

    @disk_title.setter
    def disk_title(self, disk_title: str):
        assert isinstance(disk_title, str) and disk_title.strip() != "", (
            f"{disk_title=}. Must be a non-empty str"
        )

        self._disk_title = disk_title

    @menu_font_color.setter
    def menu_font_color(self, value: str) -> None:
        """
            Sets the menu font color
        Args:
            value (str): The menu font color
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._menu_font_color = value

    @property
    def menu_font_point_size(self) -> int:
        """
            Returns the menu font point size
        Returns:
            int: The menu font point size
        """
        return self._menu_font_point_size

    @menu_font_point_size.setter
    def menu_font_point_size(self, value: int) -> None:
        """
            Sets the menu font point size
        Args:
            value (int): The menu font point size
        """
        assert isinstance(value, int) and value > 1, f"{value=}. Must be an int > 1"

        self._menu_font_point_size = value

    @property
    def menu_buttons_across(self) -> int:
        """
            Returns the menu buttons across
        Returns:
            int: The menu buttons across
        """
        return self._menu_buttons_across

    @menu_buttons_across.setter
    def menu_buttons_across(self, value: int) -> None:
        """
            Sets the menu buttons across
        Args:
            value (int): The menu buttons across
        """
        assert isinstance(value, int) and value > 0, f"{value=}. Must be an int > 0"

        self._menu_buttons_across = value

    @property
    def menu_buttons_per_page(self) -> int:
        """
            Returns the menu buttons per page
        Returns:
            int: The menu buttons per page
        """
        return self._menu_buttons_per_page

    @menu_buttons_per_page.setter
    def menu_buttons_per_page(self, value: int) -> None:
        """
            Sets the menu buttons per page
        Args:
            value (int): The menu buttons per page
        """
        assert isinstance(value, int) and value > 0, f"{value=}. Must be an int > 0"

        self._menu_buttons_per_page = value

    @property
    def project_name(self) -> str:
        """
            Returns the project name
        Returns:
            str: The project name
        """
        return self._project_name

    @project_name.setter
    def project_name(self, value: str) -> None:
        """
            Sets the project name
        Args:
            value (str): The project name
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non_empty str"
        )
        self._project_name = value

    @property
    def serial_number(self) -> str:
        """
            Returns the serial number
        Returns:
            str: The serial number
        """
        return self._serial_number

    @serial_number.setter
    def serial_number(self, value: str) -> None:
        """
            Sets the serial number
        Args:
            value (str): The serial number
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._serial_number = value

    @property
    def streaming_folder(self) -> str:
        """
            Returns the streaming folder
        Returns:
            str: The streaming folder
        """
        return self._streaming_folder

    @streaming_folder.setter
    def streaming_folder(self, value: str):
        """
            Sets the streaming folder
        Args:
            value (str): The streaming folder
        """
        assert isinstance(value, str), f"{value=}. Must be str"

        self._streaming_folder = value

    @property
    def timestamp_font(self) -> str:
        """
            Returns the timestamp font
        Returns:
            str: The timestamp font
        """
        return self._timestamp_font

    @timestamp_font.setter
    def timestamp_font(self, value: str) -> None:
        """
            Sets the timestamp font
        Args:
            value (str): The timestamp font
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        file_handler = file_utils.File()

        if file_handler.path_exists(value):
            self._timestamp_font = value

            return

        else:
            for font in dvdarch_utils.Get_Fonts():
                if font[0] == value:
                    self._timestamp_font = font[1]

                    return

        if file_handler.file_exists(
            file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )
        ):
            self._menu_font = file_utils.App_Path(
                f"IBM-Plex-Mono{file_handler.ossep}{sys_consts.DEFAULT_FONT}"
            )

            return

        # At this point, something is really wrong
        raise RuntimeError(f"{value=}. Timestamp Font not found")

    @property
    def timestamp_font_point_size(self) -> int:
        """
            Returns the timestamp font point size
        Returns:
            int: The timestamp font point size
        """
        return self._timestamp_font_point_size

    @timestamp_font_point_size.setter
    def timestamp_font_point_size(self, value: int) -> None:
        """
            Sets the timestamp font point size
        Args:
            value (int): The timestamp font point size
        """
        assert isinstance(value, int) and value > 1, f"{value=}. Must be an int > 1"

        self._timestamp_font_point_size = value

    @property
    def timestamp_prefix(self) -> str:
        """
            Returns the timestamp prefix
        Returns:
            str: The timestamp prefix
        """
        return self._timestamp_prefix

    @timestamp_prefix.setter
    def timestamp_prefix(self, value: str) -> None:
        """
            Sets the timestamp prefix
        Args:
            value (str): The timestamp prefix
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._timestamp_prefix = value

    @property
    def timestamp(self) -> str:
        """
            Returns the timestamp
        Returns:
            str: The timestamp
        """
        return self._timestamp

    @timestamp.setter
    def timestamp(self, value: str) -> None:
        """
            Sets the timestamp
        Args:
            value (str): The timestamp
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._timestamp = value

    @property
    def transcode_type(self) -> str:
        """
            Returns the transcode type
        Returns:
            str: The transcode type (sys_consts.TRANSCODE_NONE | TRANSCODE_FFV1ARCHIVAL | TRANSCODE_H264 | TRANSCODE_H265)
        """
        return self._transcode_type

    @transcode_type.setter
    def transcode_type(self, value: str):
        """
            Sets the transcode type
        Args:
            value (str): The transcode type (sys_consts.TRANSCODE_NONE | TRANSCODE_FFV1ARCHIVAL | TRANSCODE_H264 | TRANSCODE_H265)
        """
        assert isinstance(value, str) and value in (
            sys_consts.TRANSCODE_NONE,
            sys_consts.TRANSCODE_FFV1ARCHIVAL,
            sys_consts.TRANSCODE_H264,
            sys_consts.TRANSCODE_H265,
        ), (
            f"{value=}, Must be Be TRANSCODE_NONE | sys_consts.TRANSCODE_FFV1ARCHIVAL |"
            " TRANSCODE_H264 | TRANSCODE_H265"
        )
        self._transcode_type = value

    @property
    def video_standard(self):
        """
            Returns the video standard
        Returns:
            str: The video standard
        """
        return self._video_standard

    @video_standard.setter
    def video_standard(self, value: str) -> None:
        """
            Sets the video standard
        Args:
            value (str): The video standard (sys_consts.PAL | sys_consts.NTSC)
        """
        assert isinstance(value, str), f"{value=}. Must be a string"

        self._video_standard = value.upper()

        assert value in (
            sys_consts.PAL,
            sys_consts.NTSC,
        ), f"{value=}. Must be NTSC or PAL"


@dataclasses.dataclass(slots=True)
class _Cell_Coord:
    name: str = ""
    x0: int = 0
    y0: int = 0
    x1: int = 0
    y1: int = 0
    width: int = 0
    height: int = 0
    page: int = 0
    video_data: Video_Data | None = dataclasses.field(default_factory=Video_Data)
    cargo: dict = dataclasses.field(default_factory=dict)

    def __post_init__(self):
        assert isinstance(self.name, str), f"{self.name=}. Must be str"
        assert isinstance(self.x0, int) and self.x0 >= 0, (
            f"{self.x0=}. Must be int >= 0"
        )
        assert isinstance(self.y0, int) and self.y0 >= 0, (
            f"{self.y0=}. Must be int >= 0"
        )
        assert isinstance(self.x1, int) and self.x1 >= 0, (
            f"{self.x1=}. Must be int >= 0"
        )
        assert isinstance(self.y1, int) and self.y1 >= 0, (
            f"{self.y1=}. Must be int >= 0"
        )
        assert isinstance(self.width, int) and self.width >= 0, (
            f"{self.width=}. Must be int >=0"
        )
        assert isinstance(self.height, int) and self.height >= 0, (
            f"{self.height=}. Must be int >= 0"
        )
        assert isinstance(self.page, int) and self.page >= 0, (
            f"{self.page=}. Must be int >= 0"
        )
        assert isinstance(self.video_data, Video_Data) or self.video_data is None, (
            f"{self.video_data=}. Must be Video_Data Or None"
        )
        assert isinstance(self.cargo, dict), f"{self.cargo=}. Must be dict"

    def get_mask_filenames(self, alternate_file_path: str = "") -> tuple[str, ...]:
        """Generate the file names for overlay, highlight, select, and text masks.

        Args:
            alternate_file_path (str) : If provided, use this file path instead of the
                video_file.menu_image_file_path.

        Returns:
            A tuple of four strings representing the file names of the following:
            - overlay_file: A PNG file containing the overlay mask.
            - highlight_file: A PNG file containing the highlight mask.
            - select_file: A PNG file containing the select mask.
            - text_file: A file containing the text (with extension specified by file_extn).
        """
        file_handler = file_utils.File()

        if alternate_file_path:
            path_name, file_name, file_extn = file_handler.split_file_path(
                alternate_file_path
            )
        else:
            if self.video_data is None:
                return "", "", "", ""

            path_name, file_name, file_extn = file_handler.split_file_path(
                self.video_data.menu_image_file_path
            )

        suffixes = ["_overlay", "_highlight", "_select", "_text"]
        filenames = []

        for suffix in suffixes:
            if suffix == "_text":
                filename = (
                    file_handler.file_join(
                        path_name, f"{file_name}{suffix}_{self.page}", file_extn
                    )
                    if file_extn
                    else ""
                )
            else:
                filename = file_handler.file_join(
                    path_name, f"{file_name}{suffix}_{self.page}", "png"
                )
            filenames.append(filename)

        return tuple(filenames)


# ===== Public Class
@dataclasses.dataclass(slots=True)
class DVD:
    """Does the grunt work needed to automatically turn video files into a
    DVD Folder/File structure with an auto generated menu"""

    _BACKGROUND_CANVAS_FILE: Final[str] = "background_canvas.png"

    # Defaults to 43 pixels. Takes only 2 possible pixel unit values - 33 (AR169) and 43 (AR43). spumux is very sensitive
    # to this setting
    _SPUMUX_BUFFER: Literal[33, 43] = 43

    _component_event_handler: Callable = None
    _dvd_config: DVD_Config = dataclasses.field(default_factory=DVD_Config)
    _dvd_timestamp_x_offset: int = 10  # TODO Make user configurable
    _session_id: str = ""

    # folders
    _working_folder: str = ""
    _dvd_working_folder: str = ""
    _dvd_out_folder: str = ""
    _iso_out_folder: str = ""
    _menu_image_folder: str = ""
    _tmp_folder: str = ""
    _vob_folder: str = ""

    _error_messages: list = dataclasses.field(default_factory=list)
    _errored: bool = False
    _error_code: int = 1
    _error_message: str = ""
    _encode_video_complete: bool = False
    _extract_menu_images_complete: bool = False
    _create_dvd_menu_complete: bool = False
    _create_dvd_image_complete: bool = False
    _archive_complete: bool = False
    _final_report_triggered: bool = False

    # file names
    _background_canvas_file: str = ""

    def __post_init__(self) -> None:
        self._session_id: str = Get_Unique_Id()

    @dataclasses.dataclass(slots=True)
    class _Menu_Pointer_Data:
        """Dataclass to hold data for the menu pointer icon"""

        # public
        background_canvas_file: str
        dvd_config: DVD_Config
        spumux_buffer: int

        # private
        _width: int = -1
        _height: int = -1
        _left_icon_path: str = ""
        _left_x_offset: int = -1
        _left_y_offset: int = -1
        _right_icon_path: str = ""
        _right_x_offset: int = -1
        _right_y_offset: int = -1
        _error_code: int = 1
        _error_message: str = ""

        def __post_init__(self):
            """Initialize the class"""
            assert (
                isinstance(self.background_canvas_file, str)
                and self.background_canvas_file.strip() != ""
            ), f"{self.background_canvas_file=}. Must be a str"
            assert isinstance(self.dvd_config, DVD_Config), (
                f"{self.dvd_config=}. Must be a DVD_Config"
            )
            assert isinstance(self.spumux_buffer, int) and self.spumux_buffer > 0, (
                f"{self.spumux_buffer=}. Must be an int > 0"
            )

            file_handler = file_utils.File()

            # TODO Make sys_consts.ICON_PATH user configurable
            page_pointer_left_file = file_handler.file_join(
                sys_consts.ICON_PATH, self.dvd_config.page_pointer_left_file
            )
            page_pointer_right_file = file_handler.file_join(
                sys_consts.ICON_PATH, self.dvd_config.page_pointer_right_file
            )

            _, left_file, left_extn = file_handler.split_file_path(
                page_pointer_left_file
            )
            _, right_file, _ = file_handler.split_file_path(page_pointer_right_file)

            right_pointer_file = right_file
            left_pointer_file = left_file
            pointer_file_extn = left_extn

            self.left_icon_path = file_handler.file_join(
                sys_consts.ICON_PATH,
                left_pointer_file,
                pointer_file_extn,
            )

            self.right_icon_path = file_handler.file_join(
                sys_consts.ICON_PATH,
                right_pointer_file,
                pointer_file_extn,
            )

            self.width, self.height, message = dvdarch_utils.Get_Image_Size(
                self.left_icon_path
            )  # Assume left and right are the same size

            if self.width == -1 and self.height == -1:
                self.error_code = -1
                self.error_message = message

            canvas_width, canvas_height, message = dvdarch_utils.Get_Image_Size(
                self.background_canvas_file
            )

            if canvas_width == -1 and canvas_height == -1:
                self.error_code = -1
                self.error_message = message

            self.left_x_offset = self.spumux_buffer
            self.left_y_offset = canvas_height - (self.height + self.spumux_buffer)
            self.right_x_offset = canvas_width - (self.width + self.spumux_buffer)
            self.right_y_offset = canvas_height - (self.height + self.spumux_buffer)

        @property
        def error_code(self) -> int:
            """
                Gets the error code
            Returns:
                int: The error code
            """
            return self._error_code

        @error_code.setter
        def error_code(self, value: int):
            """
                Sets the error code
            Args:
                value(int): The error code

            Returns:

            """
            assert isinstance(value, int) and value in (-1, 0), (
                f"{value=} must be -1 or 0"
            )

            self._error_code = value

        @property
        def error_message(self) -> str:
            """
                Gets the error message
            Returns:
                str: The error message
            """
            return self._error_message

        @error_message.setter
        def error_message(self, value: str):
            """
                Sets the error message
            Args:
                value(str): The error message

            Returns:

            """
            assert isinstance(value, str), f"{value=} must be str"

            self._error_message = value

        @property
        def width(self) -> int:
            """
                Gets the width of the pointer icon
            Returns:
                int: The width of the pointer icon
            """
            return self._width

        @width.setter
        def width(self, value: int):
            """
                Sets the width of the pointer icon
            Args:
                value(int): The width of the pointer icon

            Returns:

            """
            assert isinstance(value, int) and value > 0, f"{value=} must  > 0"

            self._width = value

        @property
        def height(self) -> int:
            """
                Gets the height of the pointer icon
            Returns:
                int: The height of the pointer icon
            """
            return self._height

        @height.setter
        def height(self, value: int):
            """
                Sets the height of the pointer icon
            Args:
                value(int): The height of the pointer icon

            Returns:

            """
            assert isinstance(value, int) and value > 0, f"{value=} must  > 0"

            self._height = value

        @property
        def left_icon_path(self) -> str:
            """
                Gets the path of the left pointer icon.

            Returns:
                str: The path of the left pointer icon

            """
            return self._left_icon_path

        @left_icon_path.setter
        def left_icon_path(self, value: str):
            """
                Sets the path of the left pointer icon.
            Args:
                value(str): The path of the left pointer icon

            Returns:

            """
            assert isinstance(value, str) and value.strip() != "", (
                f"{value=} must be a non-empty str"
            )

            self._left_icon_path = value

        @property
        def left_x_offset(self) -> int:
            """
                Gets the x offset of the left pointer.

            Returns:
                int: The x offset of the left pointer

            """
            return self._left_x_offset

        @left_x_offset.setter
        def left_x_offset(self, value: int):
            """
                Sets the x offset of the left pointer.

            Args:
                value(int): The x offset of the left pointer

            Returns:

            """
            assert isinstance(value, int) and value > 0, f"{value=} must be > 0"

            self._left_x_offset = value

        @property
        def left_y_offset(self) -> int:
            """
                Gets the y offset of the left pointer.

            Returns:
                int: The y offset of the left pointer

            """
            return self._left_y_offset

        @left_y_offset.setter
        def left_y_offset(self, value: int):
            """
            Sets the y offset of the left pointer.

            Args:
                value(int): The y offset of the left pointer

            Returns:

            """
            assert isinstance(value, int) and value > 0, f"{value=} must be > 0"

            self._left_y_offset = value

        @property
        def right_icon_path(self) -> str:
            """
                Gets the path of the right pointer icon.

            Returns:
                str: The path of the right pointer icon
            """
            return self._right_icon_path

        @right_icon_path.setter
        def right_icon_path(self, value: str):
            """

            Sets the path of the right pointer icon.
            Args:
                value (str): The path of the right pointer icon

            Returns:

            """
            assert isinstance(value, str) and value.strip() != "", (
                f"{value=} must be a non-empty str"
            )

            self._right_icon_path = value

        @property
        def right_x_offset(self) -> int:
            """
                Gets the x offset of the right pointer.

            Returns:
                int: The x offset of the right pointer

            """
            return self._right_x_offset

        @right_x_offset.setter
        def right_x_offset(self, value: int):
            """
            Sets the x offset of the right pointer.

            Args:
                value (int): The x offset of the right pointer

            Returns:
                int: The x offset of the right pointer.

            """
            assert isinstance(value, int) and value > 0, f"{value=} must be > 0"

            self._right_x_offset = value

        @property
        def right_y_offset(self) -> int:
            """
            Gets the y offset of the right pointer.

            Returns:
                int: The y offset of the right pointer.

            """
            return self._right_y_offset

        @right_y_offset.setter
        def right_y_offset(self, value: int):
            """
            Sets the y offset of the right pointer.

            Args:
                value (int): The y offset of the right pointer
            """

            assert isinstance(value, int) and value > 0, f"{value=} must be > 0"

            self._right_y_offset = value

    @property
    def component_event_handler(self) -> Callable:
        """Returns the component_event_handler method

        Returns:
            Callable: The component_event_handler method
        """
        return self._component_event_handler

    @component_event_handler.setter
    def component_event_handler(self, value: Callable) -> None:
        """Sets the component_event_handler method

        Args:
            value (qtg.Label): The system notifications label
        """
        assert isinstance(value, Callable), f"{value=}. Must be an instance of Callable"

        signature = inspect.signature(value)
        parameters = list(signature.parameters.values())

        # Check number of arguments
        assert len(parameters) == 2, f"{value=}. Must have 2 parameters"

        arg_1 = parameters[0]
        arg_2 = parameters[1]

        assert (
            arg_1.annotation is not inspect.Parameter.empty and arg_1.annotation is int
        ), (
            f"First argument '{arg_1.name}' must be annotated as 'int'. Found: {arg_1.annotation}"
        )

        assert (
            arg_2.annotation is not inspect.Parameter.empty and arg_2.annotation is str
        ), (
            f"Second argument '{arg_2.name}' must be annotated as 'str'. Found: {arg_2.annotation}"
        )

        self._component_event_handler = value

    @property
    def dvd_config(self) -> DVD_Config:
        """
            Gets the DVD configuration.

        Returns:
            DVD_Config: The DVD configuration
        """
        return self._dvd_config

    @dvd_config.setter
    def dvd_config(self, value: DVD_Config) -> None:
        """
            Sets the DVD configuration

        Args:
            value (DVD_Config):

        Returns:

        """
        assert isinstance(value, DVD_Config), f"{value=}. Must be a DVD_Setup"

        self._dvd_config = value
        if self.dvd_config.menu_aspect_ratio == sys_consts.AR43:
            self._SPUMUX_BUFFER = (
                43  # pixel unit, spumux is very sensitive to this setting
            )
        else:  # sys_consts.AR169
            self._SPUMUX_BUFFER = (
                33  # pixel unit, spumux is very sensitive to this setting
            )

    @property
    def dvd_working_folder(self) -> str:
        """
            Gets the DVD working folder.

        Returns:
            str: The DVD working folder.
        """
        return self._dvd_working_folder

    @property
    def working_folder(self) -> str:
        """
            Gets the working folder.

        Returns:
            str: The working folder.
        """
        return self._working_folder

    @working_folder.setter
    def working_folder(self, value: str) -> None:
        """
            Sets the working folder.

        Args:
            value (str): The working folder.
        """
        assert isinstance(value, str) and value.strip() != "", (
            f"{value=}. Must be a non-empty string"
        )

        self._working_folder = value

    @property
    def dvd_image_folder(self) -> str:
        """
            Gets the DVD image folder.

        Returns:
            str: The DVD image folder.
        """
        return self._dvd_out_folder

    @property
    def iso_folder(self) -> str:
        """
            Gets the ISO folder.

        Returns:
            str: The ISO folder.
        """
        return self._iso_out_folder

    def build(self) -> tuple[int, str]:
        """Builds the  DVD Folder/File structure

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert len(self.dvd_config.input_videos) > 0, (
            "Must have at least one input video"
        )

        if DEBUG:
            print(f"Building DVD {self._session_id=}")

        self._reset_new_state()

        error_no, error_message = self._build_working_folders()

        if error_no == -1:
            return error_no, error_message

        dvd_dims = dvdarch_utils.Get_DVD_Dims(
            self.dvd_config.menu_aspect_ratio, self.dvd_config.video_standard
        )

        if dvd_dims.display_height == -1:
            return -1, "Failed To Get DVD Dimensions"

        result, message = self._create_canvas_image(
            width=dvd_dims.storage_width, height=dvd_dims.storage_height
        )

        if result == -1:
            return -1, message

        self._build_sequence(VOB_ENCODING)

        return 1, ""

    def _build_sequence(self, build_action: str) -> None:
        """
        Controls the sequencing of the DVD/Archiving operations. This sequencing is important as most operations depend on
        external files produced by prior operations - this limits the amount of parallel processing that can be done.

        Note: If then else order must not be changed due to external file dependencies

        Args:
            build_action (str):  The build operation that needs to be performed. Must be one of VOB_ENCODING,
                                EXTRACT_MENU_IMAGES, CREATE_DVD_MENU, CREATE_DVD_IMAGE, ARCHIVE_DVD_FILES

        Returns:
            None

        """

        #### Helper
        def _start_menu_images_task(task_def: Task_Def) -> None:
            """
            Handles the menu image start task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """
            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD SMIT Started {task_def.task_id=}")

            if self.component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT, "Generating DVD Menu Images"
                )

            return None

        def _finish_menu_images_task(task_def: Task_Def) -> None:
            """
            Handles the menu image finish task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """
            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD FMIT Started {task_def.task_id=}")

            if self.component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT, "Finished Generating DVD Menu Images"
                )

            task_error_no, task_message, worker_error_no, worker_message = (
                Unpack_Result_Tuple(task_def)
            )

            if (
                task_error_no == 1
                and worker_error_no == 1
                and task_message.lower() == "all done"
            ):
                self._create_dvd_menu_complete = True

                if DEBUG:
                    print(f"DBG DVD FMIT: (prefix '{CREATE_DVD_MENU}') is complete.")

                self._build_sequence(CREATE_DVD_MENU)

            elif task_error_no != 1 or worker_error_no != 1:
                self._error_messages.append(
                    f"task {task_def.task_id} reported an error: TaskError={task_error_no}, "
                    f"WorkerError={worker_error_no}, Message='{task_message}'"
                )

                self._errored = True

            self._check_all_groups_completed()

            return None

        def _start_dvd_menu_task(task_def: Task_Def) -> None:
            """
            Handles the DVD menu generation start task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """
            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD SDMT Started {task_def.task_id=}")

            if self.component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT, "Started Generating DVD Menu"
                )

            return None

        def _finish_dvd_menu_task(task_def: Task_Def) -> None:
            """
            Handles the DVD menu generation finish task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """

            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD FDNT Started {task_def.task_id=}")

            if self.component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT, "Finished Generating DVD Menu"
                )

            task_error_no, task_message, worker_error_no, worker_message = (
                Unpack_Result_Tuple(task_def)
            )

            if (
                task_error_no == 1
                and worker_error_no == 1
                and task_message.lower() == "all done"
            ):
                self._create_dvd_menu_complete = True

                if DEBUG:
                    print(f"DBG DVD FCDNT: (prefix '{CREATE_DVD_MENU}') is complete.")

                self._build_sequence(CREATE_DVD_IMAGE)

            elif task_error_no != 1 or worker_error_no != 1:
                self._error_messages.append(
                    f"Task {task_def.task_id} reported an error: TaskError={task_error_no}, "
                    f"WorkerError={worker_error_no}, Message='{task_message}'"
                )

                self._errored = True

            self._check_all_groups_completed()

            return None

        def _start_dvd_image_task(task_def: Task_Def) -> None:
            """
            Handles the DVD image (iso) start generation task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                Nome

            """

            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD SDIT Started {task_def.task_id=}")

            if self.component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT, "Started Building A DVD ISO"
                )

            return None

        def _finish_dvd_image_task(task_def: Task_Def) -> None:
            """
            Handles the DVD image (iso) finish generation task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """
            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD FDIT Started {task_def.task_id=}")

            if self.component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT, "Finished Generating A DVD ISO"
                )

            task_error_no, task_message, worker_error_no, worker_message = (
                Unpack_Result_Tuple(task_def)
            )

            if (
                task_error_no == 1
                and worker_error_no == 1
                and task_message.lower() == "all done"
            ):
                self._create_dvd_image_complete = True

                if DEBUG:
                    print(f"DBG DVD FDDIT: (prefix '{CREATE_DVD_IMAGE}') is complete.")

                self._build_sequence(ARCHIVE_DVD_FILES)

            elif task_error_no != 1 or worker_error_no != 1:
                self._error_messages.append(
                    f"Task {task_def.task_id} reported an error: TaskError={task_error_no}, "
                    f"WorkerError={worker_error_no}, Message='{task_message}'"
                )

                self._errored = True

            self._check_all_groups_completed()

            return None

        def _start_archive_task(task_def: Task_Def) -> None:
            """
            Handles the Archive start generation task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:

            """

            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD SARHT Started {task_def.task_id=}")

            if self.component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT, "Started Archiving Task"
                )

            return None

        def _finish_archive_task(task_def: Task_Def) -> None:
            """
            Handles the Archive finish generation task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:

            """
            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD Fin Arch Tsk Started {task_def.task_id=}")

            if self.component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT, "Finished Archiving Task"
                )

            task_error_no, task_message, worker_error_no, worker_message = (
                Unpack_Result_Tuple(task_def)
            )

            if (
                task_error_no == 1
                and worker_error_no == 1
                and task_message.lower() == "all done"
            ):
                self._archive_complete = True

                if DEBUG:
                    print(
                        f"DBG DVD Fin Arch Tsk: (prefix '{ARCHIVE_DVD_FILES}') is complete."
                    )

            elif task_error_no != 1 or worker_error_no != 1:
                self._error_messages.append(
                    f"Task {task_def.task_id} reported an error: TaskError={task_error_no}, "
                    f"WorkerError={worker_error_no}, Message='{task_message}'"
                )

                self._errored = True

            self._check_all_groups_completed()

            return None

        def _error_task(task_def: Task_Def) -> None:
            """
            Handles the Error task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:

            """

            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )
            if DEBUG:
                print(f"DBG DVD ET {task_def.task_id=}")

            self._error_code = -1
            self._errored = True

            if "message" in task_def.cargo:
                self._error_messages.append(
                    f"Task '{task_def.task_id} Error {task_def.cargo['message']}"
                )

            return None

        def _abort_task(task_def: Task_Def) -> None:
            """
            Handles the abort task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """
            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD AT {task_def.task_id=}")

            self._error_code = -1
            self._errored = True

            if "message" in task_def.cargo:
                self._error_messages.append(
                    f"Task '{task_def.task_id} Error {task_def.cargo['message']}"
                )

            return None

        #### Main
        assert isinstance(build_action, str) and build_action.strip() != "", (
            f"{build_action=}. Must be non-empty str"
        )

        # Note: The if/elif order is the build sequence and must be followed sequentially
        if not self._errored and build_action == VOB_ENCODING:  # 1
            self._encode_video()
        elif not self._errored and build_action == EXTRACT_MENU_IMAGES:  # 2
            task_id = f"{EXTRACT_MENU_IMAGES}_{self._session_id}"
            task_dispatch_name = f"D_{EXTRACT_MENU_IMAGES}_{self._session_id}"
            task_prefix = f"P_EXTRACT_MENU_IMAGES_{self._session_id}"

            task_def = Task_Def(
                task_id=task_id,
                task_prefix=task_prefix,
                worker_function=self._extract_menu_images,
                kwargs={},
            )

            Task_Dispatcher().submit_task(
                task_def=task_def,
                task_dispatch_methods=[
                    {
                        "task_dispatch_name": task_dispatch_name,
                        "callback": "start",
                        "operation": task_prefix,
                        "method": _start_menu_images_task,
                        "kwargs": {
                            "task_def": task_def,
                        },
                    },
                    {
                        "task_dispatch_name": task_dispatch_name,
                        "callback": "finish",
                        "operation": task_prefix,
                        "method": _finish_menu_images_task,
                        "kwargs": {
                            "task_def": task_def,
                        },
                    },
                    {
                        "task_dispatch_name": task_dispatch_name,
                        "callback": "error",
                        "operation": task_prefix,
                        "method": _error_task,
                        "kwargs": {
                            "task_def": task_def,
                        },
                    },
                    {
                        "task_dispatch_name": task_dispatch_name,
                        "callback": "abort",
                        "operation": task_prefix,
                        "method": _abort_task,
                        "kwargs": {
                            "task_def": task_def,
                        },
                    },
                ],
            )

        elif not self._errored and build_action == CREATE_DVD_MENU:  # 3
            task_id = f"{CREATE_DVD_MENU}_{self._session_id}"
            task_dispatch_ame = f"D_{CREATE_DVD_MENU}_{self._session_id}"
            task_prefix = f"P_CREATE_DVD_MENU_{self._session_id}"

            error_no, cell_coords, error_message = self._get_cell_coords()

            if error_no == -1:
                self._errored = True
                self._error_code = error_no
                self._error_messages.append(error_message)

            if not self._errored:
                task_id = task_id
                task_dispatch_name = task_dispatch_ame
                task_def = Task_Def(
                    task_id=task_id,
                    task_prefix=task_prefix,
                    worker_function=self._create_dvd_menu,
                    kwargs={"cell_coords": cell_coords},
                )

                Task_Dispatcher().submit_task(
                    task_def=task_def,
                    task_dispatch_methods=[
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "start",
                            "operation": task_prefix,
                            "method": _start_dvd_menu_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "finish",
                            "operation": task_prefix,
                            "method": _finish_dvd_menu_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "error",
                            "operation": task_prefix,
                            "method": _error_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "abort",
                            "operation": task_prefix,
                            "method": _abort_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                    ],
                )

        elif not self._errored and build_action == CREATE_DVD_IMAGE:  # 4
            task_id = f"{CREATE_DVD_IMAGE}_{self._session_id}"
            task_dispatch_name = f"D_{CREATE_DVD_IMAGE}_{self._session_id}"
            task_prefix = f"P_CREATE_DVD_IMAGE_{self._session_id}"

            error_no, cell_coords, error_message = self._get_cell_coords()

            if error_no == -1:
                self._errored = True
                self._error_code = error_no
                self._error_messages.append(error_message)

            if not self._errored:
                task_id = task_id
                task_def = Task_Def(
                    task_id=task_id,
                    task_prefix=task_prefix,
                    worker_function=self._create_dvd_image,
                    kwargs={"cell_coords": cell_coords},
                )

                Task_Dispatcher().submit_task(
                    task_def=task_def,
                    task_dispatch_methods=[
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "start",
                            "operation": task_prefix,
                            "method": _start_dvd_image_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "finish",
                            "operation": task_prefix,
                            "method": _finish_dvd_image_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "error",
                            "operation": task_prefix,
                            "method": _error_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "abort",
                            "operation": task_prefix,
                            "method": _abort_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                    ],
                )

        elif not self._errored and build_action == ARCHIVE_DVD_FILES:  # 5
            task_id = f"{ARCHIVE_DVD_FILES}_{self._session_id}"
            task_dispatch_name = f"D_{ARCHIVE_DVD_FILES}_{self._session_id}"
            task_prefix = f"P_{ARCHIVE_DVD_FILES}_{self._session_id}"

            error_no, cell_coords, error_message = self._get_cell_coords()

            if error_no == -1:
                self._errored = True
                self._error_code = error_no
                self._error_messages.append(error_message)

            if not self._errored:
                task_id = task_id
                task_def = Task_Def(
                    task_id=task_id,
                    task_prefix=task_prefix,
                    worker_function=self._archive_dvd_files,
                    kwargs={"cell_coords": cell_coords},
                )

                Task_Dispatcher().submit_task(
                    task_def=task_def,
                    task_dispatch_methods=[
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "start",
                            "operation": task_prefix,
                            "method": _start_archive_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "finish",
                            "operation": task_prefix,
                            "method": _finish_archive_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "error",
                            "operation": task_prefix,
                            "method": _error_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                        {
                            "task_dispatch_name": task_dispatch_name,
                            "callback": "abort",
                            "operation": task_prefix,
                            "method": _abort_task,
                            "kwargs": {
                                "task_def": task_def,
                            },
                        },
                    ],
                )

        elif not self._errored:
            raise RuntimeError(f"DBG unrecognised build action {build_action}")

        return None

    def _reset_new_state(self) -> None:
        """
        Resets flags and error messages for a new archiving operation.
        """
        self._error_messages = []
        self._errored = False
        self._error_code = 1
        self._error_message = ""

        self._final_report_triggered = False

        self._encode_video_complete = False
        self._extract_menu_images_complete = False
        self._create_dvd_menu_complete = False
        self._create_dvd_image_complete = False
        self._archive_complete = False

        return None

    def _check_all_groups_completed(self) -> None:
        """
        Checks if all major task groups () have
        signaled completion. If so, triggers the final status report.
        """
        if self._final_report_triggered:  # Prevent multiple final popups
            return None

        if (
            self._encode_video_complete
            and self._extract_menu_images_complete
            and self._create_dvd_menu_complete
            and self._create_dvd_image_complete
            and self._archive_complete
        ):
            if DEBUG:
                print(
                    "DBG DVD: All major task groups are reported complete. Triggering final status."
                )

            if self._component_event_handler:
                self.component_event_handler(sys_consts.NOTIFICATION_EVENT, "")

            if self._error_messages:
                final_error_message = "DVD Build Error...\n"

                for error_message in self._error_messages:
                    final_error_message += f"    {error_message}\n"

                if self._component_event_handler:
                    self.component_event_handler(
                        sys_consts.NOTIFICATION_ERROR_EVENT, final_error_message
                    )

        return None

    def _archive_dvd_files(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """
        Archives the specified video files into a DVD image and saves the ISO image to the specified folder.

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout
            representing the video files to be archived.

        Returns:
            tuple[int, str]:
            - arg 1:1 Ok. -1 otherwise.
            - arg 2: "" if ok, otherwise an error message

        """

        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        if (
            self.dvd_config.archive_folder and cell_coords
        ):  # Only archive if an archive folder is specified.
            archive_manager = Archive_Manager(
                archive_folder=self.dvd_config.archive_folder,
                streaming_folder=self.dvd_config.streaming_folder,
                archive_size=self.dvd_config.archive_size,
                transcode_type=self.dvd_config.transcode_type,
            )

            archive_manager.component_event_handler = self.component_event_handler

            menu_layout: list[tuple[str, list[Video_Data]]] = []
            video_list: list[Video_Data] = []

            page_index = cell_coords[0].page

            for cell_coord in cell_coords:
                if cell_coord.video_data is None:
                    continue

                if page_index != cell_coord.page:  # page break
                    if video_list:
                        menu_layout.append((
                            (
                                f"menu_{page_index}"
                                if self.dvd_config.menu_title[page_index].strip() == ""
                                else self.dvd_config.menu_title[page_index]
                            ),
                            video_list,
                        ))
                    page_index = cell_coord.page
                    video_list = []
                video_list.append(cell_coord.video_data)
            else:
                if video_list:
                    menu_layout.append((
                        (
                            f"menu_{page_index}"
                            if self.dvd_config.menu_title[page_index].strip() == ""
                            else self.dvd_config.menu_title[page_index]
                        ),
                        video_list,
                    ))
            result, message = archive_manager.archive_dvd_build(
                dvd_name=(
                    f"{self.dvd_config.serial_number} - {self._dvd_config.project_name}"
                ),
                dvd_folder=self.dvd_image_folder,
                iso_folder=self.iso_folder,
                menu_layout=menu_layout,
            )

            if result == -1:
                return -1, message

            file_handler = file_utils.File()

            if utils.Is_Complied():
                result, message = file_handler.remove_dir_contents(
                    self.dvd_working_folder
                )

            if result == -1:
                return -1, message

        return 1, ""

    def _build_working_folders(self) -> tuple[int, str]:
        """Builds the working file structure.

        All of these files are disposable once the DVD image is created

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        file_handler = file_utils.File()
        working_folder_name = self._session_id

        self._dvd_working_folder = file_handler.file_join(
            self.working_folder, sys_consts.DVD_BUILD_FOLDER_NAME
        )

        if not file_handler.path_exists(self.working_folder):
            if file_handler.path_writeable(self.working_folder):
                result = file_handler.make_dir(self._dvd_working_folder)

                if result == -1:
                    return -1, f"{self._dvd_working_folder=}. Could Not Be Created"
            else:
                return -1, f"{self._dvd_working_folder=}. Is Not Writeable"

        self._dvd_working_folder = file_handler.file_join(
            self._dvd_working_folder, working_folder_name
        )

        file_handler.make_dir(self._dvd_working_folder)

        if file_handler.path_exists(
            self._dvd_working_folder
        ) and file_handler.path_writeable(self._dvd_working_folder):
            self._dvd_out_folder = file_handler.file_join(
                self._dvd_working_folder, "dvd_image"
            )
            self._iso_out_folder = file_handler.file_join(
                self._dvd_working_folder, "iso_image"
            )
            self._menu_image_folder = file_handler.file_join(
                self._dvd_working_folder, "menu_images"
            )
            self._tmp_folder = file_handler.file_join(self._dvd_working_folder, "tmp")
            self._vob_folder = file_handler.file_join(self._dvd_working_folder, "vobs")

            if file_handler.make_dir(self._dvd_out_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._dvd_out_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._iso_out_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._iso_out_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._menu_image_folder) == -1:
                return (
                    -1,
                    (
                        f"{self._menu_image_folder=}. Could Not Be Created Or Is Not"
                        " Writeable"
                    ),
                )
            if file_handler.make_dir(self._tmp_folder) == -1:
                return (
                    -1,
                    f"{self._tmp_folder=}. Could Not Be Created Or Is Not Writeable",
                )
            if file_handler.make_dir(self._vob_folder) == -1:
                return (
                    -1,
                    f"{self._vob_folder=}. Could Not Be Created Or Is Not Writeable",
                )

        if not file_handler.path_exists(
            self._dvd_working_folder
        ) and not file_handler.path_writeable(self._dvd_working_folder):
            return (
                -1,
                (
                    f"{self._dvd_working_folder=}. Could Not Be Created Or Is Not"
                    " Writeable"
                ),
            )

        # Build mandatory file paths
        self._background_canvas_file = file_handler.file_join(
            self._tmp_folder, self._BACKGROUND_CANVAS_FILE
        )

        return 1, ""

    def _encode_video(self) -> tuple[int, str]:
        """Encodes the input video files as DVD VOB (mpeg2) files

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """

        #### Helper
        def _start_encode_video_task(task_def: Task_Def) -> None:
            """
            Handles the VOB encoding start task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """

            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD SEVT Started {task_def.task_id=}")

            if self._component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT,
                    f"Start VOB Encoding {sys_consts.SDELIM}{task_def.kwargs['input_file']}{sys_consts.SDELIM}",
                )

            return None

        def _finish_encode_video_task(task_def: Task_Def) -> None:
            """
            Handles the VOB encoding finish task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """

            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD EVT Finished {task_def.task_id=}")

            if self._component_event_handler:
                self.component_event_handler(
                    sys_consts.NOTIFICATION_EVENT,
                    f"Finish VOB Encoding {sys_consts.SDELIM}{task_def.kwargs['input_file']}{sys_consts.SDELIM}",
                )

            task_error_no, task_message, worker_error_no, worker_message = (
                Unpack_Result_Tuple(task_def)
            )

            if (
                task_error_no == 1
                and worker_error_no == 1
                and task_message.lower() == "all done"
            ):
                self._encode_video_complete = True

                if DEBUG:
                    print(
                        f"DBG AM FEVT: {task_def.task_id} (prefix '{VOB_ENCODING}') is complete."
                    )

                self._build_sequence(EXTRACT_MENU_IMAGES)

            elif task_error_no != 1 or worker_error_no != 1:
                self._error_messages.append(
                    f"VOB Encoding task {task_def.task_id} reported an error: TaskError={task_error_no}, "
                    f"WorkerError={worker_error_no}, Message='{task_message}'"
                )

                if self._component_event_handler:
                    self.component_event_handler(
                        sys_consts.NOTIFICATION_EVENT,
                        self._error_messages[-1],
                    )

                self._errored = True

            self._check_all_groups_completed()

            return None

        def _error_task(task_def: Task_Def) -> None:
            """
            Handles the VOB encoding error task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                None

            """

            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD EEVT {task_def.task_id=}")

            self._error_code = -1
            self._errored = True

            if "message" in task_def.cargo:
                self._error_messages.append(
                    f"Task '{task_def.task_id} Error {task_def.cargo['message']}"
                )

            return None

        def _abort_task(task_def: Task_Def) -> None:
            """
            Handles the VOB encoding abort task

            Args:
                task_def (Task_Def): Task Definition object

            Returns:
                 None

            """

            assert isinstance(task_def, Task_Def), (
                f"{task_def=}. Must be an instance of Task_Def"
            )

            if DEBUG:
                print(f"DBG DVD AEVT {task_def.task_id=}")

            self._error_code = -1
            self._errored = True

            if "message" in task_def.cargo:
                self._error_messages.append(
                    f"Task '{task_def.task_id} Error {task_def.cargo['message']}"
                )

            return None

        #### Main
        for video_index, video_file in enumerate(self.dvd_config.input_videos):
            task_id = f"vob_{video_index}_{self._session_id}"
            dispatch_name = f"D_{VOB_ENCODING}_{video_index}_{self._session_id}"
            task_prefix = f"P_{VOB_ENCODING}_{self._session_id}"

            task_def = Task_Def(
                task_id=task_id,
                task_prefix=task_prefix,
                worker_function=dvdarch_utils.Transcode_DVD_VOB,
                kwargs={
                    "input_file": video_file.video_path,
                    "output_folder": self._vob_folder,
                    "input_video_width": video_file.encoding_info.video_width,
                    "input_video_height": video_file.encoding_info.video_height,
                    "input_video_ar": video_file.encoding_info.video_ar,
                    "input_video_scan_type": video_file.encoding_info.video_scan_type,
                    "input_video_frame_rate": video_file.encoding_info.video_frame_rate,
                    "auto_bright": video_file.video_file_settings.auto_bright,
                    "normalise": video_file.video_file_settings.normalise,
                    "white_balance": video_file.video_file_settings.white_balance,
                    "denoise": video_file.video_file_settings.denoise,
                    "sharpen": video_file.video_file_settings.sharpen,
                    "filters_off": video_file.video_file_settings.filters_off,
                    "black_border": True,
                    "dvd_standard": sys_consts.PAL
                    if video_file.encoding_info.video_frame_rate == 25
                    or video_file.encoding_info.video_height
                    > sys_consts.NTSC_SPECS.height_43
                    else sys_consts.NTSC,
                },
            )

            Task_Dispatcher().submit_task(
                task_def=task_def,
                task_dispatch_methods=[
                    {
                        "task_dispatch_name": dispatch_name,
                        "callback": "start",
                        "operation": VOB_ENCODING,
                        "method": _start_encode_video_task,
                        "kwargs": {
                            "task_def": task_def,
                        },
                    },
                    {
                        "task_dispatch_name": dispatch_name,
                        "callback": "finish",
                        "operation": VOB_ENCODING,
                        "method": _finish_encode_video_task,
                        "kwargs": {
                            "task_def": task_def,
                        },
                    },
                    {
                        "task_dispatch_name": dispatch_name,
                        "callback": "error",
                        "operation": VOB_ENCODING,
                        "method": _error_task,
                        "kwargs": {
                            "task_def": task_def,
                        },
                    },
                    {
                        "task_dispatch_name": dispatch_name,
                        "callback": "abort",
                        "operation": VOB_ENCODING,
                        "method": _abort_task,
                        "kwargs": {
                            "task_def": task_def,
                        },
                    },
                ],
            )

        return 1, ""

    def _get_cell_coords(self) -> tuple[int, list[_Cell_Coord], str]:
        """Get the cell coordinates for the menu buttons

        Returns:
            tuple[int,list[_Cell_Coord],str]:
                - arg 1: Status code. Returns 1 if the cell coordinates were obtained successfully, -1 otherwise.
                - arg 2: List of cell coordinates for the menu buttons.
                - arg 3: Error message if the cell coordinates could not be obtained successfully
        """
        buttons_per_page = self.dvd_config.menu_buttons_per_page
        buttons_across = self.dvd_config.menu_buttons_across

        dvd_dims = dvdarch_utils.Get_DVD_Dims(
            self.dvd_config.menu_aspect_ratio, self.dvd_config.video_standard
        )

        if dvd_dims.display_height == -1:
            return -1, [], "Failed To Get DVD Dimensions"

        timestamp_height = 0

        if all(
            file_def.dvd_page >= 0 for file_def in self.dvd_config.input_videos
        ):  # Manual Layout
            cell_coords, message = self._dvd_page_calc_layout(
                buttons_per_page=buttons_per_page,
                buttons_across=buttons_across,
                button_aspect_ratio=4
                / 3,  # Actually does not matter because a 16/9 menu will stretch button
                dvd_dims=dvd_dims,
                border_top=10,
                border_bottom=10 + timestamp_height,
                border_left=10,  # + timestamp_height,
                border_right=10,  # + timestamp_height,
            )
        else:  # Auto calc layout
            cell_coords, message = self._auto_calc_layout(
                num_buttons=len(self.dvd_config.input_videos),
                buttons_per_page=buttons_per_page,
                buttons_across=buttons_across,
                button_aspect_ratio=4
                / 3,  # Actually does not matter because a 16/9 menu will stretch button
                dvd_dims=dvd_dims,
                border_top=10,
                border_bottom=10 + timestamp_height,
                border_left=10,  # + timestamp_height,
                border_right=10,  # + timestamp_height,
            )

        if not cell_coords:
            return -1, [], message

        return 1, cell_coords, ""

    def _create_dvd_menu(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Creates the DVD menu automagically

        Args:
            cell_coords (list[_Cell_Coord]): The cell coordinates for the menu buttons

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        debug = False

        result, message = self._resize_menu_button_images(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_labels(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._prepare_buttons(
            cell_coords=cell_coords,
        )

        if result == -1:
            return -1, message

        result, message = self._convert_to_m2v(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._convert_audio(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._multiplex_audio_video(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        result, message = self._create_menu_mpg(cell_coords=cell_coords)

        if result == -1:
            return -1, message

        if debug and not utils.Is_Complied():
            canvas_height, message = dvdarch_utils.Get_Image_Height(
                self._background_canvas_file
            )
            if canvas_height == -1:
                return -1, message

            canvas_width, message = dvdarch_utils.Get_Image_Width(
                self._background_canvas_file
            )
            if canvas_width == -1:
                return -1, message

        return 1, ""

    def _create_labels(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """
        Create images for each label to be placed on the button images.

        Args:
            cell_coords (list[_Cell_Coord]): The list of cell coordinates.

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail,
            - arg2: error message or "" if ok
        """
        # Black Choice
        # label_line_height = 0
        # label_lines = 2
        # font: str = "DejaVu-Sans-Bold"
        # pointsize: int = 15
        # fill: str = "white"
        # fill: str = "gold"
        # stroke: str = "black"
        # strokewidth: int = 0
        # word_spacing: int = 0
        # clear_inner_stroke: bool = True
        # line_height: int = 0
        # max_width: int = 0
        # max_lines: int = 1
        # size: int = 0
        # undercolor = "RoyalBlue"
        # background: str = "none"
        # gravity: str = "center"

        file_handler = file_utils.File()

        for cell_coord in cell_coords:
            if cell_coord.video_data is None:
                continue

            path_name, file_name, file_extn = file_handler.split_file_path(
                cell_coord.video_data.menu_image_file_path
            )

            # Setup required files
            menu_button_file = file_handler.file_join(path_name, file_name, file_extn)
            menu_button_text_file = file_handler.file_join(
                path_name, f"{file_name}_text_{cell_coord.page}", file_extn
            )

            if not file_handler.file_exists(menu_button_file):
                return -1, f"Video File Does Not Exist : {menu_button_file}"

            menu_text = cell_coord.video_data.video_file_settings.button_title

            result, message = dvdarch_utils.Overlay_Text(
                in_file=menu_button_file,
                out_file=menu_button_text_file,
                text=menu_text,
                text_font=self.dvd_config.button_font,
                text_pointsize=self.dvd_config.button_font_point_size,
                text_color=self.dvd_config.button_font_color,
                position="bottom",
                background_color=self.dvd_config.button_background_color,
                opacity=self.dvd_config.button_background_transparency,
                y_offset=10,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _build_page_grid(
        self,
        num_buttons: int,
        num_pages: int,
        buttons_per_page: int,
        buttons_across: int,
    ) -> tuple[list[list], int, int]:
        """
         Builds a page grid.  Empty cells are represented by -1, Non-empty cells are represented by 1.

        Args:
            num_buttons (int): Total number of buttons in the dvd menu.
            num_pages (int): Total number of pages in the dvd menu.
            buttons_per_page (int): Number of buttons on a single page.
            buttons_across (int): Number of buttons across a single page.

        Returns:
            tuple[list[list], int, int]:
            - arg 1: A list of page grids.
            - arg 2: Number of rows in the page grid.
            - arg 3: Number of columns in the page grid.
        """
        assert isinstance(num_buttons, int) and num_buttons > 0, (
            f"{num_buttons=}. Must be int > 0"
        )
        assert isinstance(buttons_per_page, int) and buttons_per_page > 0, (
            f"{buttons_per_page=}. Must be int > 0"
        )
        assert isinstance(buttons_across, int) and buttons_across > 0, (
            f"{buttons_across=}. Must be int > 0"
        )

        pages = []
        button_count = 0
        num_rows = 0
        num_cols = 0

        if buttons_per_page == 1:
            buttons_down = 1
        else:
            buttons_down = math.ceil(buttons_per_page / buttons_across)

        for _ in range(num_pages):
            page_grid = [
                [-1 for _ in range(buttons_across)] for _ in range(buttons_down)
            ]

            button_num = 0
            for row_index in range(buttons_down):
                for col_index in range(buttons_across):
                    if button_num > buttons_per_page - 1:
                        break
                    elif button_count < num_buttons:
                        page_grid[row_index][col_index] = 1
                        button_count += 1
                    else:
                        break

                    button_num += 1

                if button_num > buttons_per_page - 1 or button_count == num_buttons:
                    break

            pages.append(page_grid)
            num_rows = max(num_rows, len(page_grid))
            num_cols = max(num_cols, len(page_grid[0]))
        return pages, num_rows, num_cols

    def _auto_calc_layout(
        self,
        num_buttons: int,
        buttons_per_page: int,
        buttons_across,
        button_aspect_ratio: float,
        dvd_dims: dvdarch_utils.Dvd_Dims,
        border_top: int = 0,
        border_left: int = 0,
        border_bottom: int = 15,
        border_right: int = 0,
    ) -> tuple[list[_Cell_Coord], str]:
        """
        Generates a layout of rectangles with fixed size borders on each edge,
        arranged to fit within a canvas of fixed aspect ratio.

        Args:
            num_buttons (int): The number of num_buttons to be arranged.
            buttons_per_page (int): The number of buttons on the DVD menu page
            buttons_across (int): The number of buttons across the DVD menu (buttons down is calculated).
            button_aspect_ratio (float): The aspect ratio of the button rectangles (height/width).
            dvd_dims (dvdarch_utils.dvd_dims): The DVD dimensions
            border_top (int): The width of the border at the top edge of the canvas.
            border_left (int): The width of the border at the left edge of the canvas.
            border_bottom (int): The width of the border at the bottom edge of the canvas.
            border_right (int): The width of the border at the right edge of the canvas.

        Returns:
            tuple[list[_Cell_Coord], str]:
            - arg 1: A list of _Cell_Coords objects representing the layout of the rectangles within the canvas.
            - arg 2 : An error message if there is an error.

        """
        assert isinstance(num_buttons, int) and num_buttons > 0, (
            f"{num_buttons=}. Must be int > 0"
        )
        assert isinstance(button_aspect_ratio, float) and button_aspect_ratio > 0, (
            f"{button_aspect_ratio=}. Must be float > 0"
        )
        assert isinstance(dvd_dims, dvdarch_utils.Dvd_Dims), (
            f"{dvd_dims=}. Must be a valid dvd_dims object"
        )
        assert isinstance(border_top, int) and border_top >= 0, (
            f"{border_top=}. Must be int >= 0"
        )
        assert isinstance(border_left, int) and border_left >= 0, (
            f"{border_left=}. Must be int >= 0"
        )
        assert isinstance(border_bottom, int) and border_bottom >= 0, (
            f"{border_bottom=}. Must be int >= 0"
        )
        assert isinstance(border_right, int) and border_right >= 0, (
            f"{border_right=}. Must be int >= 0"
        )

        # TODO Make these values configurable
        header_pad = 10  # Feel good thing
        button_padding = 20  # Min value that works with spumux

        pointer_path_data: "_Menu_Pointer_Data" = None

        # This keeps spumux happy
        if border_right < self._SPUMUX_BUFFER:
            border_right = self._SPUMUX_BUFFER

        if border_left < self._SPUMUX_BUFFER:
            border_left = self._SPUMUX_BUFFER

        if not self.dvd_config.menu_title:  # Header pad is only for titles
            header_pad = 0

        # Compute the canvas size and ratio
        canvas_width = dvd_dims.storage_width - (border_left + border_right)
        canvas_height = dvd_dims.storage_height - (
            border_top + border_bottom + header_pad
        )

        num_pages = math.ceil(num_buttons / buttons_per_page)

        if num_pages > 1:
            pointer_path_data = self._Menu_Pointer_Data(
                background_canvas_file=self._background_canvas_file,
                dvd_config=self.dvd_config,
                spumux_buffer=self._SPUMUX_BUFFER,
            )

            if pointer_path_data.error_code == -1:
                return (
                    [],
                    "Failed To Get Page Pointer Path & Size",
                )

        pages, num_rows, num_cols = self._build_page_grid(
            num_buttons=num_buttons,
            num_pages=num_pages,
            buttons_per_page=buttons_per_page,
            buttons_across=buttons_across,
        )

        max_button_height = canvas_height // max(
            num_rows, 4
        )  # Do not change as spumux very sensitive to this

        # Compute the maximum width of each rectangle based on the number of columns across all pages
        rect_width_max = (
            (canvas_width // num_cols)
            - (num_cols * button_padding)
            - (border_left + border_right)
        )

        # Compute the dimensions of each rectangle and the padding between them
        rect_width = rect_width_max
        rect_height = int(min(canvas_height / num_rows, max_button_height))
        rect_aspect_ratio = rect_width / rect_height

        if rect_aspect_ratio > button_aspect_ratio:
            rect_width = int(rect_height * button_aspect_ratio)
        else:
            rect_height = int(rect_width / button_aspect_ratio)

        # Compute the vertical padding between the rectangles
        if num_rows > 1:
            rect_padding = (canvas_height - rect_height * num_rows) / (num_rows - 1)
        else:
            rect_padding = canvas_height - rect_height * num_rows

        # We do not want the padding to be too big or small, so we max it at
        # twice the horizontal spacing between the rectangles and min it at button_padding.
        if rect_padding < button_padding or rect_padding > 2 * button_padding:
            rect_padding = 2 * button_padding

        # Want buttons in same pos on all pages, so we calc based on first page
        num_non_empty_rows = sum(1 for row in pages[0] if any(col != -1 for col in row))

        # Calculate the total height of the grid
        total_height = (
            num_non_empty_rows * rect_height + (num_non_empty_rows - 1) * rect_padding
        )

        if total_height > canvas_height:
            return (
                [],
                f"Too Many Buttons Down: {total_height=}  >  {canvas_height=}",
            )

        # Calculate the y offset
        y_offset = ((canvas_height - total_height) // 2) + border_top + header_pad

        cell_cords = []
        file_index = 0
        for page_index, page in enumerate(pages):
            for row_index, row in enumerate(page):
                row_col_count = len([col for col in row if col != -1])

                total_width = (row_col_count * rect_width) + (
                    button_padding * (row_col_count - 1)
                )

                if total_width > canvas_width:
                    return (
                        [],
                        f"Too Many Buttons Across: {total_width=}  >  {canvas_width=}",
                    )

                x_offset = (canvas_width - total_width) // 2 + border_right

                col_index = 0
                for col_value in row:
                    if col_value == -1:  # Ignore not on grid
                        continue

                    x = int(x_offset + col_index * (rect_width + button_padding))
                    y = int(y_offset + row_index * (rect_height + rect_padding))

                    if file_index > len(self.dvd_config.input_videos) - 1:
                        return (
                            [],
                            (
                                "File index out of range 0 -"
                                f" {len(self.dvd_config.input_videos) - 1}"
                            ),
                        )

                    cell_cords.append(
                        _Cell_Coord(
                            name=f"button_{file_index}",
                            x0=x,
                            y0=y,
                            x1=x + rect_width,
                            y1=y + rect_height,
                            width=rect_width
                            - button_padding,  # Provide space between buttons
                            height=rect_height
                            - button_padding,  # Provide space between buttons
                            page=page_index,
                            video_data=self.dvd_config.input_videos[file_index],
                        )
                    )
                    file_index += 1
                    col_index += 1
            if pointer_path_data:  # Add page pointers
                # Left Pointer
                cell_cords.append(
                    _Cell_Coord(
                        name=f"left_pointer_{file_index + 1}",
                        x0=pointer_path_data.left_x_offset,
                        y0=pointer_path_data.left_y_offset,
                        x1=pointer_path_data.left_x_offset + pointer_path_data.width,
                        y1=pointer_path_data.left_y_offset + pointer_path_data.height,
                        width=pointer_path_data.width
                        + button_padding,  # Provide space between buttons
                        height=pointer_path_data.height
                        + button_padding,  # Provide space between buttons
                        page=page_index,
                        video_data=None,
                        cargo={
                            "pointer_data": pointer_path_data,
                            "left": page_index - 1 if page_index > 0 else num_pages,
                        },
                    )
                )

                # Right Pointer
                cell_cords.append(
                    _Cell_Coord(
                        name=f"right_pointer_{file_index + 2}",
                        x0=pointer_path_data.right_x_offset,
                        y0=pointer_path_data.right_y_offset,
                        x1=pointer_path_data.right_x_offset + pointer_path_data.width,
                        y1=pointer_path_data.right_y_offset + pointer_path_data.height,
                        width=pointer_path_data.width
                        + button_padding,  # Provide space between buttons
                        height=pointer_path_data.height
                        + button_padding,  # Provide space between buttons
                        page=page_index,
                        video_data=None,
                        cargo={
                            "pointer_data": pointer_path_data,
                            "right": page_index + 1
                            if page_index < num_pages - 1
                            else 0,
                        },
                    )
                )

        return cell_cords, ""

    def _dvd_page_calc_layout(
        self,
        buttons_per_page: int,
        buttons_across,
        button_aspect_ratio: float,
        dvd_dims: dvdarch_utils.Dvd_Dims,
        border_top: int = 0,
        border_left: int = 0,
        border_bottom: int = 15,
        border_right: int = 0,
    ) -> tuple[list[_Cell_Coord], str]:
        """
        Generates a layout of rectangles with fixed size borders on each edge,
        arranged to fit, according to assigned dvd pages.

        Args:
            buttons_per_page (int): The number of buttons on the DVD menu page
            buttons_across (int): The number of buttons across the DVD menu (buttons down is calculated).
            button_aspect_ratio (float): The aspect ratio of the button rectangles (height/width).
            dvd_dims (dvdarch_utils.dvd_dims): The DVD dimensions
            border_top (int): The width of the border at the top edge of the canvas.
            border_left (int): The width of the border at the left edge of the canvas.
            border_bottom (int): The width of the border at the bottom edge of the canvas.
            border_right (int): The width of the border at the right edge of the canvas.
        Returns:
            tuple[list[_Cell_Coord], str]:
            - arg 1: A list of _Cell_Coords objects representing the layout of the rectangles within the canvas.
            - arg 2 : An error message if there is an error.

        """
        assert isinstance(buttons_per_page, int) and buttons_per_page > 0, (
            f"{buttons_per_page=}. Must be int > 0"
        )
        assert isinstance(buttons_across, int) and buttons_across > 0, (
            f"{buttons_across=}. Must be int > 0"
        )
        assert isinstance(button_aspect_ratio, float) and button_aspect_ratio > 0, (
            f"{button_aspect_ratio=}. Must be float > 0"
        )
        assert isinstance(button_aspect_ratio, float) and button_aspect_ratio > 0, (
            f"{button_aspect_ratio=}. Must be float > 0"
        )
        assert isinstance(dvd_dims, dvdarch_utils.Dvd_Dims), (
            f"{dvd_dims=}. Must be a valid dvd_dims object"
        )
        assert isinstance(border_top, int) and border_top >= 0, (
            f"{border_top=}. Must be int >= 0"
        )
        assert isinstance(border_left, int) and border_left >= 0, (
            f"{border_left=}. Must be int >= 0"
        )
        assert isinstance(border_bottom, int) and border_bottom >= 0, (
            f"{border_bottom=}. Must be int >= 0"
        )
        assert isinstance(border_right, int) and border_right >= 0, (
            f"{border_right=}. Must be int >= 0"
        )

        # TODO Make these values configurable
        header_pad = 10  # Feel good thing
        button_padding = 20  # Min value that works with spumux

        pointer_path_data: "_Menu_Pointer_Data" = None

        # This keeps spumux happy
        if border_right < self._SPUMUX_BUFFER:
            border_right = self._SPUMUX_BUFFER

        if border_left < self._SPUMUX_BUFFER:
            border_left = self._SPUMUX_BUFFER

        if not self.dvd_config.menu_title:  # Header pad is only for titles
            header_pad = 0

        # Compute the canvas size and ratio
        canvas_width = dvd_dims.storage_width - (border_left + border_right)
        canvas_height = dvd_dims.storage_height - (
            border_top + border_bottom + header_pad
        )

        num_pages = (
            self.dvd_config.input_videos[-1].dvd_page + 1
        )  # dvd_page is zero based

        if num_pages > 1:
            pointer_path_data = self._Menu_Pointer_Data(
                background_canvas_file=self._background_canvas_file,
                dvd_config=self.dvd_config,
                spumux_buffer=self._SPUMUX_BUFFER,
            )

            if pointer_path_data.error_code == -1:
                return (
                    [],
                    "Failed To Get Page Pointer Path & Size",
                )

        if buttons_per_page == 1:
            buttons_down = 1
        else:
            buttons_down = math.ceil(buttons_per_page / buttons_across)

        max_button_height = canvas_height // max(
            buttons_down, 4
        )  # Do not change as spumux very sensitive to this

        # Compute the maximum width of each rectangle based on the number of columns across all pages
        rect_width_max = (
            (canvas_width // buttons_across)
            - (buttons_across * button_padding)
            - (border_left + border_right)
        )

        # Compute the dimensions of each rectangle and the padding between them
        rect_width = rect_width_max
        rect_height = int(min(canvas_height / buttons_down, max_button_height))
        rect_aspect_ratio = rect_width / rect_height

        if rect_aspect_ratio > button_aspect_ratio:
            rect_width = int(rect_height * button_aspect_ratio)
        else:
            rect_height = int(rect_width / button_aspect_ratio)

        # Compute the vertical padding between the rectangles
        if buttons_down > 1:
            rect_padding = (canvas_height - rect_height * buttons_down) / (
                buttons_down - 1
            )
        else:
            rect_padding = canvas_height - rect_height * buttons_down

        # We do not want the padding to be too big or small, so we max it at
        # twice the horizontal spacing between the rectangles and min it at button_padding.
        if rect_padding < button_padding or rect_padding > 2 * button_padding:
            rect_padding = 2 * button_padding

        dvd_menu_pages = []
        num_non_empty_rows = 0
        for page_index in range(num_pages):
            page_file_defs = [
                file_def
                for file_def in sorted(
                    self.dvd_config.input_videos, key=lambda item: item.dvd_page
                )
                if file_def.dvd_page == page_index
            ]

            dvd_page = []

            for row_index in range(buttons_down):
                row = []
                for col_index in range(buttons_across):
                    if row_index * buttons_across + col_index >= len(page_file_defs):
                        break

                    row.append(page_file_defs[row_index * buttons_across + col_index])

                if row_index > num_non_empty_rows:
                    num_non_empty_rows = row_index

                dvd_page.append(row)

            dvd_menu_pages.append(dvd_page)

        cell_cords = []
        file_index = 0

        for page_index, page in enumerate(dvd_menu_pages):
            # Num of rows could vary per page so need to calc for each page
            num_non_empty_rows = len([item for item in page if item])

            # Calculate the total height of the grid
            total_height = (
                num_non_empty_rows * rect_height
                + (num_non_empty_rows - 1) * rect_padding
            )

            # Calculate the y offset
            y_offset = ((canvas_height - total_height) // 2) + border_top + header_pad

            for row_index, row in enumerate(page):
                row_col_count = len(row)

                total_width = (row_col_count * rect_width) + (
                    button_padding * (row_col_count - 1)
                )

                if total_width > canvas_width:
                    return (
                        [],
                        f"Too Many Buttons Across: {total_width=}  >  {canvas_width=}",
                    )

                x_offset = (canvas_width - total_width) // 2 + border_right

                col_index = 0
                for col_value in row:
                    if col_value == -1:  # Ignore not on grid
                        continue

                    x = int(x_offset + col_index * (rect_width + button_padding))
                    y = int(y_offset + row_index * (rect_height + rect_padding))

                    if file_index > len(self.dvd_config.input_videos) - 1:
                        return (
                            [],
                            (
                                "File index out of range 0 -"
                                f" {len(self.dvd_config.input_videos) - 1}"
                            ),
                        )

                    cell_cords.append(
                        _Cell_Coord(
                            name=f"button_{file_index}",
                            x0=x,
                            y0=y,
                            x1=x + rect_width,
                            y1=y + rect_height,
                            width=rect_width
                            - button_padding,  # Provide space between buttons
                            height=rect_height
                            - button_padding,  # Provide space between buttons
                            page=page_index,
                            video_data=self.dvd_config.input_videos[file_index],
                        )
                    )
                    file_index += 1
                    col_index += 1
            if pointer_path_data:  # Add page pointers
                # Left Pointer
                cell_cords.append(
                    _Cell_Coord(
                        name=f"left_pointer_{file_index + 1}",
                        x0=pointer_path_data.left_x_offset,
                        y0=pointer_path_data.left_y_offset,
                        x1=pointer_path_data.left_x_offset + pointer_path_data.width,
                        y1=pointer_path_data.left_y_offset + pointer_path_data.height,
                        width=pointer_path_data.width,
                        height=pointer_path_data.height
                        + button_padding,  # Provide space between buttons
                        page=page_index,
                        video_data=None,
                        cargo={
                            "pointer_data": pointer_path_data,
                            "left": page_index - 1 if page_index > 0 else num_pages,
                        },
                    )
                )

                # Right Pointer
                cell_cords.append(
                    _Cell_Coord(
                        name=f"right_button_{file_index + 2}",
                        x0=pointer_path_data.right_x_offset,
                        y0=pointer_path_data.right_y_offset,
                        x1=pointer_path_data.right_x_offset + pointer_path_data.width,
                        y1=pointer_path_data.right_y_offset + pointer_path_data.height,
                        width=pointer_path_data.width,
                        height=pointer_path_data.height
                        + button_padding,  # Provide space between buttons
                        page=page_index,
                        video_data=None,
                        cargo={
                            "pointer_data": pointer_path_data,
                            "right": page_index + 1
                            if page_index < num_pages - 1
                            else 0,
                        },
                    )
                )

        return cell_cords, ""

    def _create_canvas_image(self, width: int, height: int) -> tuple[int, str]:
        """Creates a background canvas to place the menu elements on

        Args:
            width (int): Width in pixels
            height (int ): Height in pixels

        Returns:
            tuple[int,str]
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(width, int) and width > 0, f"{width=}. Must be int > 0"
        assert isinstance(width, int) and width > 0, f"{height=}. Must be int > 0"

        commands = [
            sys_consts.CONVERT,
            "-size",
            f"{width}x{height}",
            f"xc:{self.dvd_config.menu_background_color}",
            self._background_canvas_file,
        ]

        result, message = Execute_Check_Output(commands=commands)

        if result == -1:
            return -1, message

        if self.dvd_config.timestamp_font and self.dvd_config.timestamp:
            _, timestamp_height = dvdarch_utils.Get_Text_Dims(
                text=self.dvd_config.timestamp,
                font=self.dvd_config.timestamp_font,
                pointsize=self.dvd_config.timestamp_font_point_size,
            )

            if timestamp_height == -1:
                return -1, "Failed to get timestamp height"

            result, message = dvdarch_utils.Write_Text_On_File(
                input_file=self._background_canvas_file,
                text=self.dvd_config.timestamp,
                x=self._dvd_timestamp_x_offset,
                y=height - timestamp_height,
                pointsize=self.dvd_config.timestamp_font_point_size,
                color=self.dvd_config.menu_font_color,
                font=self.dvd_config.timestamp_font,
            )

            if result == -1:
                return -1, message

        if self.dvd_config.timestamp_font and self.dvd_config.serial_number:
            serial_num_width, serial_num_height = dvdarch_utils.Get_Text_Dims(
                text=self.dvd_config.serial_number,
                font=self.dvd_config.timestamp_font,
                pointsize=self.dvd_config.timestamp_font_point_size,
            )

            if serial_num_height == -1:
                return -1, "Failed to get serial number height"

            result, message = dvdarch_utils.Write_Text_On_File(
                input_file=self._background_canvas_file,
                text=self.dvd_config.serial_number,
                x=width - serial_num_width - self._dvd_timestamp_x_offset,
                y=height - serial_num_height,
                pointsize=self.dvd_config.timestamp_font_point_size,
                color=self.dvd_config.menu_font_color,
                font=self.dvd_config.timestamp_font,
            )

            if result == -1:
                return -1, message

            calling_card = (
                f"{sys_consts.PROGRAM_NAME} (c)"
                f" {sys_consts.AUTHOR} {sys_consts.COPYRIGHT_YEAR()}"
            )

            progname_width, progname_height = dvdarch_utils.Get_Text_Dims(
                text=calling_card,
                font=self.dvd_config.timestamp_font,
                pointsize=self.dvd_config.timestamp_font_point_size,
            )

            if progname_height == -1:
                return -1, "Failed to get calling card height"

            result, message = dvdarch_utils.Write_Text_On_File(
                input_file=self._background_canvas_file,
                text=calling_card,
                x=width // 2 - progname_width // 2,
                y=height - progname_height,
                pointsize=self.dvd_config.timestamp_font_point_size,
                color=self.dvd_config.menu_font_color,
                font=self.dvd_config.timestamp_font,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _prepare_buttons(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Prepares the buttons and places them on the requisite image files required to build a dvd menu.

        Args:
            cell_coords (list[_Cell_Coord]): The list of cell coordinates.

        Returns:
            tuple[int, str]: A tuple containing the following values:
                - arg1: 1: ok, -1: fail
                - arg2: error message or "" if ok
        """

        # ===== Helper
        def _get_canvas_overlay_files(
            background_path_name: str, background_file_name: str, page_no: int
        ) -> tuple[int, str, str, str, str]:
            """Returns a tuple containing the paths of canvas overlay, highlight, select, and images files.

            Args:
                background_path_name (str): The path of the background file.
                background_file_name (str): The name of the background file.
                page_no (int): The page number for which the canvas files are required.

            Returns:
                tuple[int, str, str, str, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - The path of the canvas overlay file or error_message of not ok .
                    - The path of the canvas highlight file.
                    - The path of the canvas select file.
                    - The path of the canvas images file.
            """
            assert (
                isinstance(background_path_name, str)
                and background_path_name.strip() != ""
            ), f"{background_path_name=}. Must be non-empty str"
            assert (
                isinstance(background_file_name, str)
                and background_file_name.strip() != ""
            ), f"{background_file_name=}. Must be non-empty str"
            assert isinstance(page_no, int) and page_no >= 0, (
                f"{page_no=}. Must be int >= 0"
            )

            canvas_overlay_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_overlay_{page_no}",
                "png",
            )
            canvas_highlight_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_highlight_{page_no}",
                "png",
            )
            canvas_select_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_select_{page_no}",
                "png",
            )
            canvas_images_file = file_handler.file_join(
                background_path_name,
                f"{background_file_name}_images_{page_no}",
                "png",
            )

            command = [
                sys_consts.CONVERT,
                self._background_canvas_file,
                canvas_images_file,
            ]

            result, message = Execute_Check_Output(commands=command)

            if result == -1:
                return -1, message, "", "", ""

            return (
                1,
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
                canvas_images_file,
            )

        def _create_canvas_files(
            width: int,
            height: int,
            canvas_overlay_file: str,
            canvas_highlight_file: str,
            canvas_select_file: str,
        ) -> tuple[int, str]:
            """Create canvas image files with specified width and height.

            Args:
                width (int): Width of the canvas image files to create.
                height (int): Height of the canvas image files to create.
                canvas_overlay_file (str): Filename for the canvas overlay file.
                canvas_highlight_file (str): Filename for the canvas highlight file.
                canvas_select_file (str): Filename for the canvas select file.

            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if successful, otherwise -1.
                    - "" if successful, otherwise the error message.
            """
            # Check that the width and height are positive integers
            assert isinstance(width, int) and width > 0, f"{width=}. Must be int >= 0 "
            assert isinstance(height, int) and height > 0, (
                f"{height=}. Must be int >= 0 "
            )
            assert (
                isinstance(canvas_overlay_file, str)
                and canvas_overlay_file.strip() != ""
            ), f"{canvas_overlay_file=}. Cannot be empty."
            assert (
                isinstance(canvas_highlight_file, str)
                and canvas_highlight_file.strip() != ""
            ), f"{canvas_highlight_file=}. Cannot be empty."
            assert (
                isinstance(canvas_select_file, str) and canvas_select_file.strip() != ""
            ), f"{canvas_select_file=}. Cannot be empty."

            for file in (
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
            ):
                result, message = dvdarch_utils.Create_Transparent_File(
                    width=width,
                    height=height,
                    out_file=file,
                )

                if result == -1:
                    return -1, message
            return 1, ""

        def _create_outline_files(
            width: int,
            height: int,
            overlay_file: str,
            highlight_file: str,
            selected_file: str,
            highlight_border_colour: str = "gold",
            select_border_colour: str = "white",
        ) -> tuple[int, str]:
            """Creates three outline files (highlight, select, and overlay) with transparent backgrounds and colored borders.

            Args:
                width (int): The width of the outline files in pixels.
                height (int): The height of the outline files in pixels.
                overlay_file (str): The name of the overlay file.
                highlight_file (str): The name of the highlight file.
                selected_file (str): The name of the selected file.
                highlight_border_colour (str, optional): The color of the highlight border. Defaults to "gold".
                select_border_colour (str, optional): The color of the select border. Defaults to "white".

            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - "" if ok otherwise the error message
            """
            assert isinstance(width, int), f"{width=}. Must be int >= 0"
            assert isinstance(height, int), f"{height=} . Must be int >= 0"
            assert isinstance(overlay_file, str) and overlay_file.strip() != "", (
                f"{overlay_file=}. Must be non-empty str"
            )
            assert isinstance(highlight_file, str) and highlight_file.strip() != "", (
                f"{highlight_file} . Must be non-empty str"
            )
            assert isinstance(selected_file, str) and selected_file.strip() != "", (
                f"{selected_file} . Must be non-empty str"
            )
            assert (
                isinstance(highlight_border_colour, str)
                and highlight_border_colour.strip() != ""
            ), f"{highlight_border_colour=} . Must be non-empty str"
            assert (
                isinstance(select_border_colour, str)
                and select_border_colour.strip() != ""
            ), f"{select_border_colour=} . Must be non-empty str"

            # Create the 3 outline files we will need - highlight, select, overlay
            for file in (
                (overlay_file, "transparent"),
                (highlight_file, highlight_border_colour),
                (selected_file, select_border_colour),
            ):
                out_file = file[0]
                border_color = file[1]

                result, message = dvdarch_utils.Create_Transparent_File(
                    width=width,
                    height=height,
                    out_file=out_file,
                    border_color=border_color,
                )

                if result == -1:
                    return -1, message

            return 1, ""

        def _overlay_files(
            x: int, y: int, files: tuple[tuple[str, str], ...]
        ) -> tuple[int, str]:
            """Places a file on another file at a given x, y coord

            Args:
                x (int): x co-ordinate of image
                y (int): y co-ordinate of image
                files (tuple[tuple[str, str], ...]): A tuple of tuples defining the files to be overlaid.
                tuple[0] is the file to be overlaid, tuple[1] is the file to overlay it on.


            Returns:
                tuple[int, str]: A tuple containing the following values:
                    - 1 if ok, otherwise -1.
                    - "" if ok otherwise the error message
            """
            assert isinstance(x, int), f"{x=}. Must be int >= 0"
            assert isinstance(y, int), f"{y=}. Must be int >= 0"
            assert isinstance(files, tuple), f"{files=}. Must be tuple"
            assert all(
                isinstance(file_tuple, tuple) and len(file_tuple) == 2
                for file_tuple in files
            ), f"{files=}. Must be tuple of tuples"

            for file_tuple in files:
                overlaid_file = file_tuple[0]
                overlay_file = file_tuple[1]

                result, message = dvdarch_utils.Overlay_File(
                    in_file=overlaid_file,
                    overlay_file=overlay_file,
                    out_file=overlaid_file,
                    x=x,
                    y=y,
                )

                if result == -1:
                    return -1, message
            return 1, ""

        def _write_spumux_xml(
            page: int,
            spu_buttons: list[dict[str, str]],
            background_path_name: str,
        ) -> tuple[int, str]:
            """
            Writes a spumux xml file for the page.

            Args:
                page (int): The current page number.
                spu_buttons (list[dict[str, str]]): A list of dictionaries defining the spu buttons.
                background_path_name (str): The path name for the background file.

            Returns:
                tuple[int, str]: A tuple of an integer (1 on success, -1 on failure) and a string message.

            """
            assert isinstance(page, int), f"{page=}. Must be int"

            assert (
                isinstance(background_path_name, str)
                and background_path_name.strip() != ""
            ), f"{background_path_name}. Must be str"

            file_handler = file_utils.File()

            (
                result,
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
                _,
            ) = _get_canvas_overlay_files(
                background_path_name=background_path_name,
                background_file_name=background_file_name,
                page_no=page_number,
            )

            if result == -1:
                return (
                    -1,
                    canvas_overlay_file,
                )  # Holds error message if result is -1

            spumux_xml = file_handler.file_join(
                background_path_name, f"spumux_{page_number}", "xml"
            )

            try:
                with open(spumux_xml, "w") as result_file:
                    xmltodict.unparse(
                        input_dict={
                            "subpictures": {
                                "@format": self.dvd_config.video_standard,
                                "stream": {
                                    "spu": {
                                        "@force": "yes",
                                        "@start": "00:00:00.00",
                                        "@image": canvas_overlay_file,
                                        "@highlight": canvas_highlight_file,
                                        "@select": canvas_select_file,
                                        "button": spu_buttons,
                                    }
                                },
                            }
                        },
                        output=result_file,
                        pretty=True,
                    )
            except IOError:
                return -1, f"Sys Error: Could Not Write {spumux_xml}"

            return 1, ""

        # ===== Main
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        file_handler = file_utils.File()

        background_path_name, background_file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        # ----- Write out spumux files #
        spu_pages = {}

        canvas_width, canvas_height, message = dvdarch_utils.Get_Image_Size(
            self._background_canvas_file
        )

        if canvas_width == -1:  # Error
            return -1, message

        for cell_index, cell_coord in enumerate(cell_coords):
            page_number = cell_coord.page  # Get the page number from the cell

            if page_number not in spu_pages:
                spu_pages[page_number] = []

            spu_pages[page_number].append(cell_coord)

        button_index = 0

        for page_number in spu_pages:
            spu_buttons = []
            for cell_coord in spu_pages[page_number]:
                button_x0 = cell_coord.x0
                button_y0 = cell_coord.y0
                button_x1 = cell_coord.x0 + cell_coord.width
                button_y1 = cell_coord.y0 + cell_coord.height

                # Need to ensure y co-ordinates are even to keep some DVD players happy
                if button_y0 % 2 != 0:
                    button_y0 = button_y0 - 1 if button_y0 > 0 else button_y0 + 1

                if button_y1 % 2 != 0:
                    button_y1 += 1

                spu_buttons.append(
                    {
                        "@name": f"{cell_coord.name}",
                        "@x0": button_x0,
                        "@y0": button_y0,
                        "@x1": button_x1,
                        "@y1": button_y1,
                    },
                )

                button_index += 1

            if spu_buttons:  # Write out spumux file
                result, message = _write_spumux_xml(
                    page=page_number,
                    spu_buttons=spu_buttons,
                    background_path_name=background_path_name,
                )

                if result == -1:
                    return -1, message

            # Now generate required image files
            (
                result,
                canvas_overlay_file,
                canvas_highlight_file,
                canvas_select_file,
                canvas_images_file,
            ) = _get_canvas_overlay_files(
                background_path_name=background_path_name,
                background_file_name=background_file_name,
                page_no=page_number,
            )

            if result == -1:
                return (
                    -1,
                    canvas_overlay_file,
                )  # Holds error message if result is -1

            command = [
                sys_consts.CONVERT,
                self._background_canvas_file,
                canvas_images_file,
            ]

            result, message = Execute_Check_Output(commands=command)

            if result == -1:
                return -1, message

            menu_title = self.dvd_config.menu_title[page_number]

            if page_number == 0 and self.dvd_config.disk_title.strip() != "":
                menu_title = f"{self.dvd_config.disk_title}\n{menu_title}"

            if menu_title.strip() != "":
                result, message = dvdarch_utils.Overlay_Text(
                    in_file=canvas_images_file,
                    text=menu_title,
                    text_font=self.dvd_config.menu_font,
                    text_pointsize=self.dvd_config.menu_font_point_size,
                    text_color=self.dvd_config.menu_font_color,
                    position="top",
                    background_color=self.dvd_config.menu_background_color,
                    opacity=0.9,
                    x_offset=0,  # -10 if page_number == 0 else 0,
                )

                if result == -1:
                    return -1, message

            result, message = _create_canvas_files(
                width=canvas_width,
                height=canvas_height,
                canvas_overlay_file=canvas_overlay_file,
                canvas_highlight_file=canvas_highlight_file,
                canvas_select_file=canvas_select_file,
            )

            if result == -1:
                return -1, message

            for cell_coord in spu_pages[page_number]:
                if cell_coord.video_data is None:  # Menu pointer images
                    if "pointer_data" not in cell_coord.cargo:
                        return -1, "Error: pointer_data not in cell_coord.cargo"

                    pointer_data: "_Menu_Pointer_Data" = cell_coord.cargo[
                        "pointer_data"
                    ]

                    (
                        left_pointer_overlay_file,
                        left_pointer_highlight_file,
                        left_pointer_select_file,
                        _,
                    ) = cell_coord.get_mask_filenames(pointer_data.left_icon_path)

                    (
                        right_pointer_overlay_file,
                        right_pointer_highlight_file,
                        right_pointer_select_file,
                        _,
                    ) = cell_coord.get_mask_filenames(pointer_data.right_icon_path)

                    result, message = _create_outline_files(
                        width=pointer_data.width,
                        height=pointer_data.height,
                        overlay_file=left_pointer_overlay_file,
                        highlight_file=left_pointer_highlight_file,
                        selected_file=left_pointer_select_file,
                        highlight_border_colour="gold",
                        select_border_colour="white",
                    )

                    if result == -1:
                        return -1, message

                    result, message = _create_outline_files(
                        width=pointer_data.width,
                        height=pointer_data.height,
                        overlay_file=right_pointer_overlay_file,
                        highlight_file=right_pointer_highlight_file,
                        selected_file=right_pointer_select_file,
                        highlight_border_colour="gold",
                        select_border_colour="white",
                    )

                    if result == -1:
                        return -1, message

                    # Overlay the pointer outline files on the canvas
                    left_overlay_files = (
                        (canvas_overlay_file, left_pointer_overlay_file),
                        (canvas_select_file, left_pointer_select_file),
                        (canvas_highlight_file, left_pointer_highlight_file),
                        (canvas_images_file, pointer_data.left_icon_path),
                    )

                    right_overlay_files = (
                        (canvas_overlay_file, right_pointer_overlay_file),
                        (canvas_select_file, right_pointer_select_file),
                        (canvas_highlight_file, right_pointer_highlight_file),
                        (canvas_images_file, pointer_data.right_icon_path),
                    )

                    result, message = _overlay_files(
                        x=pointer_data.left_x_offset,
                        y=pointer_data.left_y_offset,
                        files=left_overlay_files,
                    )

                    if result == -1:
                        return -1, message

                    result, message = _overlay_files(
                        x=pointer_data.right_x_offset,
                        y=pointer_data.right_y_offset,
                        files=right_overlay_files,
                    )

                    if result == -1:
                        return -1, message

                else:  # Vido Button images
                    (
                        button_overlay_file,
                        button_highlight_file,
                        button_select_file,
                        button_text_file,
                    ) = cell_coord.get_mask_filenames()

                    width, height, message = dvdarch_utils.Get_Image_Size(
                        button_text_file
                    )

                    if width == -1 or height == -1:
                        return -1, message

                    # Create button outline files
                    result, message = _create_outline_files(
                        width=cell_coord.width,
                        height=cell_coord.height,
                        overlay_file=button_overlay_file,
                        highlight_file=button_highlight_file,
                        selected_file=button_select_file,
                        highlight_border_colour="gold",
                        select_border_colour="white",
                    )

                    if result == -1:
                        return -1, message

                    # Overlay the button outline files on the canvas
                    overlay_files = (
                        (canvas_overlay_file, button_overlay_file),
                        (canvas_select_file, button_select_file),
                        (canvas_highlight_file, button_highlight_file),
                        (canvas_images_file, button_text_file),
                    )

                    result, message = _overlay_files(
                        x=cell_coord.x0, y=cell_coord.y0, files=overlay_files
                    )

                    if result == -1:
                        return -1, message
        return 1, ""

    def _resize_menu_button_images(
        self, cell_coords: list[_Cell_Coord]
    ) -> tuple[int, str]:
        """Resize the menu buttons to fit on the grid layout

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok

        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        for cell_coord in cell_coords:
            if (
                cell_coord.video_data is None
                or cell_coord.video_data.menu_image_file_path == ""
            ):
                continue

            result, message = dvdarch_utils.Resize_Image(
                input_file=cell_coord.video_data.menu_image_file_path,
                out_file=cell_coord.video_data.menu_image_file_path,
                width=cell_coord.width,
                height=cell_coord.height,
                ignore_aspect=True,
            )

            if result == -1:
                return -1, message

        return 1, ""

    def _extract_menu_images(self) -> tuple[int, str]:
        """Extracts a random video image for the menu button

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        for video_data in self.dvd_config.input_videos:
            # Refresh the encoding info in case of bad data - this should not happen, but I just got bit
            video_data.encoding_info = dvdarch_utils.Get_File_Encoding_Info(
                video_data.video_path
            )

            if video_data.encoding_info.error != "":
                return -1, video_data.encoding_info.error

            if video_data.encoding_info.video_frame_count <= 0:
                return -1, f"No video frame count found for {video_data.video_path}"

            if (
                video_data.video_file_settings.menu_button_frame == -1
                or video_data.video_file_settings.menu_button_frame
                > video_data.encoding_info.video_frame_count
            ):  # No frame number provided, pick a random frame OR the selected menu frame is > number of frames in
                # the video. so choose a random frame - this is a technical error, but one I can live with
                menu_image_frame = randint(
                    1, video_data.encoding_info.video_frame_count
                )
            else:
                menu_image_frame = video_data.video_file_settings.menu_button_frame

            if menu_image_frame > video_data.encoding_info.video_frame_count:
                return (
                    -1,
                    (
                        f"{menu_image_frame=} is greater than video frame count"
                        f" {video_data.encoding_info.video_frame_count}"
                    ),
                )

            (
                result,
                image_file,
            ) = dvdarch_utils.Generate_Menu_Image_From_File(
                video_file=video_data.video_path,
                frame_number=menu_image_frame,
                out_folder=self._menu_image_folder,
            )

            if result == -1:
                return result, image_file
            else:
                video_data.menu_image_file_path = image_file

        return 1, ""

    def _convert_to_m2v(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """
        Converts the background_canvas_images_file into a short video stream for the DVD menu

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()

        path_name, file_name, file_extn = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for cell_coord in cell_coords:
            if cell_coord.video_data is None:
                continue

            if prev_page != cell_coord.page:
                prev_page = cell_coord.page

                background_canvas_images_file = file_handler.file_join(
                    path_name, f"{file_name}_images_{cell_coord.page}", file_extn
                )

                jpg_file = file_handler.file_join(
                    path_name, f"{file_name}_jpgcvrt_{cell_coord.page}", "jpg"
                )

                m2v_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "m2v"
                )

                if not file_handler.file_exists(background_canvas_images_file):
                    return (
                        -1,
                        f"Sys Error : {background_canvas_images_file} does not exist!",
                    )

                if self._dvd_config.video_standard == sys_consts.PAL:
                    frame_rate = sys_consts.PAL_SPECS.frame_rate
                else:  # NTSC
                    frame_rate = sys_consts.NTSC_SPECS.frame_rate

                # In theory FFMPEG should take png and make this step unnecessary TODO look into how ffmeg was compiled
                result, message = Execute_Check_Output(
                    [sys_consts.CONVERT, background_canvas_images_file, jpg_file],
                    debug=False,
                )

                if result == -1:
                    return -1, message

                command = [
                    sys_consts.FFMPG,
                    "-loop",
                    "1",
                    "-i",
                    jpg_file,
                    "-f",
                    "lavfi",
                    "-i",
                    "anullsrc=r=48000:cl=stereo",
                    "-t",
                    "10",
                    "-c:v",
                    "mpeg2video",
                    "-q:v",
                    "2",
                    "-r",
                    f"{frame_rate}",
                    "-c:a",
                    "mp2",
                    "-b:a",
                    "192k",
                    "-y",
                    m2v_file,
                ]

                result, message = dvdarch_utils.Execute_Check_Output(
                    command, debug=False
                )

                if result == -1:
                    return -1, message

        return 1, ""

    def _convert_audio(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Generates the audio for the DVD menu. By default it is a empty soundtrack
        TODO Allow user selection of an audio file

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for cell_coord in cell_coords:
            if cell_coord.video_data is None:
                continue

            if prev_page != cell_coord.page:
                prev_page = cell_coord.page

                ac3_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "ac3"
                )

                # TODO Allow an audio file of the users choice
                # Generate an empty audio file
                commands = [
                    sys_consts.FFMPG,
                    "-f",
                    "lavfi",
                    "-i",
                    "anullsrc=channel_layout=5.1:sample_rate=48000",
                    "-t",
                    "10",
                    "-b:a",
                    "224000",
                    "-c:a",
                    "ac3",
                    ac3_file,
                ]

                result, message = Execute_Check_Output(commands=commands)

                if result == -1:
                    return -1, message

        return 1, ""

    def _multiplex_audio_video(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Multiplexes the menu m2v file and the menu ac3 file to produce the menu mgp file

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for cell_coord in cell_coords:
            if cell_coord.video_data is None:
                continue

            if prev_page != cell_coord.page:
                prev_page = cell_coord.page

                ac3_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "ac3"
                )
                m2v_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "m2v"
                )
                menu_video_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{cell_coord.page}", "mpg"
                )

                commands = [
                    sys_consts.MPLEX,
                    "-f",
                    "8",
                    "-o",
                    menu_video_file,
                    m2v_file,
                    ac3_file,
                ]

                result, message = Execute_Check_Output(commands=commands)

                if result == -1:
                    return -1, message
        return 1, ""

    def _create_menu_mpg(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Creates the DVD menu mpg file via the dvdauthor application spumux

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int,str]:
            - arg1 1: ok, -1: fail
            - arg2: error message or "" if ok
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()

        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        prev_page = -1

        for coord in cell_coords:
            if prev_page != coord.page:
                prev_page = coord.page

                menu_video_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_{coord.page}", "mpg"
                )
                menu_video_buttons_file = file_handler.file_join(
                    path_name, f"{file_name}_menu_video_buttons_{coord.page}", "mpg"
                )

                spumux_xml = file_handler.file_join(
                    path_name, f"spumux_{coord.page}", "xml"
                )

                env = {"VIDEO_FORMAT": self.dvd_config.video_standard}

                commands = [
                    sys_consts.SPUMUX,
                    "-m",
                    "dvd",
                    "-s",
                    str(0),
                    spumux_xml,
                ]

                try:
                    input_file = open(menu_video_file, "rb")
                    output_file = open(menu_video_buttons_file, "wb")

                    result = subprocess.run(
                        commands,
                        env=env,
                        stdin=input_file,
                        stdout=output_file,
                        stderr=subprocess.PIPE,
                        text=True,
                    )

                    if result.returncode != 0:
                        return -1, result.stderr.strip()
                except IOError as e:
                    return -1, f"Error opening file: {e}"
                finally:
                    input_file.close()
                    output_file.close()

        return 1, ""

    def _create_dvd_image(self, cell_coords: list[_Cell_Coord]) -> tuple[int, str]:
        """Creates the DVD Folder/File structure via the dvdauthor application

        Args:
            cell_coords (list[_Cell_Coord]): The calculated grid layout

        Returns:
            tuple[int, str]: arg 1 : 1 Ok, -1 Fail, arg 2 : "" if Ok otherwise Error Message
        """
        assert isinstance(cell_coords, list), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )
        assert all(isinstance(item, _Cell_Coord) for item in cell_coords), (
            f"{cell_coords=}. Must be a list of _Cell_Coord"
        )

        file_handler = file_utils.File()
        path_name, file_name, _ = file_handler.split_file_path(
            self._background_canvas_file
        )

        # Create the main DVD author structure
        dvd_author_dict = {
            "dvdauthor": {
                "@dest": "DVD",
                "@jumppad": "1",
                "vmgm": {"menus": {}},
                "titleset": [],
            }
        }

        spu_pages = {}
        pgcs = []
        title_set_index = 0

        # Create the DVD menu spu pages dictionary
        for cell_index, cell_coord in enumerate(cell_coords):
            page_number = cell_coord.page

            if page_number not in spu_pages:
                spu_pages[page_number] = []

            spu_pages[page_number].append(cell_coord)

        # Build dictionary of menu/button/title entries
        for page_index, spu_page in enumerate(spu_pages):
            prev_index = page_index - 1 if page_index > 0 else len(spu_pages) - 1
            next_index = page_index + 1 if page_index < len(spu_pages) - 1 else 0

            # Note: The buttons. titles and menu indicies are 1 based so need to add 1
            menu_video_file = file_handler.file_join(
                path_name, f"{file_name}_menu_video_buttons_{page_index}.mpg"
            )
            pgc = {"vob": {"@pause": "inf"}, "button": []}

            for cell_coord in spu_pages[spu_page]:
                pgc["vob"]["@file"] = menu_video_file
                if cell_coord.name.startswith("button"):
                    pgc["button"].append({
                        "@name": f"{cell_coord.name}",  # cell_coord.name,
                        "#text": f"jump title {title_set_index + 1};",
                    })
                elif cell_coord.name.startswith("left"):
                    pgc["button"].append({
                        "@name": f"{cell_coord.name}",  # cell_coord.name,
                        "#text": f"jump vmgm menu {prev_index + 1};",
                    })
                elif cell_coord.name.startswith("right"):
                    pgc["button"].append({
                        "@name": f"{cell_coord.name}",  # cell_coord.name,
                        "#text": f"jump vmgm menu {next_index + 1};",
                    })

                if cell_coord.video_data is not None:
                    vob_file = file_handler.file_join(
                        self._vob_folder, cell_coord.video_data.video_file, "vob"
                    )

                    dvd_author_dict["dvdauthor"]["titleset"].append({
                        "titles": {
                            "video": {
                                "@format": self.dvd_config.video_standard,
                                "@aspect": cell_coord.video_data.encoding_info.video_ar,
                            },
                            "pgc": {
                                "vob": {"@file": vob_file},
                                "post": {f"call vmgm menu {page_index + 1};"},
                            },
                        }
                    })

                    title_set_index += 1

            pgcs.append(pgc)

        dvd_author_dict["dvdauthor"]["vmgm"]["menus"] = {
            "video": {
                "@format": self.dvd_config.video_standard,
                "@aspect": self.dvd_config.menu_aspect_ratio,
            },
            "pgc": pgcs,
        }

        # Generate the DVDAuthor XML file
        dvd_author_file = file_handler.file_join(path_name, "dvd_author", "xml")

        try:
            with open(dvd_author_file, "w") as result_file:
                (
                    xmltodict.unparse(
                        input_dict=dvd_author_dict, output=result_file, pretty=True
                    )
                )
        except IOError:
            return -1, f"Sys Error: Could Not Write {dvd_author_file}"

        # Run the DVDauthor XML control file
        env = {"VIDEO_FORMAT": self.dvd_config.video_standard}

        commands = [
            sys_consts.DVDAUTHOR,
            "-x",
            dvd_author_file,
            "-o",
            self._dvd_out_folder,
        ]

        # Had to use shell if I did not run like this
        result = subprocess.run(
            commands, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )

        if result.returncode == 0:
            iso_folder = file_handler.file_join(self._iso_out_folder, "dvd_iso")

            return dvdarch_utils.Create_DVD_Iso(self._dvd_out_folder, iso_folder)

        else:
            return -1, result.stderr.strip()
